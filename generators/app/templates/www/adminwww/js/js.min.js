/*!
 * Bootstrap v3.0.3 (http://getbootstrap.com)
 * Copyright 2013 Twitter, Inc.
 * Licensed under http://www.apache.org/licenses/LICENSE-2.0
 */
if (document.createElement("canvas").getContext || !function() {
    function T() {
        return this.context_ || (this.context_ = new W(this));
    }
    function G(i, j, m) {
        var Z = O.call(arguments, 2);
        return function() {
            return i.apply(j, Z.concat(O.call(arguments)));
        };
    }
    function AD(Z) {
        return String(Z).replace(/&/g, "&amp;").replace(/"/g, "&quot;");
    }
    function r(i) {
        if (i.namespaces.g_vml_ || i.namespaces.add("g_vml_", "urn:schemas-microsoft-com:vml", "#default#VML"), 
        i.namespaces.g_o_ || i.namespaces.add("g_o_", "urn:schemas-microsoft-com:office:office", "#default#VML"), 
        !i.styleSheets.ex_canvas_) {
            var Z = i.createStyleSheet();
            Z.owningElement.id = "ex_canvas_", Z.cssText = "canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}";
        }
    }
    function S(i) {
        var Z = i.srcElement;
        switch (i.propertyName) {
          case "width":
            Z.getContext().clearRect(), Z.style.width = Z.attributes.width.nodeValue + "px", 
            Z.firstChild.style.width = Z.clientWidth + "px";
            break;

          case "height":
            Z.getContext().clearRect(), Z.style.height = Z.attributes.height.nodeValue + "px", 
            Z.firstChild.style.height = Z.clientHeight + "px";
        }
    }
    function w(i) {
        var Z = i.srcElement;
        Z.firstChild && (Z.firstChild.style.width = Z.clientWidth + "px", Z.firstChild.style.height = Z.clientHeight + "px");
    }
    function V() {
        return [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ];
    }
    function d(m, j) {
        for (var i = V(), Z = 0; 3 > Z; Z++) for (var AF = 0; 3 > AF; AF++) {
            for (var p = 0, AE = 0; 3 > AE; AE++) p += m[Z][AE] * j[AE][AF];
            i[Z][AF] = p;
        }
        return i;
    }
    function Q(i, Z) {
        Z.fillStyle = i.fillStyle, Z.lineCap = i.lineCap, Z.lineJoin = i.lineJoin, Z.lineWidth = i.lineWidth, 
        Z.miterLimit = i.miterLimit, Z.shadowBlur = i.shadowBlur, Z.shadowColor = i.shadowColor, 
        Z.shadowOffsetX = i.shadowOffsetX, Z.shadowOffsetY = i.shadowOffsetY, Z.strokeStyle = i.strokeStyle, 
        Z.globalAlpha = i.globalAlpha, Z.font = i.font, Z.textAlign = i.textAlign, Z.textBaseline = i.textBaseline, 
        Z.arcScaleX_ = i.arcScaleX_, Z.arcScaleY_ = i.arcScaleY_, Z.lineScale_ = i.lineScale_;
    }
    function g(i) {
        var m = i.indexOf("(", 3), Z = i.indexOf(")", m + 1), j = i.substring(m + 1, Z).split(",");
        return 4 == j.length && "a" == i.substr(3, 1) ? alpha = Number(j[3]) : j[3] = 1, 
        j;
    }
    function C(Z) {
        return parseFloat(Z) / 100;
    }
    function N(i, j, Z) {
        return Math.min(Z, Math.max(j, i));
    }
    function c(AF) {
        var j, i, Z;
        if (h = parseFloat(AF[0]) / 360 % 360, h < 0 && h++, s = N(C(AF[1]), 0, 1), l = N(C(AF[2]), 0, 1), 
        0 == s) j = i = Z = l; else {
            var m = l < .5 ? l * (1 + s) : l + s - l * s, AE = 2 * l - m;
            j = A(AE, m, h + 1 / 3), i = A(AE, m, h), Z = A(AE, m, h - 1 / 3);
        }
        return "#" + I[Math.floor(255 * j)] + I[Math.floor(255 * i)] + I[Math.floor(255 * Z)];
    }
    function A(i, Z, j) {
        return 0 > j && j++, j > 1 && j--, 1 > 6 * j ? i + 6 * (Z - i) * j : 1 > 2 * j ? Z : 2 > 3 * j ? i + (Z - i) * (2 / 3 - j) * 6 : i;
    }
    function Y(Z) {
        var AE, p = 1;
        if (Z = String(Z), "#" == Z.charAt(0)) AE = Z; else if (/^rgb/.test(Z)) {
            for (var AF, m = g(Z), AE = "#", j = 0; 3 > j; j++) AF = -1 != m[j].indexOf("%") ? Math.floor(255 * C(m[j])) : Number(m[j]), 
            AE += I[N(AF, 0, 255)];
            p = m[3];
        } else if (/^hsl/.test(Z)) {
            var m = g(Z);
            AE = c(m), p = m[3];
        } else AE = B[Z] || Z;
        return {
            color: AE,
            alpha: p
        };
    }
    function X(Z) {
        if (f[Z]) return f[Z];
        var m = document.createElement("div"), j = m.style;
        try {
            j.font = Z;
        } catch (i) {}
        return f[Z] = {
            style: j.fontStyle || L.style,
            variant: j.fontVariant || L.variant,
            weight: j.fontWeight || L.weight,
            size: j.fontSize || L.size,
            family: j.fontFamily || L.family
        };
    }
    function P(j, i) {
        var Z = {};
        for (var AF in j) Z[AF] = j[AF];
        var AE = parseFloat(i.currentStyle.fontSize), m = parseFloat(j.size);
        return "number" == typeof j.size ? Z.size = j.size : -1 != j.size.indexOf("px") ? Z.size = m : -1 != j.size.indexOf("em") ? Z.size = AE * m : -1 != j.size.indexOf("%") ? Z.size = AE / 100 * m : -1 != j.size.indexOf("pt") ? Z.size = m / .75 : Z.size = AE, 
        Z.size *= .981, Z;
    }
    function AA(Z) {
        return Z.style + " " + Z.variant + " " + Z.weight + " " + Z.size + "px " + Z.family;
    }
    function t(Z) {
        switch (Z) {
          case "butt":
            return "flat";

          case "round":
            return "round";

          case "square":
          default:
            return "square";
        }
    }
    function W(i) {
        this.m_ = V(), this.mStack_ = [], this.aStack_ = [], this.currentPath_ = [], this.strokeStyle = "#000", 
        this.fillStyle = "#000", this.lineWidth = 1, this.lineJoin = "miter", this.lineCap = "butt", 
        this.miterLimit = 1 * D, this.globalAlpha = 1, this.font = "10px sans-serif", this.textAlign = "left", 
        this.textBaseline = "alphabetic", this.canvas = i;
        var Z = i.ownerDocument.createElement("div");
        Z.style.width = i.clientWidth + "px", Z.style.height = i.clientHeight + "px", Z.style.overflow = "hidden", 
        Z.style.position = "absolute", i.appendChild(Z), this.element_ = Z, this.arcScaleX_ = 1, 
        this.arcScaleY_ = 1, this.lineScale_ = 1;
    }
    function e(Z, m, j, i) {
        Z.currentPath_.push({
            type: "bezierCurveTo",
            cp1x: m.x,
            cp1y: m.y,
            cp2x: j.x,
            cp2y: j.y,
            x: i.x,
            y: i.y
        }), Z.currentX_ = i.x, Z.currentY_ = i.y;
    }
    function R(j, AE) {
        var i = Y(j.strokeStyle), m = i.color, p = i.alpha * j.globalAlpha, Z = j.lineScale_ * j.lineWidth;
        1 > Z && (p *= Z), AE.push("<g_vml_:stroke", ' opacity="', p, '"', ' joinstyle="', j.lineJoin, '"', ' miterlimit="', j.miterLimit, '"', ' endcap="', t(j.lineCap), '"', ' weight="', Z, 'px"', ' color="', m, '" />');
    }
    function a(AO, AG, Ah, AP) {
        var AH = AO.fillStyle, AY = AO.arcScaleX_, AX = AO.arcScaleY_, Z = AP.x - Ah.x, m = AP.y - Ah.y;
        if (AH instanceof v) {
            var AL = 0, Ac = {
                x: 0,
                y: 0
            }, AU = 0, AK = 1;
            if ("gradient" == AH.type_) {
                var AJ = AH.x0_ / AY, j = AH.y0_ / AX, AI = AH.x1_ / AY, Aj = AH.y1_ / AX, Ag = AO.getCoords_(AJ, j), Af = AO.getCoords_(AI, Aj), AE = Af.x - Ag.x, p = Af.y - Ag.y;
                AL = 180 * Math.atan2(AE, p) / Math.PI, 0 > AL && (AL += 360), 1e-6 > AL && (AL = 0);
            } else {
                var Ag = AO.getCoords_(AH.x0_, AH.y0_);
                Ac = {
                    x: (Ag.x - Ah.x) / Z,
                    y: (Ag.y - Ah.y) / m
                }, Z /= AY * D, m /= AX * D;
                var Aa = z.max(Z, m);
                AU = 2 * AH.r0_ / Aa, AK = 2 * AH.r1_ / Aa - AU;
            }
            var AS = AH.colors_;
            AS.sort(function(Ak, i) {
                return Ak.offset - i.offset;
            });
            for (var AN = AS.length, AR = AS[0].color, AQ = AS[AN - 1].color, AW = AS[0].alpha * AO.globalAlpha, AV = AS[AN - 1].alpha * AO.globalAlpha, Ab = [], Ae = 0; AN > Ae; Ae++) {
                var AM = AS[Ae];
                Ab.push(AM.offset * AK + AU + " " + AM.color);
            }
            AG.push('<g_vml_:fill type="', AH.type_, '"', ' method="none" focus="100%"', ' color="', AR, '"', ' color2="', AQ, '"', ' colors="', Ab.join(","), '"', ' opacity="', AV, '"', ' g_o_:opacity2="', AW, '"', ' angle="', AL, '"', ' focusposition="', Ac.x, ",", Ac.y, '" />');
        } else if (AH instanceof u) {
            if (Z && m) {
                var AF = -Ah.x, AZ = -Ah.y;
                AG.push("<g_vml_:fill", ' position="', AF / Z * AY * AY, ",", AZ / m * AX * AX, '"', ' type="tile"', ' src="', AH.src_, '" />');
            }
        } else {
            var Ai = Y(AO.fillStyle), AT = Ai.color, Ad = Ai.alpha * AO.globalAlpha;
            AG.push('<g_vml_:fill color="', AT, '" opacity="', Ad, '" />');
        }
    }
    function H(Z) {
        return isFinite(Z[0][0]) && isFinite(Z[0][1]) && isFinite(Z[1][0]) && isFinite(Z[1][1]) && isFinite(Z[2][0]) && isFinite(Z[2][1]);
    }
    function y(i, Z, j) {
        if (H(Z) && (i.m_ = Z, j)) {
            var p = Z[0][0] * Z[1][1] - Z[0][1] * Z[1][0];
            i.lineScale_ = k(b(p));
        }
    }
    function v(Z) {
        this.type_ = Z, this.x0_ = 0, this.y0_ = 0, this.r0_ = 0, this.x1_ = 0, this.y1_ = 0, 
        this.r1_ = 0, this.colors_ = [];
    }
    function u(i, Z) {
        switch (q(i), Z) {
          case "repeat":
          case null:
          case "":
            this.repetition_ = "repeat";
            break;

          case "repeat-x":
          case "repeat-y":
          case "no-repeat":
            this.repetition_ = Z;
            break;

          default:
            n("SYNTAX_ERR");
        }
        this.src_ = i.src, this.width_ = i.width, this.height_ = i.height;
    }
    function n(Z) {
        throw new o(Z);
    }
    function q(Z) {
        Z && 1 == Z.nodeType && "IMG" == Z.tagName || n("TYPE_MISMATCH_ERR"), "complete" != Z.readyState && n("INVALID_STATE_ERR");
    }
    function o(Z) {
        this.code = this[Z], this.message = Z + ": DOM Exception " + this.code;
    }
    var z = Math, K = z.round, J = z.sin, U = z.cos, b = z.abs, k = z.sqrt, D = 10, F = D / 2, O = Array.prototype.slice;
    r(document);
    var E = {
        init: function(Z) {
            if (/MSIE/.test(navigator.userAgent) && !window.opera) {
                var i = Z || document;
                i.createElement("canvas"), i.attachEvent("onreadystatechange", G(this.init_, this, i));
            }
        },
        init_: function(m) {
            for (var j = m.getElementsByTagName("canvas"), Z = 0; Z < j.length; Z++) this.initElement(j[Z]);
        },
        initElement: function(i) {
            if (!i.getContext) {
                i.getContext = T, r(i.ownerDocument), i.innerHTML = "", i.attachEvent("onpropertychange", S), 
                i.attachEvent("onresize", w);
                var Z = i.attributes;
                Z.width && Z.width.specified ? i.style.width = Z.width.nodeValue + "px" : i.width = i.clientWidth, 
                Z.height && Z.height.specified ? i.style.height = Z.height.nodeValue + "px" : i.height = i.clientHeight;
            }
            return i;
        }
    };
    E.init();
    for (var I = [], AC = 0; 16 > AC; AC++) for (var AB = 0; 16 > AB; AB++) I[16 * AC + AB] = AC.toString(16) + AB.toString(16);
    var B = {
        aliceblue: "#F0F8FF",
        antiquewhite: "#FAEBD7",
        aquamarine: "#7FFFD4",
        azure: "#F0FFFF",
        beige: "#F5F5DC",
        bisque: "#FFE4C4",
        black: "#000000",
        blanchedalmond: "#FFEBCD",
        blueviolet: "#8A2BE2",
        brown: "#A52A2A",
        burlywood: "#DEB887",
        cadetblue: "#5F9EA0",
        chartreuse: "#7FFF00",
        chocolate: "#D2691E",
        coral: "#FF7F50",
        cornflowerblue: "#6495ED",
        cornsilk: "#FFF8DC",
        crimson: "#DC143C",
        cyan: "#00FFFF",
        darkblue: "#00008B",
        darkcyan: "#008B8B",
        darkgoldenrod: "#B8860B",
        darkgray: "#A9A9A9",
        darkgreen: "#006400",
        darkgrey: "#A9A9A9",
        darkkhaki: "#BDB76B",
        darkmagenta: "#8B008B",
        darkolivegreen: "#556B2F",
        darkorange: "#FF8C00",
        darkorchid: "#9932CC",
        darkred: "#8B0000",
        darksalmon: "#E9967A",
        darkseagreen: "#8FBC8F",
        darkslateblue: "#483D8B",
        darkslategray: "#2F4F4F",
        darkslategrey: "#2F4F4F",
        darkturquoise: "#00CED1",
        darkviolet: "#9400D3",
        deeppink: "#FF1493",
        deepskyblue: "#00BFFF",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1E90FF",
        firebrick: "#B22222",
        floralwhite: "#FFFAF0",
        forestgreen: "#228B22",
        gainsboro: "#DCDCDC",
        ghostwhite: "#F8F8FF",
        gold: "#FFD700",
        goldenrod: "#DAA520",
        grey: "#808080",
        greenyellow: "#ADFF2F",
        honeydew: "#F0FFF0",
        hotpink: "#FF69B4",
        indianred: "#CD5C5C",
        indigo: "#4B0082",
        ivory: "#FFFFF0",
        khaki: "#F0E68C",
        lavender: "#E6E6FA",
        lavenderblush: "#FFF0F5",
        lawngreen: "#7CFC00",
        lemonchiffon: "#FFFACD",
        lightblue: "#ADD8E6",
        lightcoral: "#F08080",
        lightcyan: "#E0FFFF",
        lightgoldenrodyellow: "#FAFAD2",
        lightgreen: "#90EE90",
        lightgrey: "#D3D3D3",
        lightpink: "#FFB6C1",
        lightsalmon: "#FFA07A",
        lightseagreen: "#20B2AA",
        lightskyblue: "#87CEFA",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#B0C4DE",
        lightyellow: "#FFFFE0",
        limegreen: "#32CD32",
        linen: "#FAF0E6",
        magenta: "#FF00FF",
        mediumaquamarine: "#66CDAA",
        mediumblue: "#0000CD",
        mediumorchid: "#BA55D3",
        mediumpurple: "#9370DB",
        mediumseagreen: "#3CB371",
        mediumslateblue: "#7B68EE",
        mediumspringgreen: "#00FA9A",
        mediumturquoise: "#48D1CC",
        mediumvioletred: "#C71585",
        midnightblue: "#191970",
        mintcream: "#F5FFFA",
        mistyrose: "#FFE4E1",
        moccasin: "#FFE4B5",
        navajowhite: "#FFDEAD",
        oldlace: "#FDF5E6",
        olivedrab: "#6B8E23",
        orange: "#FFA500",
        orangered: "#FF4500",
        orchid: "#DA70D6",
        palegoldenrod: "#EEE8AA",
        palegreen: "#98FB98",
        paleturquoise: "#AFEEEE",
        palevioletred: "#DB7093",
        papayawhip: "#FFEFD5",
        peachpuff: "#FFDAB9",
        peru: "#CD853F",
        pink: "#FFC0CB",
        plum: "#DDA0DD",
        powderblue: "#B0E0E6",
        rosybrown: "#BC8F8F",
        royalblue: "#4169E1",
        saddlebrown: "#8B4513",
        salmon: "#FA8072",
        sandybrown: "#F4A460",
        seagreen: "#2E8B57",
        seashell: "#FFF5EE",
        sienna: "#A0522D",
        skyblue: "#87CEEB",
        slateblue: "#6A5ACD",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#FFFAFA",
        springgreen: "#00FF7F",
        steelblue: "#4682B4",
        tan: "#D2B48C",
        thistle: "#D8BFD8",
        tomato: "#FF6347",
        turquoise: "#40E0D0",
        violet: "#EE82EE",
        wheat: "#F5DEB3",
        whitesmoke: "#F5F5F5",
        yellowgreen: "#9ACD32"
    }, L = {
        style: "normal",
        variant: "normal",
        weight: "normal",
        size: 10,
        family: "sans-serif"
    }, f = {}, M = W.prototype;
    M.clearRect = function() {
        this.textMeasureEl_ && (this.textMeasureEl_.removeNode(!0), this.textMeasureEl_ = null), 
        this.element_.innerHTML = "";
    }, M.beginPath = function() {
        this.currentPath_ = [];
    }, M.moveTo = function(i, Z) {
        var j = this.getCoords_(i, Z);
        this.currentPath_.push({
            type: "moveTo",
            x: j.x,
            y: j.y
        }), this.currentX_ = j.x, this.currentY_ = j.y;
    }, M.lineTo = function(i, Z) {
        var j = this.getCoords_(i, Z);
        this.currentPath_.push({
            type: "lineTo",
            x: j.x,
            y: j.y
        }), this.currentX_ = j.x, this.currentY_ = j.y;
    }, M.bezierCurveTo = function(j, i, AI, AH, AG, AE) {
        var Z = this.getCoords_(AG, AE), AF = this.getCoords_(j, i), m = this.getCoords_(AI, AH);
        e(this, AF, m, Z);
    }, M.quadraticCurveTo = function(AG, j, i, Z) {
        var AF = this.getCoords_(AG, j), AE = this.getCoords_(i, Z), AH = {
            x: this.currentX_ + 2 / 3 * (AF.x - this.currentX_),
            y: this.currentY_ + 2 / 3 * (AF.y - this.currentY_)
        }, m = {
            x: AH.x + (AE.x - this.currentX_) / 3,
            y: AH.y + (AE.y - this.currentY_) / 3
        };
        e(this, AH, m, AE);
    }, M.arc = function(AJ, AH, AI, AE, i, j) {
        AI *= D;
        var AN = j ? "at" : "wa", AK = AJ + U(AE) * AI - F, AM = AH + J(AE) * AI - F, Z = AJ + U(i) * AI - F, AL = AH + J(i) * AI - F;
        AK != Z || j || (AK += .125);
        var m = this.getCoords_(AJ, AH), AG = this.getCoords_(AK, AM), AF = this.getCoords_(Z, AL);
        this.currentPath_.push({
            type: AN,
            x: m.x,
            y: m.y,
            radius: AI,
            xStart: AG.x,
            yStart: AG.y,
            xEnd: AF.x,
            yEnd: AF.y
        });
    }, M.rect = function(j, i, Z, m) {
        this.moveTo(j, i), this.lineTo(j + Z, i), this.lineTo(j + Z, i + m), this.lineTo(j, i + m), 
        this.closePath();
    }, M.strokeRect = function(j, i, Z, m) {
        var p = this.currentPath_;
        this.beginPath(), this.moveTo(j, i), this.lineTo(j + Z, i), this.lineTo(j + Z, i + m), 
        this.lineTo(j, i + m), this.closePath(), this.stroke(), this.currentPath_ = p;
    }, M.fillRect = function(j, i, Z, m) {
        var p = this.currentPath_;
        this.beginPath(), this.moveTo(j, i), this.lineTo(j + Z, i), this.lineTo(j + Z, i + m), 
        this.lineTo(j, i + m), this.closePath(), this.fill(), this.currentPath_ = p;
    }, M.createLinearGradient = function(i, m, Z, j) {
        var p = new v("gradient");
        return p.x0_ = i, p.y0_ = m, p.x1_ = Z, p.y1_ = j, p;
    }, M.createRadialGradient = function(m, AE, j, i, p, Z) {
        var AF = new v("gradientradial");
        return AF.x0_ = m, AF.y0_ = AE, AF.r0_ = j, AF.x1_ = i, AF.y1_ = p, AF.r1_ = Z, 
        AF;
    }, M.drawImage = function(AO, j) {
        var AH, AF, AJ, AV, AM, AK, AQ, AX, AI = AO.runtimeStyle.width, AN = AO.runtimeStyle.height;
        AO.runtimeStyle.width = "auto", AO.runtimeStyle.height = "auto";
        var AG = AO.width, AT = AO.height;
        if (AO.runtimeStyle.width = AI, AO.runtimeStyle.height = AN, 3 == arguments.length) AH = arguments[1], 
        AF = arguments[2], AM = AK = 0, AQ = AJ = AG, AX = AV = AT; else if (5 == arguments.length) AH = arguments[1], 
        AF = arguments[2], AJ = arguments[3], AV = arguments[4], AM = AK = 0, AQ = AG, AX = AT; else {
            if (9 != arguments.length) throw Error("Invalid number of arguments");
            AM = arguments[1], AK = arguments[2], AQ = arguments[3], AX = arguments[4], AH = arguments[5], 
            AF = arguments[6], AJ = arguments[7], AV = arguments[8];
        }
        var AW = this.getCoords_(AH, AF), AU = [], Z = 10, AE = 10;
        if (AU.push(" <g_vml_:group", ' coordsize="', D * Z, ",", D * AE, '"', ' coordorigin="0,0"', ' style="width:', Z, "px;height:", AE, "px;position:absolute;"), 
        1 != this.m_[0][0] || this.m_[0][1] || 1 != this.m_[1][1] || this.m_[1][0]) {
            var p = [];
            p.push("M11=", this.m_[0][0], ",", "M12=", this.m_[1][0], ",", "M21=", this.m_[0][1], ",", "M22=", this.m_[1][1], ",", "Dx=", K(AW.x / D), ",", "Dy=", K(AW.y / D), "");
            var AS = AW, AR = this.getCoords_(AH + AJ, AF), AP = this.getCoords_(AH, AF + AV), AL = this.getCoords_(AH + AJ, AF + AV);
            AS.x = z.max(AS.x, AR.x, AP.x, AL.x), AS.y = z.max(AS.y, AR.y, AP.y, AL.y), AU.push("padding:0 ", K(AS.x / D), "px ", K(AS.y / D), "px 0;filter:progid:DXImageTransform.Microsoft.Matrix(", p.join(""), ", sizingmethod='clip');");
        } else AU.push("top:", K(AW.y / D), "px;left:", K(AW.x / D), "px;");
        AU.push(' ">', '<g_vml_:image src="', AO.src, '"', ' style="width:', D * AJ, "px;", " height:", D * AV, 'px"', ' cropleft="', AM / AG, '"', ' croptop="', AK / AT, '"', ' cropright="', (AG - AM - AQ) / AG, '"', ' cropbottom="', (AT - AK - AX) / AT, '"', " />", "</g_vml_:group>"), 
        this.element_.insertAdjacentHTML("BeforeEnd", AU.join(""));
    }, M.stroke = function(AM) {
        for (var m = 10, AN = 10, AE = 5e3, AG = {
            x: null,
            y: null
        }, AL = {
            x: null,
            y: null
        }, AH = 0; AH < this.currentPath_.length; AH += AE) {
            var AK = [];
            AK.push("<g_vml_:shape", ' filled="', !!AM, '"', ' style="position:absolute;width:', m, "px;height:", AN, 'px;"', ' coordorigin="0,0"', ' coordsize="', D * m, ",", D * AN, '"', ' stroked="', !AM, '"', ' path="');
            for (var AI = AH; AI < Math.min(AH + AE, this.currentPath_.length); AI++) {
                AI % AE == 0 && AI > 0 && AK.push(" m ", K(this.currentPath_[AI - 1].x), ",", K(this.currentPath_[AI - 1].y));
                var AJ, Z = this.currentPath_[AI];
                switch (Z.type) {
                  case "moveTo":
                    AJ = Z, AK.push(" m ", K(Z.x), ",", K(Z.y));
                    break;

                  case "lineTo":
                    AK.push(" l ", K(Z.x), ",", K(Z.y));
                    break;

                  case "close":
                    AK.push(" x "), Z = null;
                    break;

                  case "bezierCurveTo":
                    AK.push(" c ", K(Z.cp1x), ",", K(Z.cp1y), ",", K(Z.cp2x), ",", K(Z.cp2y), ",", K(Z.x), ",", K(Z.y));
                    break;

                  case "at":
                  case "wa":
                    AK.push(" ", Z.type, " ", K(Z.x - this.arcScaleX_ * Z.radius), ",", K(Z.y - this.arcScaleY_ * Z.radius), " ", K(Z.x + this.arcScaleX_ * Z.radius), ",", K(Z.y + this.arcScaleY_ * Z.radius), " ", K(Z.xStart), ",", K(Z.yStart), " ", K(Z.xEnd), ",", K(Z.yEnd));
                }
                Z && ((null == AG.x || Z.x < AG.x) && (AG.x = Z.x), (null == AL.x || Z.x > AL.x) && (AL.x = Z.x), 
                (null == AG.y || Z.y < AG.y) && (AG.y = Z.y), (null == AL.y || Z.y > AL.y) && (AL.y = Z.y));
            }
            AK.push(' ">'), AM ? a(this, AK, AG, AL) : R(this, AK), AK.push("</g_vml_:shape>"), 
            this.element_.insertAdjacentHTML("beforeEnd", AK.join(""));
        }
    }, M.fill = function() {
        this.stroke(!0);
    }, M.closePath = function() {
        this.currentPath_.push({
            type: "close"
        });
    }, M.getCoords_ = function(j, i) {
        var Z = this.m_;
        return {
            x: D * (j * Z[0][0] + i * Z[1][0] + Z[2][0]) - F,
            y: D * (j * Z[0][1] + i * Z[1][1] + Z[2][1]) - F
        };
    }, M.save = function() {
        var Z = {};
        Q(this, Z), this.aStack_.push(Z), this.mStack_.push(this.m_), this.m_ = d(V(), this.m_);
    }, M.restore = function() {
        this.aStack_.length && (Q(this.aStack_.pop(), this), this.m_ = this.mStack_.pop());
    }, M.translate = function(j, i) {
        var Z = [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ j, i, 1 ] ];
        y(this, d(Z, this.m_), !1);
    }, M.rotate = function(i) {
        var m = U(i), j = J(i), Z = [ [ m, j, 0 ], [ -j, m, 0 ], [ 0, 0, 1 ] ];
        y(this, d(Z, this.m_), !1);
    }, M.scale = function(j, i) {
        this.arcScaleX_ *= j, this.arcScaleY_ *= i;
        var Z = [ [ j, 0, 0 ], [ 0, i, 0 ], [ 0, 0, 1 ] ];
        y(this, d(Z, this.m_), !0);
    }, M.transform = function(p, m, AF, AE, i, Z) {
        var j = [ [ p, m, 0 ], [ AF, AE, 0 ], [ i, Z, 1 ] ];
        y(this, d(j, this.m_), !0);
    }, M.setTransform = function(AE, p, AG, AF, j, i) {
        var Z = [ [ AE, p, 0 ], [ AG, AF, 0 ], [ j, i, 1 ] ];
        y(this, Z, !0);
    }, M.drawText_ = function(AK, AI, AH, AN, AG) {
        var AM = this.m_, AQ = 1e3, i = 0, AP = AQ, AF = {
            x: 0,
            y: 0
        }, AE = [], Z = P(X(this.font), this.element_), j = AA(Z), AR = this.element_.currentStyle, p = this.textAlign.toLowerCase();
        switch (p) {
          case "left":
          case "center":
          case "right":
            break;

          case "end":
            p = "ltr" == AR.direction ? "right" : "left";
            break;

          case "start":
            p = "rtl" == AR.direction ? "right" : "left";
            break;

          default:
            p = "left";
        }
        switch (this.textBaseline) {
          case "hanging":
          case "top":
            AF.y = Z.size / 1.75;
            break;

          case "middle":
            break;

          default:
          case null:
          case "alphabetic":
          case "ideographic":
          case "bottom":
            AF.y = -Z.size / 2.25;
        }
        switch (p) {
          case "right":
            i = AQ, AP = .05;
            break;

          case "center":
            i = AP = AQ / 2;
        }
        var AO = this.getCoords_(AI + AF.x, AH + AF.y);
        AE.push('<g_vml_:line from="', -i, ' 0" to="', AP, ' 0.05" ', ' coordsize="100 100" coordorigin="0 0"', ' filled="', !AG, '" stroked="', !!AG, '" style="position:absolute;width:1px;height:1px;">'), 
        AG ? R(this, AE) : a(this, AE, {
            x: -i,
            y: 0
        }, {
            x: AP,
            y: Z.size
        });
        var AL = AM[0][0].toFixed(3) + "," + AM[1][0].toFixed(3) + "," + AM[0][1].toFixed(3) + "," + AM[1][1].toFixed(3) + ",0,0", AJ = K(AO.x / D) + "," + K(AO.y / D);
        AE.push('<g_vml_:skew on="t" matrix="', AL, '" ', ' offset="', AJ, '" origin="', i, ' 0" />', '<g_vml_:path textpathok="true" />', '<g_vml_:textpath on="true" string="', AD(AK), '" style="v-text-align:', p, ";font:", AD(j), '" /></g_vml_:line>'), 
        this.element_.insertAdjacentHTML("beforeEnd", AE.join(""));
    }, M.fillText = function(j, Z, m, i) {
        this.drawText_(j, Z, m, i, !1);
    }, M.strokeText = function(j, Z, m, i) {
        this.drawText_(j, Z, m, i, !0);
    }, M.measureText = function(j) {
        if (!this.textMeasureEl_) {
            var Z = '<span style="position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;"></span>';
            this.element_.insertAdjacentHTML("beforeEnd", Z), this.textMeasureEl_ = this.element_.lastChild;
        }
        var i = this.element_.ownerDocument;
        return this.textMeasureEl_.innerHTML = "", this.textMeasureEl_.style.font = this.font, 
        this.textMeasureEl_.appendChild(i.createTextNode(j)), {
            width: this.textMeasureEl_.offsetWidth
        };
    }, M.clip = function() {}, M.arcTo = function() {}, M.createPattern = function(i, Z) {
        return new u(i, Z);
    }, v.prototype.addColorStop = function(i, Z) {
        Z = Y(Z), this.colors_.push({
            offset: i,
            color: Z.color,
            alpha: Z.alpha
        });
    };
    var x = o.prototype = new Error();
    x.INDEX_SIZE_ERR = 1, x.DOMSTRING_SIZE_ERR = 2, x.HIERARCHY_REQUEST_ERR = 3, x.WRONG_DOCUMENT_ERR = 4, 
    x.INVALID_CHARACTER_ERR = 5, x.NO_DATA_ALLOWED_ERR = 6, x.NO_MODIFICATION_ALLOWED_ERR = 7, 
    x.NOT_FOUND_ERR = 8, x.NOT_SUPPORTED_ERR = 9, x.INUSE_ATTRIBUTE_ERR = 10, x.INVALID_STATE_ERR = 11, 
    x.SYNTAX_ERR = 12, x.INVALID_MODIFICATION_ERR = 13, x.NAMESPACE_ERR = 14, x.INVALID_ACCESS_ERR = 15, 
    x.VALIDATION_ERR = 16, x.TYPE_MISMATCH_ERR = 17, G_vmlCanvasManager = E, CanvasRenderingContext2D = W, 
    CanvasGradient = v, CanvasPattern = u, DOMException = o;
}(), /*!
 * jQuery JavaScript Library v1.11.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-04-28T16:19Z
 */
function(global, factory) {
    "object" == typeof module && "object" == typeof module.exports ? // For CommonJS and CommonJS-like environments where a proper window is present,
    // execute the factory and get jQuery
    // For environments that do not inherently posses a window with a document
    // (such as Node.js), expose a jQuery-making factory as module.exports
    // This accentuates the need for the creation of a real window
    // e.g. var jQuery = require("jquery")(window);
    // See ticket #14549 for more info
    module.exports = global.document ? factory(global, !0) : function(w) {
        if (!w.document) throw new Error("jQuery requires a window with a document");
        return factory(w);
    } : factory(global);
}("undefined" != typeof window ? window : this, function(window, noGlobal) {
    function isArraylike(obj) {
        // Support: iOS 8.2 (not reproducible in simulator)
        // `in` check used to prevent JIT error (gh-2145)
        // hasOwn isn't used here due to false negatives
        // regarding Nodelist length in IE
        var length = "length" in obj && obj.length, type = jQuery.type(obj);
        return "function" === type || jQuery.isWindow(obj) ? !1 : 1 === obj.nodeType && length ? !0 : "array" === type || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj;
    }
    // Implement the identical functionality for filter and not
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) return jQuery.grep(elements, function(elem, i) {
            /* jshint -W018 */
            return !!qualifier.call(elem, i, elem) !== not;
        });
        if (qualifier.nodeType) return jQuery.grep(elements, function(elem) {
            return elem === qualifier !== not;
        });
        if ("string" == typeof qualifier) {
            if (risSimple.test(qualifier)) return jQuery.filter(qualifier, elements, not);
            qualifier = jQuery.filter(qualifier, elements);
        }
        return jQuery.grep(elements, function(elem) {
            return jQuery.inArray(elem, qualifier) >= 0 !== not;
        });
    }
    function sibling(cur, dir) {
        do cur = cur[dir]; while (cur && 1 !== cur.nodeType);
        return cur;
    }
    // Convert String-formatted options into Object-formatted ones and store in cache
    function createOptions(options) {
        var object = optionsCache[options] = {};
        return jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
            object[flag] = !0;
        }), object;
    }
    /**
 * Clean-up method for dom ready events
 */
    function detach() {
        document.addEventListener ? (document.removeEventListener("DOMContentLoaded", completed, !1), 
        window.removeEventListener("load", completed, !1)) : (document.detachEvent("onreadystatechange", completed), 
        window.detachEvent("onload", completed));
    }
    /**
 * The ready event handler and self cleanup method
 */
    function completed() {
        // readyState === "complete" is good enough for us to call the dom ready in oldIE
        (document.addEventListener || "load" === event.type || "complete" === document.readyState) && (detach(), 
        jQuery.ready());
    }
    function dataAttr(elem, key, data) {
        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if (void 0 === data && 1 === elem.nodeType) {
            var name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
            if (data = elem.getAttribute(name), "string" == typeof data) {
                try {
                    data = "true" === data ? !0 : "false" === data ? !1 : "null" === data ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                } catch (e) {}
                // Make sure we set the data so it isn't changed later
                jQuery.data(elem, key, data);
            } else data = void 0;
        }
        return data;
    }
    // checks a cache object for emptiness
    function isEmptyDataObject(obj) {
        var name;
        for (name in obj) // if the public data object is empty, the private is still empty
        if (("data" !== name || !jQuery.isEmptyObject(obj[name])) && "toJSON" !== name) return !1;
        return !0;
    }
    function internalData(elem, name, data, pvt) {
        if (jQuery.acceptData(elem)) {
            var ret, thisCache, internalKey = jQuery.expando, // We have to handle DOM nodes and JS objects differently because IE6-7
            // can't GC object references properly across the DOM-JS boundary
            isNode = elem.nodeType, // Only DOM nodes need the global jQuery cache; JS object data is
            // attached directly to the object so GC can occur automatically
            cache = isNode ? jQuery.cache : elem, // Only defining an ID for JS objects if its cache already exists allows
            // the code to shortcut on the same path as a DOM node with no cache
            id = isNode ? elem[internalKey] : elem[internalKey] && internalKey;
            // Avoid doing any more work than we need to when trying to get data on an
            // object that has no data at all
            if (id && cache[id] && (pvt || cache[id].data) || void 0 !== data || "string" != typeof name) // Only DOM nodes need a new unique ID for each element since their data
            // ends up in the global cache
            // Avoid exposing jQuery metadata on plain JS objects when the object
            // is serialized using JSON.stringify
            // An object can be passed to jQuery.data instead of a key/value pair; this gets
            // shallow copied over onto the existing cache
            // jQuery data() is stored in a separate object inside the object's internal data
            // cache in order to avoid key collisions between internal data and user-defined
            // data.
            // Check for both converted-to-camel and non-converted data property names
            // If a data property was specified
            // First Try to find as-is property data
            // Test for null|undefined property data
            // Try to find the camelCased property
            return id || (id = isNode ? elem[internalKey] = deletedIds.pop() || jQuery.guid++ : internalKey), 
            cache[id] || (cache[id] = isNode ? {} : {
                toJSON: jQuery.noop
            }), ("object" == typeof name || "function" == typeof name) && (pvt ? cache[id] = jQuery.extend(cache[id], name) : cache[id].data = jQuery.extend(cache[id].data, name)), 
            thisCache = cache[id], pvt || (thisCache.data || (thisCache.data = {}), thisCache = thisCache.data), 
            void 0 !== data && (thisCache[jQuery.camelCase(name)] = data), "string" == typeof name ? (ret = thisCache[name], 
            null == ret && (ret = thisCache[jQuery.camelCase(name)])) : ret = thisCache, ret;
        }
    }
    function internalRemoveData(elem, name, pvt) {
        if (jQuery.acceptData(elem)) {
            var thisCache, i, isNode = elem.nodeType, // See jQuery.data for more information
            cache = isNode ? jQuery.cache : elem, id = isNode ? elem[jQuery.expando] : jQuery.expando;
            // If there is already no cache entry for this object, there is no
            // purpose in continuing
            if (cache[id]) {
                if (name && (thisCache = pvt ? cache[id] : cache[id].data)) {
                    // Support array or space separated string names for data keys
                    jQuery.isArray(name) ? // If "name" is an array of keys...
                    // When data is initially created, via ("key", "val") signature,
                    // keys will be converted to camelCase.
                    // Since there is no way to tell _how_ a key was added, remove
                    // both plain key and camelCase key. #12786
                    // This will only penalize the array argument path.
                    name = name.concat(jQuery.map(name, jQuery.camelCase)) : // try the string as a key before any manipulation
                    name in thisCache ? name = [ name ] : (name = jQuery.camelCase(name), name = name in thisCache ? [ name ] : name.split(" ")), 
                    i = name.length;
                    for (;i--; ) delete thisCache[name[i]];
                    // If there is no data left in the cache, we want to continue
                    // and let the cache object itself get destroyed
                    if (pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache)) return;
                }
                // See jQuery.data for more information
                (pvt || (delete cache[id].data, isEmptyDataObject(cache[id]))) && (// Destroy the cache
                isNode ? jQuery.cleanData([ elem ], !0) : support.deleteExpando || cache != cache.window ? /* jshint eqeqeq: true */
                delete cache[id] : cache[id] = null);
            }
        }
    }
    function returnTrue() {
        return !0;
    }
    function returnFalse() {
        return !1;
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {}
    }
    function createSafeFragment(document) {
        var list = nodeNames.split("|"), safeFrag = document.createDocumentFragment();
        if (safeFrag.createElement) for (;list.length; ) safeFrag.createElement(list.pop());
        return safeFrag;
    }
    function getAll(context, tag) {
        var elems, elem, i = 0, found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName(tag || "*") : typeof context.querySelectorAll !== strundefined ? context.querySelectorAll(tag || "*") : void 0;
        if (!found) for (found = [], elems = context.childNodes || context; null != (elem = elems[i]); i++) !tag || jQuery.nodeName(elem, tag) ? found.push(elem) : jQuery.merge(found, getAll(elem, tag));
        return void 0 === tag || tag && jQuery.nodeName(context, tag) ? jQuery.merge([ context ], found) : found;
    }
    // Used in buildFragment, fixes the defaultChecked property
    function fixDefaultChecked(elem) {
        rcheckableType.test(elem.type) && (elem.defaultChecked = elem.checked);
    }
    // Support: IE<8
    // Manipulating tables requires a tbody
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, "table") && jQuery.nodeName(11 !== content.nodeType ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
    }
    // Replace/restore the type attribute of script elements for safe DOM manipulation
    function disableScript(elem) {
        return elem.type = (null !== jQuery.find.attr(elem, "type")) + "/" + elem.type, 
        elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        return match ? elem.type = match[1] : elem.removeAttribute("type"), elem;
    }
    // Mark scripts as having already been evaluated
    function setGlobalEval(elems, refElements) {
        for (var elem, i = 0; null != (elem = elems[i]); i++) jQuery._data(elem, "globalEval", !refElements || jQuery._data(refElements[i], "globalEval"));
    }
    function cloneCopyEvent(src, dest) {
        if (1 === dest.nodeType && jQuery.hasData(src)) {
            var type, i, l, oldData = jQuery._data(src), curData = jQuery._data(dest, oldData), events = oldData.events;
            if (events) {
                delete curData.handle, curData.events = {};
                for (type in events) for (i = 0, l = events[type].length; l > i; i++) jQuery.event.add(dest, type, events[type][i]);
            }
            // make the cloned public data object a copy from the original
            curData.data && (curData.data = jQuery.extend({}, curData.data));
        }
    }
    function fixCloneNodeIssues(src, dest) {
        var nodeName, e, data;
        // We do not need to do anything for non-Elements
        if (1 === dest.nodeType) {
            // IE6-8 copies events bound via attachEvent when using cloneNode.
            if (nodeName = dest.nodeName.toLowerCase(), !support.noCloneEvent && dest[jQuery.expando]) {
                data = jQuery._data(dest);
                for (e in data.events) jQuery.removeEvent(dest, e, data.handle);
                // Event data gets referenced instead of copied if the expando gets copied too
                dest.removeAttribute(jQuery.expando);
            }
            // IE blanks contents when cloning scripts, and tries to evaluate newly-set text
            "script" === nodeName && dest.text !== src.text ? (disableScript(dest).text = src.text, 
            restoreScript(dest)) : "object" === nodeName ? (dest.parentNode && (dest.outerHTML = src.outerHTML), 
            // This path appears unavoidable for IE9. When cloning an object
            // element in IE9, the outerHTML strategy above is not sufficient.
            // If the src has innerHTML and the destination does not,
            // copy the src.innerHTML into the dest.innerHTML. #10324
            support.html5Clone && src.innerHTML && !jQuery.trim(dest.innerHTML) && (dest.innerHTML = src.innerHTML)) : "input" === nodeName && rcheckableType.test(src.type) ? (// IE6-8 fails to persist the checked state of a cloned checkbox
            // or radio button. Worse, IE6-7 fail to give the cloned element
            // a checked appearance if the defaultChecked value isn't also set
            dest.defaultChecked = dest.checked = src.checked, // IE6-7 get confused and end up setting the value of a cloned
            // checkbox/radio button to an empty string instead of "on"
            dest.value !== src.value && (dest.value = src.value)) : "option" === nodeName ? dest.defaultSelected = dest.selected = src.defaultSelected : ("input" === nodeName || "textarea" === nodeName) && (dest.defaultValue = src.defaultValue);
        }
    }
    /**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
    // Called only from within defaultDisplay
    function actualDisplay(name, doc) {
        var style, elem = jQuery(doc.createElement(name)).appendTo(doc.body), // getDefaultComputedStyle might be reliably used only on attached element
        display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? // Use of this method is a temporary fix (more like optmization) until something better comes along,
        // since it was removed from specification and supported only in FF
        style.display : jQuery.css(elem[0], "display");
        // We don't have any data stored on the element,
        // so use "detach" method as fast way to get rid of the element
        return elem.detach(), display;
    }
    /**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
    function defaultDisplay(nodeName) {
        var doc = document, display = elemdisplay[nodeName];
        // If the simple way fails, read from inside an iframe
        // Use the already-created iframe if possible
        // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
        // Support: IE
        // Store the correct default display
        return display || (display = actualDisplay(nodeName, doc), "none" !== display && display || (iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement), 
        doc = (iframe[0].contentWindow || iframe[0].contentDocument).document, doc.write(), 
        doc.close(), display = actualDisplay(nodeName, doc), iframe.detach()), elemdisplay[nodeName] = display), 
        display;
    }
    function addGetHookIf(conditionFn, hookFn) {
        // Define the hook, we'll check on the first run if it's really needed.
        return {
            get: function() {
                var condition = conditionFn();
                if (null != condition) // Hook not needed (or it's not possible to use it due to missing dependency),
                // remove it.
                // Since there are no other hooks for marginRight, remove the whole object.
                return condition ? void delete this.get : (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    // return a css property mapped to a potentially vendor prefixed property
    function vendorPropName(style, name) {
        // shortcut for names that are not vendor prefixed
        if (name in style) return name;
        for (// check for vendor prefixed names
        var capName = name.charAt(0).toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length; i--; ) if (name = cssPrefixes[i] + capName, 
        name in style) return name;
        return origName;
    }
    function showHide(elements, show) {
        for (var display, elem, hidden, values = [], index = 0, length = elements.length; length > index; index++) elem = elements[index], 
        elem.style && (values[index] = jQuery._data(elem, "olddisplay"), display = elem.style.display, 
        show ? (values[index] || "none" !== display || (elem.style.display = ""), "" === elem.style.display && isHidden(elem) && (values[index] = jQuery._data(elem, "olddisplay", defaultDisplay(elem.nodeName)))) : (hidden = isHidden(elem), 
        (display && "none" !== display || !hidden) && jQuery._data(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"))));
        // Set the display of most of the elements in a second loop
        // to avoid the constant reflow
        for (index = 0; length > index; index++) elem = elements[index], elem.style && (show && "none" !== elem.style.display && "" !== elem.style.display || (elem.style.display = show ? values[index] || "" : "none"));
        return elements;
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value);
        // Guard against undefined "subtract", e.g., when used as in cssHooks
        return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        for (var i = extra === (isBorderBox ? "border" : "content") ? // If we already have the right measurement, avoid augmentation
        4 : "width" === name ? 1 : 0, val = 0; 4 > i; i += 2) // both box models exclude margin, so add it if we want it
        "margin" === extra && (val += jQuery.css(elem, extra + cssExpand[i], !0, styles)), 
        isBorderBox ? (// border-box includes padding, so remove it if we want content
        "content" === extra && (val -= jQuery.css(elem, "padding" + cssExpand[i], !0, styles)), 
        // at this point, extra isn't border nor margin, so remove border
        "margin" !== extra && (val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles))) : (val += jQuery.css(elem, "padding" + cssExpand[i], !0, styles), 
        "padding" !== extra && (val += jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles)));
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        // Start with offset property, which is equivalent to the border-box value
        var valueIsBorderBox = !0, val = "width" === name ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = support.boxSizing && "border-box" === jQuery.css(elem, "boxSizing", !1, styles);
        // some non-html elements return undefined for offsetWidth, so check for null/undefined
        // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
        // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
        if (0 >= val || null == val) {
            // Computed unit is not pixels. Stop here and return.
            if (val = curCSS(elem, name, styles), (0 > val || null == val) && (val = elem.style[name]), 
            rnumnonpx.test(val)) return val;
            // we need the check for style in case a browser which returns unreliable values
            // for getComputedStyle silently falls back to the reliable elem.style
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]), 
            // Normalize "", auto, and prepare for extra
            val = parseFloat(val) || 0;
        }
        // use the active box-sizing model to add/subtract irrelevant styles
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
    }
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    // Animations created synchronously will run synchronously
    function createFxNow() {
        return setTimeout(function() {
            fxNow = void 0;
        }), fxNow = jQuery.now();
    }
    // Generate parameters to create a standard animation
    function genFx(type, includeWidth) {
        var which, attrs = {
            height: type
        }, i = 0;
        for (// if we include width, step value is 1 to do all cssExpand values,
        // if we don't include width, step value is 2 to skip over Left and Right
        includeWidth = includeWidth ? 1 : 0; 4 > i; i += 2 - includeWidth) which = cssExpand[i], 
        attrs["margin" + which] = attrs["padding" + which] = type;
        return includeWidth && (attrs.opacity = attrs.width = type), attrs;
    }
    function createTween(value, prop, animation) {
        for (var tween, collection = (tweeners[prop] || []).concat(tweeners["*"]), index = 0, length = collection.length; length > index; index++) if (tween = collection[index].call(animation, prop, value)) // we're done with this property
        return tween;
    }
    function defaultPrefilter(elem, props, opts) {
        /* jshint validthis: true */
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = jQuery._data(elem, "fxshow");
        // handle queue: false promises
        opts.queue || (hooks = jQuery._queueHooks(elem, "fx"), null == hooks.unqueued && (hooks.unqueued = 0, 
        oldfire = hooks.empty.fire, hooks.empty.fire = function() {
            hooks.unqueued || oldfire();
        }), hooks.unqueued++, anim.always(function() {
            anim.always(function() {
                hooks.unqueued--, jQuery.queue(elem, "fx").length || hooks.empty.fire();
            });
        })), // height/width overflow pass
        1 === elem.nodeType && ("height" in props || "width" in props) && (// Make sure that nothing sneaks out
        // Record all 3 overflow attributes because IE does not
        // change the overflow attribute when overflowX and
        // overflowY are set to the same value
        opts.overflow = [ style.overflow, style.overflowX, style.overflowY ], display = jQuery.css(elem, "display"), 
        checkDisplay = "none" === display ? jQuery._data(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display, 
        "inline" === checkDisplay && "none" === jQuery.css(elem, "float") && (support.inlineBlockNeedsLayout && "inline" !== defaultDisplay(elem.nodeName) ? style.zoom = 1 : style.display = "inline-block")), 
        opts.overflow && (style.overflow = "hidden", support.shrinkWrapBlocks() || anim.always(function() {
            style.overflow = opts.overflow[0], style.overflowX = opts.overflow[1], style.overflowY = opts.overflow[2];
        }));
        // show/hide pass
        for (prop in props) if (value = props[prop], rfxtypes.exec(value)) {
            if (delete props[prop], toggle = toggle || "toggle" === value, value === (hidden ? "hide" : "show")) {
                // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
                if ("show" !== value || !dataShow || void 0 === dataShow[prop]) continue;
                hidden = !0;
            }
            orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
        } else display = void 0;
        if (jQuery.isEmptyObject(orig)) "inline" === ("none" === display ? defaultDisplay(elem.nodeName) : display) && (style.display = display); else {
            dataShow ? "hidden" in dataShow && (hidden = dataShow.hidden) : dataShow = jQuery._data(elem, "fxshow", {}), 
            // store state if its toggle - enables .stop().toggle() to "reverse"
            toggle && (dataShow.hidden = !hidden), hidden ? jQuery(elem).show() : anim.done(function() {
                jQuery(elem).hide();
            }), anim.done(function() {
                var prop;
                jQuery._removeData(elem, "fxshow");
                for (prop in orig) jQuery.style(elem, prop, orig[prop]);
            });
            for (prop in orig) tween = createTween(hidden ? dataShow[prop] : 0, prop, anim), 
            prop in dataShow || (dataShow[prop] = tween.start, hidden && (tween.end = tween.start, 
            tween.start = "width" === prop || "height" === prop ? 1 : 0));
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        // camelCase, specialEasing and expand cssHook pass
        for (index in props) if (name = jQuery.camelCase(index), easing = specialEasing[name], 
        value = props[index], jQuery.isArray(value) && (easing = value[1], value = props[index] = value[0]), 
        index !== name && (props[name] = value, delete props[index]), hooks = jQuery.cssHooks[name], 
        hooks && "expand" in hooks) {
            value = hooks.expand(value), delete props[name];
            // not quite $.extend, this wont overwrite keys already present.
            // also - reusing 'index' from above because we have the correct "name"
            for (index in value) index in props || (props[index] = value[index], specialEasing[index] = easing);
        } else specialEasing[name] = easing;
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function() {
            // don't match elem in the :animated selector
            delete tick.elem;
        }), tick = function() {
            if (stopped) return !1;
            for (var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
            temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length; length > index; index++) animation.tweens[index].run(percent);
            return deferred.notifyWith(elem, [ animation, percent, remaining ]), 1 > percent && length ? remaining : (deferred.resolveWith(elem, [ animation ]), 
            !1);
        }, animation = deferred.promise({
            elem: elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(!0, {
                specialEasing: {}
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                return animation.tweens.push(tween), tween;
            },
            stop: function(gotoEnd) {
                var index = 0, // if we are going to the end, we want to run all the tweens
                // otherwise we skip this part
                length = gotoEnd ? animation.tweens.length : 0;
                if (stopped) return this;
                for (stopped = !0; length > index; index++) animation.tweens[index].run(1);
                // resolve when we played the last frame
                // otherwise, reject
                return gotoEnd ? deferred.resolveWith(elem, [ animation, gotoEnd ]) : deferred.rejectWith(elem, [ animation, gotoEnd ]), 
                this;
            }
        }), props = animation.props;
        for (propFilter(props, animation.opts.specialEasing); length > index; index++) if (result = animationPrefilters[index].call(animation, elem, props, animation.opts)) return result;
        // attach callbacks from options
        return jQuery.map(props, createTween, animation), jQuery.isFunction(animation.opts.start) && animation.opts.start.call(elem, animation), 
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        })), animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }
    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {
        // dataTypeExpression is optional and defaults to "*"
        return function(dataTypeExpression, func) {
            "string" != typeof dataTypeExpression && (func = dataTypeExpression, dataTypeExpression = "*");
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
            if (jQuery.isFunction(func)) // For each dataType in the dataTypeExpression
            for (;dataType = dataTypes[i++]; ) // Prepend if requested
            "+" === dataType.charAt(0) ? (dataType = dataType.slice(1) || "*", (structure[dataType] = structure[dataType] || []).unshift(func)) : (structure[dataType] = structure[dataType] || []).push(func);
        };
    }
    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        function inspect(dataType) {
            var selected;
            return inspected[dataType] = !0, jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                return "string" != typeof dataTypeOrTransport || seekingTransport || inspected[dataTypeOrTransport] ? seekingTransport ? !(selected = dataTypeOrTransport) : void 0 : (options.dataTypes.unshift(dataTypeOrTransport), 
                inspect(dataTypeOrTransport), !1);
            }), selected;
        }
        var inspected = {}, seekingTransport = structure === transports;
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887
    function ajaxExtend(target, src) {
        var deep, key, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) void 0 !== src[key] && ((flatOptions[key] ? target : deep || (deep = {}))[key] = src[key]);
        return deep && jQuery.extend(!0, target, deep), target;
    }
    /* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
    function ajaxHandleResponses(s, jqXHR, responses) {
        // Remove auto dataType and get content-type in the process
        for (var firstDataType, ct, finalDataType, type, contents = s.contents, dataTypes = s.dataTypes; "*" === dataTypes[0]; ) dataTypes.shift(), 
        void 0 === ct && (ct = s.mimeType || jqXHR.getResponseHeader("Content-Type"));
        // Check if we're dealing with a known content-type
        if (ct) for (type in contents) if (contents[type] && contents[type].test(ct)) {
            dataTypes.unshift(type);
            break;
        }
        // Check to see if we have a response for the expected dataType
        if (dataTypes[0] in responses) finalDataType = dataTypes[0]; else {
            // Try convertible dataTypes
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                firstDataType || (firstDataType = type);
            }
            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }
        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        return finalDataType ? (finalDataType !== dataTypes[0] && dataTypes.unshift(finalDataType), 
        responses[finalDataType]) : void 0;
    }
    /* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, // Work with a copy of dataTypes in case we need to modify it for conversion
        dataTypes = s.dataTypes.slice();
        // Create converters map with lowercased keys
        if (dataTypes[1]) for (conv in s.converters) converters[conv.toLowerCase()] = s.converters[conv];
        // Convert to each sequential dataType
        for (current = dataTypes.shift(); current; ) if (s.responseFields[current] && (jqXHR[s.responseFields[current]] = response), 
        // Apply the dataFilter if provided
        !prev && isSuccess && s.dataFilter && (response = s.dataFilter(response, s.dataType)), 
        prev = current, current = dataTypes.shift()) // There's only work to do if current dataType is non-auto
        if ("*" === current) current = prev; else if ("*" !== prev && prev !== current) {
            // If none found, seek a pair
            if (conv = converters[prev + " " + current] || converters["* " + current], !conv) for (conv2 in converters) if (tmp = conv2.split(" "), 
            tmp[1] === current && (conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]])) {
                // Condense equivalence converters
                conv === !0 ? conv = converters[conv2] : converters[conv2] !== !0 && (current = tmp[0], 
                dataTypes.unshift(tmp[1]));
                break;
            }
            // Apply converter (if not an equivalence)
            if (conv !== !0) // Unless errors are allowed to bubble, catch and return them
            if (conv && s["throws"]) response = conv(response); else try {
                response = conv(response);
            } catch (e) {
                return {
                    state: "parsererror",
                    error: conv ? e : "No conversion from " + prev + " to " + current
                };
            }
        }
        return {
            state: "success",
            data: response
        };
    }
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) // Serialize array item.
        jQuery.each(obj, function(i, v) {
            traditional || rbracket.test(prefix) ? // Treat each array item as a scalar.
            add(prefix, v) : // Item is non-scalar (array or object), encode its numeric index.
            buildParams(prefix + "[" + ("object" == typeof v ? i : "") + "]", v, traditional, add);
        }); else if (traditional || "object" !== jQuery.type(obj)) // Serialize scalar item.
        add(prefix, obj); else // Serialize object item.
        for (name in obj) buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
    }
    // Functions to create xhrs
    function createStandardXHR() {
        try {
            return new window.XMLHttpRequest();
        } catch (e) {}
    }
    function createActiveXHR() {
        try {
            return new window.ActiveXObject("Microsoft.XMLHTTP");
        } catch (e) {}
    }
    /**
 * Gets a window from an element
 */
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : 9 === elem.nodeType ? elem.defaultView || elem.parentWindow : !1;
    }
    // Can't do this because several apps including ASP.NET trace
    // the stack via arguments.caller.callee and Firefox dies if
    // you try to trace through "use strict" call chains. (#13335)
    // Support: Firefox 18+
    //
    var deletedIds = [], slice = deletedIds.slice, concat = deletedIds.concat, push = deletedIds.push, indexOf = deletedIds.indexOf, class2type = {}, toString = class2type.toString, hasOwn = class2type.hasOwnProperty, support = {}, version = "1.11.3", // Define a local copy of jQuery
    jQuery = function(selector, context) {
        // The jQuery object is actually just the init constructor 'enhanced'
        // Need init if jQuery is called (just allow error to be thrown if not included)
        return new jQuery.fn.init(selector, context);
    }, // Support: Android<4.1, IE<9
    // Make sure we trim BOM and NBSP
    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, // Matches dashed string for camelizing
    rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, // Used by jQuery.camelCase as callback to replace()
    fcamelCase = function(all, letter) {
        return letter.toUpperCase();
    };
    jQuery.fn = jQuery.prototype = {
        // The current version of jQuery being used
        jquery: version,
        constructor: jQuery,
        // Start with an empty selector
        selector: "",
        // The default length of a jQuery object is 0
        length: 0,
        toArray: function() {
            return slice.call(this);
        },
        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function(num) {
            // Return just the one element from the set
            // Return all the elements in a clean array
            return null != num ? 0 > num ? this[num + this.length] : this[num] : slice.call(this);
        },
        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function(elems) {
            // Build a new jQuery matched element set
            var ret = jQuery.merge(this.constructor(), elems);
            // Return the newly-formed element set
            // Add the old object onto the stack (as a reference)
            return ret.prevObject = this, ret.context = this.context, ret;
        },
        // Execute a callback for every element in the matched set.
        // (You can seed the arguments with an array of args, but this is
        // only used internally.)
        each: function(callback, args) {
            return jQuery.each(this, callback, args);
        },
        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function() {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(i) {
            var len = this.length, j = +i + (0 > i ? len : 0);
            return this.pushStack(j >= 0 && len > j ? [ this[j] ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor(null);
        },
        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push,
        sort: deletedIds.sort,
        splice: deletedIds.splice
    }, jQuery.extend = jQuery.fn.extend = function() {
        var src, copyIsArray, copy, name, options, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = !1;
        for (// Handle a deep copy situation
        "boolean" == typeof target && (deep = target, target = arguments[i] || {}, i++), 
        // Handle case when target is a string or something (possible in deep copy)
        "object" == typeof target || jQuery.isFunction(target) || (target = {}), // extend jQuery itself if only one argument is passed
        i === length && (target = this, i--); length > i; i++) // Only deal with non-null/undefined values
        if (null != (options = arguments[i])) // Extend the base object
        for (name in options) src = target[name], copy = options[name], target !== copy && (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy))) ? (copyIsArray ? (copyIsArray = !1, 
        clone = src && jQuery.isArray(src) ? src : []) : clone = src && jQuery.isPlainObject(src) ? src : {}, 
        target[name] = jQuery.extend(deep, clone, copy)) : void 0 !== copy && (target[name] = copy));
        // Return the modified object
        return target;
    }, jQuery.extend({
        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        // Assume jQuery is ready without the ready module
        isReady: !0,
        error: function(msg) {
            throw new Error(msg);
        },
        noop: function() {},
        // See test/unit/core.js for details concerning isFunction.
        // Since version 1.3, DOM methods and functions like alert
        // aren't supported. They return false on IE (#2968).
        isFunction: function(obj) {
            return "function" === jQuery.type(obj);
        },
        isArray: Array.isArray || function(obj) {
            return "array" === jQuery.type(obj);
        },
        isWindow: function(obj) {
            /* jshint eqeqeq: false */
            return null != obj && obj == obj.window;
        },
        isNumeric: function(obj) {
            // parseFloat NaNs numeric-cast false positives (null|true|false|"")
            // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
            // subtraction forces infinities to NaN
            // adding 1 corrects loss of precision from parseFloat (#15100)
            return !jQuery.isArray(obj) && obj - parseFloat(obj) + 1 >= 0;
        },
        isEmptyObject: function(obj) {
            var name;
            for (name in obj) return !1;
            return !0;
        },
        isPlainObject: function(obj) {
            var key;
            // Must be an Object.
            // Because of IE, we also have to check the presence of the constructor property.
            // Make sure that DOM nodes and window objects don't pass through, as well
            if (!obj || "object" !== jQuery.type(obj) || obj.nodeType || jQuery.isWindow(obj)) return !1;
            try {
                // Not own constructor property must be Object
                if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) return !1;
            } catch (e) {
                // IE8,9 Will throw exceptions on certain host objects #9897
                return !1;
            }
            // Support: IE<9
            // Handle iteration over inherited properties before own properties.
            if (support.ownLast) for (key in obj) return hasOwn.call(obj, key);
            // Own properties are enumerated firstly, so to speed up,
            // if last one is own, then all properties are own.
            for (key in obj) ;
            return void 0 === key || hasOwn.call(obj, key);
        },
        type: function(obj) {
            return null == obj ? obj + "" : "object" == typeof obj || "function" == typeof obj ? class2type[toString.call(obj)] || "object" : typeof obj;
        },
        // Evaluates a script in a global context
        // Workarounds based on findings by Jim Driscoll
        // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
        globalEval: function(data) {
            data && jQuery.trim(data) && // We use execScript on Internet Explorer
            // We use an anonymous function so that context is window
            // rather than jQuery in Firefox
            (window.execScript || function(data) {
                window.eval.call(window, data);
            })(data);
        },
        // Convert dashed to camelCase; used by the css and data modules
        // Microsoft forgot to hump their vendor prefix (#9572)
        camelCase: function(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        },
        nodeName: function(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
        // args is for internal usage only
        each: function(obj, callback, args) {
            var value, i = 0, length = obj.length, isArray = isArraylike(obj);
            if (args) {
                if (isArray) for (;length > i && (value = callback.apply(obj[i], args), value !== !1); i++) ; else for (i in obj) if (value = callback.apply(obj[i], args), 
                value === !1) break;
            } else if (isArray) for (;length > i && (value = callback.call(obj[i], i, obj[i]), 
            value !== !1); i++) ; else for (i in obj) if (value = callback.call(obj[i], i, obj[i]), 
            value === !1) break;
            return obj;
        },
        // Support: Android<4.1, IE<9
        trim: function(text) {
            return null == text ? "" : (text + "").replace(rtrim, "");
        },
        // results is for internal usage only
        makeArray: function(arr, results) {
            var ret = results || [];
            return null != arr && (isArraylike(Object(arr)) ? jQuery.merge(ret, "string" == typeof arr ? [ arr ] : arr) : push.call(ret, arr)), 
            ret;
        },
        inArray: function(elem, arr, i) {
            var len;
            if (arr) {
                if (indexOf) return indexOf.call(arr, elem, i);
                for (len = arr.length, i = i ? 0 > i ? Math.max(0, len + i) : i : 0; len > i; i++) // Skip accessing in sparse arrays
                if (i in arr && arr[i] === elem) return i;
            }
            return -1;
        },
        merge: function(first, second) {
            for (var len = +second.length, j = 0, i = first.length; len > j; ) first[i++] = second[j++];
            // Support: IE<9
            // Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
            if (len !== len) for (;void 0 !== second[j]; ) first[i++] = second[j++];
            return first.length = i, first;
        },
        grep: function(elems, callback, invert) {
            // Go through the array, only saving the items
            // that pass the validator function
            for (var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert; length > i; i++) callbackInverse = !callback(elems[i], i), 
            callbackInverse !== callbackExpect && matches.push(elems[i]);
            return matches;
        },
        // arg is for internal usage only
        map: function(elems, callback, arg) {
            var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
            // Go through the array, translating each of the items to their new values
            if (isArray) for (;length > i; i++) value = callback(elems[i], i, arg), null != value && ret.push(value); else for (i in elems) value = callback(elems[i], i, arg), 
            null != value && ret.push(value);
            // Flatten any nested arrays
            return concat.apply([], ret);
        },
        // A global GUID counter for objects
        guid: 1,
        // Bind a function to a context, optionally partially applying any
        // arguments.
        proxy: function(fn, context) {
            var args, proxy, tmp;
            // Quick check to determine if target is callable, in the spec
            // this throws a TypeError, but we will just return undefined.
            // Quick check to determine if target is callable, in the spec
            // this throws a TypeError, but we will just return undefined.
            // Simulated bind
            // Set the guid of unique handler to the same of original handler, so it can be removed
            return "string" == typeof context && (tmp = fn[context], context = fn, fn = tmp), 
            jQuery.isFunction(fn) ? (args = slice.call(arguments, 2), proxy = function() {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            }, proxy.guid = fn.guid = fn.guid || jQuery.guid++, proxy) : void 0;
        },
        now: function() {
            return +new Date();
        },
        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support
    }), // Populate the class2type map
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });
    var Sizzle = /*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
    function(window) {
        function Sizzle(selector, context, results, seed) {
            var match, elem, m, nodeType, // QSA vars
            i, groups, old, nid, newContext, newSelector;
            if ((context ? context.ownerDocument || context : preferredDoc) !== document && setDocument(context), 
            context = context || document, results = results || [], nodeType = context.nodeType, 
            "string" != typeof selector || !selector || 1 !== nodeType && 9 !== nodeType && 11 !== nodeType) return results;
            if (!seed && documentIsHTML) {
                // Try to shortcut find operations when possible (e.g., not under DocumentFragment)
                if (11 !== nodeType && (match = rquickExpr.exec(selector))) // Speed-up: Sizzle("#ID")
                if (m = match[1]) {
                    if (9 === nodeType) {
                        // Check parentNode to catch when Blackberry 4.6 returns
                        // nodes that are no longer in the document (jQuery #6963)
                        if (elem = context.getElementById(m), !elem || !elem.parentNode) return results;
                        // Handle the case where IE, Opera, and Webkit return items
                        // by name instead of ID
                        if (elem.id === m) return results.push(elem), results;
                    } else // Context is not a document
                    if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) return results.push(elem), 
                    results;
                } else {
                    if (match[2]) return push.apply(results, context.getElementsByTagName(selector)), 
                    results;
                    if ((m = match[3]) && support.getElementsByClassName) return push.apply(results, context.getElementsByClassName(m)), 
                    results;
                }
                // QSA path
                if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    // qSA works strangely on Element-rooted queries
                    // We can work around this by specifying an extra ID on the root
                    // and working up from there (Thanks to Andrew Dupont for the technique)
                    // IE 8 doesn't work on object elements
                    if (nid = old = expando, newContext = context, newSelector = 1 !== nodeType && selector, 
                    1 === nodeType && "object" !== context.nodeName.toLowerCase()) {
                        for (groups = tokenize(selector), (old = context.getAttribute("id")) ? nid = old.replace(rescape, "\\$&") : context.setAttribute("id", nid), 
                        nid = "[id='" + nid + "'] ", i = groups.length; i--; ) groups[i] = nid + toSelector(groups[i]);
                        newContext = rsibling.test(selector) && testContext(context.parentNode) || context, 
                        newSelector = groups.join(",");
                    }
                    if (newSelector) try {
                        return push.apply(results, newContext.querySelectorAll(newSelector)), results;
                    } catch (qsaError) {} finally {
                        old || context.removeAttribute("id");
                    }
                }
            }
            // All others
            return select(selector.replace(rtrim, "$1"), context, results, seed);
        }
        /**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
        function createCache() {
            function cache(key, value) {
                // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                // Only keep the most recent entries
                return keys.push(key + " ") > Expr.cacheLength && delete cache[keys.shift()], cache[key + " "] = value;
            }
            var keys = [];
            return cache;
        }
        /**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
        function markFunction(fn) {
            return fn[expando] = !0, fn;
        }
        /**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
        function assert(fn) {
            var div = document.createElement("div");
            try {
                return !!fn(div);
            } catch (e) {
                return !1;
            } finally {
                // Remove from its parent by default
                div.parentNode && div.parentNode.removeChild(div), // release memory in IE
                div = null;
            }
        }
        /**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
        function addHandle(attrs, handler) {
            for (var arr = attrs.split("|"), i = attrs.length; i--; ) Expr.attrHandle[arr[i]] = handler;
        }
        /**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
            // Use IE sourceIndex if available on both nodes
            if (diff) return diff;
            // Check if b follows a
            if (cur) for (;cur = cur.nextSibling; ) if (cur === b) return -1;
            return a ? 1 : -1;
        }
        /**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
        function createInputPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return "input" === name && elem.type === type;
            };
        }
        /**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
        function createButtonPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return ("input" === name || "button" === name) && elem.type === type;
            };
        }
        /**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
        function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                return argument = +argument, markFunction(function(seed, matches) {
                    for (var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length; i--; ) seed[j = matchIndexes[i]] && (seed[j] = !(matches[j] = seed[j]));
                });
            });
        }
        /**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
        function testContext(context) {
            return context && "undefined" != typeof context.getElementsByTagName && context;
        }
        // Easy API for creating new setFilters
        function setFilters() {}
        function toSelector(tokens) {
            for (var i = 0, len = tokens.length, selector = ""; len > i; i++) selector += tokens[i].value;
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, checkNonElements = base && "parentNode" === dir, doneName = done++;
            // Check against closest ancestor/preceding element
            // Check against all ancestor/preceding elements
            return combinator.first ? function(elem, context, xml) {
                for (;elem = elem[dir]; ) if (1 === elem.nodeType || checkNonElements) return matcher(elem, context, xml);
            } : function(elem, context, xml) {
                var oldCache, outerCache, newCache = [ dirruns, doneName ];
                // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
                if (xml) {
                    for (;elem = elem[dir]; ) if ((1 === elem.nodeType || checkNonElements) && matcher(elem, context, xml)) return !0;
                } else for (;elem = elem[dir]; ) if (1 === elem.nodeType || checkNonElements) {
                    if (outerCache = elem[expando] || (elem[expando] = {}), (oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) // Assign to newCache so results back-propagate to previous elements
                    return newCache[2] = oldCache[2];
                    // A match means we're done; a fail means we have to keep checking
                    if (// Reuse newcache so results back-propagate to previous elements
                    outerCache[dir] = newCache, newCache[2] = matcher(elem, context, xml)) return !0;
                }
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                for (var i = matchers.length; i--; ) if (!matchers[i](elem, context, xml)) return !1;
                return !0;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            for (var i = 0, len = contexts.length; len > i; i++) Sizzle(selector, contexts[i], results);
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            for (var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = null != map; len > i; i++) (elem = unmatched[i]) && (!filter || filter(elem, context, xml)) && (newUnmatched.push(elem), 
            mapped && map.push(i));
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            return postFilter && !postFilter[expando] && (postFilter = setMatcher(postFilter)), 
            postFinder && !postFinder[expando] && (postFinder = setMatcher(postFinder, postSelector)), 
            markFunction(function(seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, // Get initial elements from seed or context
                elems = seed || multipleContexts(selector || "*", context.nodeType ? [ context ] : context, []), // Prefilter to get matcher input, preserving a map for seed-results synchronization
                matcherIn = !preFilter || !seed && selector ? elems : condense(elems, preMap, preFilter, context, xml), matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
                [] : results : matcherIn;
                // Apply postFilter
                if (// Find primary matches
                matcher && matcher(matcherIn, matcherOut, context, xml), postFilter) for (temp = condense(matcherOut, postMap), 
                postFilter(temp, [], context, xml), // Un-match failing elements by moving them back to matcherIn
                i = temp.length; i--; ) (elem = temp[i]) && (matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem));
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            for (// Get the final matcherOut by condensing this intermediate into postFinder contexts
                            temp = [], i = matcherOut.length; i--; ) (elem = matcherOut[i]) && // Restore matcherIn since elem is not yet a final match
                            temp.push(matcherIn[i] = elem);
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        for (// Move matched elements from seed to results to keep them synchronized
                        i = matcherOut.length; i--; ) (elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1 && (seed[temp] = !(results[temp] = elem));
                    }
                } else matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut), 
                postFinder ? postFinder(null, results, matcherOut, xml) : push.apply(results, matcherOut);
            });
        }
        function matcherFromTokens(tokens) {
            for (var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, // The foundational matcher ensures that elements are reachable from top-level context(s)
            matchContext = addCombinator(function(elem) {
                return elem === checkContext;
            }, implicitRelative, !0), matchAnyContext = addCombinator(function(elem) {
                return indexOf(checkContext, elem) > -1;
            }, implicitRelative, !0), matchers = [ function(elem, context, xml) {
                var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                // Avoid hanging onto element (issue #299)
                return checkContext = null, ret;
            } ]; len > i; i++) if (matcher = Expr.relative[tokens[i].type]) matchers = [ addCombinator(elementMatcher(matchers), matcher) ]; else {
                // Return special upon seeing a positional matcher
                if (matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches), matcher[expando]) {
                    for (// Find the next relative operator (if any) for proper handling
                    j = ++i; len > j && !Expr.relative[tokens[j].type]; j++) ;
                    // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                    return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                        value: " " === tokens[i - 2].type ? "*" : ""
                    })).replace(rtrim, "$1"), matcher, j > i && matcherFromTokens(tokens.slice(i, j)), len > j && matcherFromTokens(tokens = tokens.slice(j)), len > j && toSelector(tokens));
                }
                matchers.push(matcher);
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
                var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, // We must always have either seed elements or outermost context
                elems = seed || byElement && Expr.find.TAG("*", outermost), // Use integer dirruns iff this is the outermost matcher
                dirrunsUnique = dirruns += null == contextBackup ? 1 : Math.random() || .1, len = elems.length;
                // Add elements passing elementMatchers directly to results
                // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
                // Support: IE<9, Safari
                // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                for (outermost && (outermostContext = context !== document && context); i !== len && null != (elem = elems[i]); i++) {
                    if (byElement && elem) {
                        for (j = 0; matcher = elementMatchers[j++]; ) if (matcher(elem, context, xml)) {
                            results.push(elem);
                            break;
                        }
                        outermost && (dirruns = dirrunsUnique);
                    }
                    // Track unmatched elements for set filters
                    bySet && (// They will have gone through all possible matchers
                    (elem = !matcher && elem) && matchedCount--, // Lengthen the array for every element, matched or not
                    seed && unmatched.push(elem));
                }
                if (matchedCount += i, bySet && i !== matchedCount) {
                    for (j = 0; matcher = setMatchers[j++]; ) matcher(unmatched, setMatched, context, xml);
                    if (seed) {
                        // Reintegrate element matches to eliminate the need for sorting
                        if (matchedCount > 0) for (;i--; ) unmatched[i] || setMatched[i] || (setMatched[i] = pop.call(results));
                        // Discard index placeholder values to get only actual matches
                        setMatched = condense(setMatched);
                    }
                    // Add matches to results
                    push.apply(results, setMatched), // Seedless set matches succeeding multiple successful matchers stipulate sorting
                    outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1 && Sizzle.uniqueSort(results);
                }
                // Override manipulation of globals by nested matchers
                return outermost && (dirruns = dirrunsUnique, outermostContext = contextBackup), 
                unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, // Local document vars
        setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, // Instance-specific data
        expando = "sizzle" + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
            return a === b && (hasDuplicate = !0), 0;
        }, // General-purpose constants
        MAX_NEGATIVE = 1 << 31, // Instance methods
        hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, // Use a stripped-down indexOf as it's faster than native
        // http://jsperf.com/thor-indexof-vs-for/5
        indexOf = function(list, elem) {
            for (var i = 0, len = list.length; len > i; i++) if (list[i] === elem) return i;
            return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", // Regular expressions
        // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
        whitespace = "[\\x20\\t\\r\\n\\f]", // http://www.w3.org/TR/css3-syntax/#characters
        characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", // Loosely modeled on CSS identifier characters
        // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
        // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
        identifier = characterEncoding.replace("w", "w#"), // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
        attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace + // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
        "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + characterEncoding + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|.*)\\)|)", // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
        rwhitespace = new RegExp(whitespace + "+", "g"), rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            ID: new RegExp("^#(" + characterEncoding + ")"),
            CLASS: new RegExp("^\\.(" + characterEncoding + ")"),
            TAG: new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
            ATTR: new RegExp("^" + attributes),
            PSEUDO: new RegExp("^" + pseudos),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + booleans + ")$", "i"),
            // For use in libraries implementing .is()
            // We use this for POS matching in `select`
            needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, // Easily-parseable/retrievable ID or TAG or CLASS selectors
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
            var high = "0x" + escaped - 65536;
            // NaN means non-codepoint
            // Support: Firefox<24
            // Workaround erroneous numeric interpretation of +"0x"
            // BMP codepoint
            // Supplemental Plane codepoint (surrogate pair)
            return high !== high || escapedWhitespace ? escaped : 0 > high ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, 1023 & high | 56320);
        }, // Used for iframes
        // See setDocument()
        // Removing the function wrapper causes a "Permission Denied"
        // error in IE
        unloadHandler = function() {
            setDocument();
        };
        // Optimize for push.apply( _, NodeList )
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes), 
            // Support: Android<4.0
            // Detect silently failing push.apply
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? // Leverage slice if possible
                function(target, els) {
                    push_native.apply(target, slice.call(els));
                } : // Support: IE<9
                // Otherwise append directly
                function(target, els) {
                    // Can't trust NodeList.length
                    for (var j = target.length, i = 0; target[j++] = els[i++]; ) ;
                    target.length = j - 1;
                }
            };
        }
        support = Sizzle.support = {}, isXML = Sizzle.isXML = function(elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? "HTML" !== documentElement.nodeName : !1;
        }, setDocument = Sizzle.setDocument = function(node) {
            var hasCompare, parent, doc = node ? node.ownerDocument || node : preferredDoc;
            return doc !== document && 9 === doc.nodeType && doc.documentElement ? (document = doc, 
            docElem = doc.documentElement, parent = doc.defaultView, parent && parent !== parent.top && (parent.addEventListener ? parent.addEventListener("unload", unloadHandler, !1) : parent.attachEvent && parent.attachEvent("onunload", unloadHandler)), 
            documentIsHTML = !isXML(doc), support.attributes = assert(function(div) {
                return div.className = "i", !div.getAttribute("className");
            }), support.getElementsByTagName = assert(function(div) {
                return div.appendChild(doc.createComment("")), !div.getElementsByTagName("*").length;
            }), support.getElementsByClassName = rnative.test(doc.getElementsByClassName), support.getById = assert(function(div) {
                return docElem.appendChild(div).id = expando, !doc.getElementsByName || !doc.getElementsByName(expando).length;
            }), support.getById ? (Expr.find.ID = function(id, context) {
                if ("undefined" != typeof context.getElementById && documentIsHTML) {
                    var m = context.getElementById(id);
                    return m && m.parentNode ? [ m ] : [];
                }
            }, Expr.filter.ID = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                    return elem.getAttribute("id") === attrId;
                };
            }) : (delete Expr.find.ID, Expr.filter.ID = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                    var node = "undefined" != typeof elem.getAttributeNode && elem.getAttributeNode("id");
                    return node && node.value === attrId;
                };
            }), Expr.find.TAG = support.getElementsByTagName ? function(tag, context) {
                return "undefined" != typeof context.getElementsByTagName ? context.getElementsByTagName(tag) : support.qsa ? context.querySelectorAll(tag) : void 0;
            } : function(tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                if ("*" === tag) {
                    for (;elem = results[i++]; ) 1 === elem.nodeType && tmp.push(elem);
                    return tmp;
                }
                return results;
            }, Expr.find.CLASS = support.getElementsByClassName && function(className, context) {
                return documentIsHTML ? context.getElementsByClassName(className) : void 0;
            }, rbuggyMatches = [], rbuggyQSA = [], (support.qsa = rnative.test(doc.querySelectorAll)) && (assert(function(div) {
                docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\f]' msallowcapture=''><option selected=''></option></select>", 
                div.querySelectorAll("[msallowcapture^='']").length && rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")"), 
                div.querySelectorAll("[selected]").length || rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")"), 
                div.querySelectorAll("[id~=" + expando + "-]").length || rbuggyQSA.push("~="), div.querySelectorAll(":checked").length || rbuggyQSA.push(":checked"), 
                div.querySelectorAll("a#" + expando + "+*").length || rbuggyQSA.push(".#.+[+~]");
            }), assert(function(div) {
                var input = doc.createElement("input");
                input.setAttribute("type", "hidden"), div.appendChild(input).setAttribute("name", "D"), 
                div.querySelectorAll("[name=d]").length && rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?="), 
                div.querySelectorAll(":enabled").length || rbuggyQSA.push(":enabled", ":disabled"), 
                div.querySelectorAll("*,:x"), rbuggyQSA.push(",.*:");
            })), (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) && assert(function(div) {
                support.disconnectedMatch = matches.call(div, "div"), matches.call(div, "[s!='']:x"), 
                rbuggyMatches.push("!=", pseudos);
            }), rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|")), rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|")), 
            hasCompare = rnative.test(docElem.compareDocumentPosition), contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                var adown = 9 === a.nodeType ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !(!bup || 1 !== bup.nodeType || !(adown.contains ? adown.contains(bup) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(bup)));
            } : function(a, b) {
                if (b) for (;b = b.parentNode; ) if (b === a) return !0;
                return !1;
            }, sortOrder = hasCompare ? function(a, b) {
                if (a === b) return hasDuplicate = !0, 0;
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                return compare ? compare : (compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 
                1 & compare || !support.sortDetached && b.compareDocumentPosition(a) === compare ? a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ? -1 : b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0 : 4 & compare ? -1 : 1);
            } : function(a, b) {
                if (a === b) return hasDuplicate = !0, 0;
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [ a ], bp = [ b ];
                if (!aup || !bup) return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                if (aup === bup) return siblingCheck(a, b);
                for (cur = a; cur = cur.parentNode; ) ap.unshift(cur);
                for (cur = b; cur = cur.parentNode; ) bp.unshift(cur);
                for (;ap[i] === bp[i]; ) i++;
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            }, doc) : document;
        }, Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements);
        }, Sizzle.matchesSelector = function(elem, expr) {
            if ((elem.ownerDocument || elem) !== document && setDocument(elem), expr = expr.replace(rattributeQuotes, "='$1']"), 
            support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) try {
                var ret = matches.call(elem, expr);
                if (ret || support.disconnectedMatch || elem.document && 11 !== elem.document.nodeType) return ret;
            } catch (e) {}
            return Sizzle(expr, document, null, [ elem ]).length > 0;
        }, Sizzle.contains = function(context, elem) {
            return (context.ownerDocument || context) !== document && setDocument(context), 
            contains(context, elem);
        }, Sizzle.attr = function(elem, name) {
            (elem.ownerDocument || elem) !== document && setDocument(elem);
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
            return void 0 !== val ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }, Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        }, Sizzle.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i = 0;
            if (hasDuplicate = !support.detectDuplicates, sortInput = !support.sortStable && results.slice(0), 
            results.sort(sortOrder), hasDuplicate) {
                for (;elem = results[i++]; ) elem === results[i] && (j = duplicates.push(i));
                for (;j--; ) results.splice(duplicates[j], 1);
            }
            return sortInput = null, results;
        }, getText = Sizzle.getText = function(elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;
            if (nodeType) {
                if (1 === nodeType || 9 === nodeType || 11 === nodeType) {
                    if ("string" == typeof elem.textContent) return elem.textContent;
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) ret += getText(elem);
                } else if (3 === nodeType || 4 === nodeType) return elem.nodeValue;
            } else for (;node = elem[i++]; ) ret += getText(node);
            return ret;
        }, Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(match) {
                    return match[1] = match[1].replace(runescape, funescape), match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape), 
                    "~=" === match[2] && (match[3] = " " + match[3] + " "), match.slice(0, 4);
                },
                CHILD: function(match) {
                    return match[1] = match[1].toLowerCase(), "nth" === match[1].slice(0, 3) ? (match[3] || Sizzle.error(match[0]), 
                    match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * ("even" === match[3] || "odd" === match[3])), 
                    match[5] = +(match[7] + match[8] || "odd" === match[3])) : match[3] && Sizzle.error(match[0]), 
                    match;
                },
                PSEUDO: function(match) {
                    var excess, unquoted = !match[6] && match[2];
                    return matchExpr.CHILD.test(match[0]) ? null : (match[3] ? match[2] = match[4] || match[5] || "" : unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, !0)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length) && (match[0] = match[0].slice(0, excess), 
                    match[2] = unquoted.slice(0, excess)), match.slice(0, 3));
                }
            },
            filter: {
                TAG: function(nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return "*" === nodeNameSelector ? function() {
                        return !0;
                    } : function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                CLASS: function(className) {
                    var pattern = classCache[className + " "];
                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                        return pattern.test("string" == typeof elem.className && elem.className || "undefined" != typeof elem.getAttribute && elem.getAttribute("class") || "");
                    });
                },
                ATTR: function(name, operator, check) {
                    return function(elem) {
                        var result = Sizzle.attr(elem, name);
                        return null == result ? "!=" === operator : operator ? (result += "", "=" === operator ? result === check : "!=" === operator ? result !== check : "^=" === operator ? check && 0 === result.indexOf(check) : "*=" === operator ? check && result.indexOf(check) > -1 : "$=" === operator ? check && result.slice(-check.length) === check : "~=" === operator ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : "|=" === operator ? result === check || result.slice(0, check.length + 1) === check + "-" : !1) : !0;
                    };
                },
                CHILD: function(type, what, argument, first, last) {
                    var simple = "nth" !== type.slice(0, 3), forward = "last" !== type.slice(-4), ofType = "of-type" === what;
                    return 1 === first && 0 === last ? function(elem) {
                        return !!elem.parentNode;
                    } : function(elem, context, xml) {
                        var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
                        if (parent) {
                            if (simple) {
                                for (;dir; ) {
                                    for (node = elem; node = node[dir]; ) if (ofType ? node.nodeName.toLowerCase() === name : 1 === node.nodeType) return !1;
                                    start = dir = "only" === type && !start && "nextSibling";
                                }
                                return !0;
                            }
                            if (start = [ forward ? parent.firstChild : parent.lastChild ], forward && useCache) {
                                for (outerCache = parent[expando] || (parent[expando] = {}), cache = outerCache[type] || [], 
                                nodeIndex = cache[0] === dirruns && cache[1], diff = cache[0] === dirruns && cache[2], 
                                node = nodeIndex && parent.childNodes[nodeIndex]; node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop(); ) if (1 === node.nodeType && ++diff && node === elem) {
                                    outerCache[type] = [ dirruns, nodeIndex, diff ];
                                    break;
                                }
                            } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) diff = cache[1]; else for (;(node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) && ((ofType ? node.nodeName.toLowerCase() !== name : 1 !== node.nodeType) || !++diff || (useCache && ((node[expando] || (node[expando] = {}))[type] = [ dirruns, diff ]), 
                            node !== elem)); ) ;
                            return diff -= last, diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                PSEUDO: function(pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                    return fn[expando] ? fn(argument) : fn.length > 1 ? (args = [ pseudo, pseudo, "", argument ], 
                    Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                        for (var idx, matched = fn(seed, argument), i = matched.length; i--; ) idx = indexOf(seed, matched[i]), 
                        seed[idx] = !(matches[idx] = matched[i]);
                    }) : function(elem) {
                        return fn(elem, 0, args);
                    }) : fn;
                }
            },
            pseudos: {
                not: markFunction(function(selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
                    return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                        for (var elem, unmatched = matcher(seed, null, xml, []), i = seed.length; i--; ) (elem = unmatched[i]) && (seed[i] = !(matches[i] = elem));
                    }) : function(elem, context, xml) {
                        return input[0] = elem, matcher(input, null, xml, results), input[0] = null, !results.pop();
                    };
                }),
                has: markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                contains: markFunction(function(text) {
                    return text = text.replace(runescape, funescape), function(elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                lang: markFunction(function(lang) {
                    return ridentifier.test(lang || "") || Sizzle.error("unsupported lang: " + lang), 
                    lang = lang.replace(runescape, funescape).toLowerCase(), function(elem) {
                        var elemLang;
                        do if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) return elemLang = elemLang.toLowerCase(), 
                        elemLang === lang || 0 === elemLang.indexOf(lang + "-"); while ((elem = elem.parentNode) && 1 === elem.nodeType);
                        return !1;
                    };
                }),
                target: function(elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                root: function(elem) {
                    return elem === docElem;
                },
                focus: function(elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                enabled: function(elem) {
                    return elem.disabled === !1;
                },
                disabled: function(elem) {
                    return elem.disabled === !0;
                },
                checked: function(elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return "input" === nodeName && !!elem.checked || "option" === nodeName && !!elem.selected;
                },
                selected: function(elem) {
                    return elem.parentNode && elem.parentNode.selectedIndex, elem.selected === !0;
                },
                empty: function(elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) if (elem.nodeType < 6) return !1;
                    return !0;
                },
                parent: function(elem) {
                    return !Expr.pseudos.empty(elem);
                },
                header: function(elem) {
                    return rheader.test(elem.nodeName);
                },
                input: function(elem) {
                    return rinputs.test(elem.nodeName);
                },
                button: function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return "input" === name && "button" === elem.type || "button" === name;
                },
                text: function(elem) {
                    var attr;
                    return "input" === elem.nodeName.toLowerCase() && "text" === elem.type && (null == (attr = elem.getAttribute("type")) || "text" === attr.toLowerCase());
                },
                first: createPositionalPseudo(function() {
                    return [ 0 ];
                }),
                last: createPositionalPseudo(function(matchIndexes, length) {
                    return [ length - 1 ];
                }),
                eq: createPositionalPseudo(function(matchIndexes, length, argument) {
                    return [ 0 > argument ? argument + length : argument ];
                }),
                even: createPositionalPseudo(function(matchIndexes, length) {
                    for (var i = 0; length > i; i += 2) matchIndexes.push(i);
                    return matchIndexes;
                }),
                odd: createPositionalPseudo(function(matchIndexes, length) {
                    for (var i = 1; length > i; i += 2) matchIndexes.push(i);
                    return matchIndexes;
                }),
                lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    for (var i = 0 > argument ? argument + length : argument; --i >= 0; ) matchIndexes.push(i);
                    return matchIndexes;
                }),
                gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    for (var i = 0 > argument ? argument + length : argument; ++i < length; ) matchIndexes.push(i);
                    return matchIndexes;
                })
            }
        }, Expr.pseudos.nth = Expr.pseudos.eq;
        // Add button/input type pseudos
        for (i in {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        }) Expr.pseudos[i] = createInputPseudo(i);
        for (i in {
            submit: !0,
            reset: !0
        }) Expr.pseudos[i] = createButtonPseudo(i);
        /**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
        // One-time assignments
        // Sort stability
        // Support: Chrome 14-35+
        // Always assume duplicates if they aren't passed to the comparison function
        // Initialize against the default document
        // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
        // Detached nodes confoundingly follow *each other*
        // Support: IE<8
        // Prevent attribute/property "interpolation"
        // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
        // Support: IE<9
        // Use defaultValue in place of getAttribute("value")
        // Support: IE<9
        // Use getAttributeNode to fetch booleans when getAttribute lies
        return setFilters.prototype = Expr.filters = Expr.pseudos, Expr.setFilters = new setFilters(), 
        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) return parseOnly ? 0 : cached.slice(0);
            for (soFar = selector, groups = [], preFilters = Expr.preFilter; soFar; ) {
                // Comma and first run
                (!matched || (match = rcomma.exec(soFar))) && (match && (// Don't consume trailing commas as valid
                soFar = soFar.slice(match[0].length) || soFar), groups.push(tokens = [])), matched = !1, 
                // Combinators
                (match = rcombinators.exec(soFar)) && (matched = match.shift(), tokens.push({
                    value: matched,
                    type: match[0].replace(rtrim, " ")
                }), soFar = soFar.slice(matched.length));
                // Filters
                for (type in Expr.filter) !(match = matchExpr[type].exec(soFar)) || preFilters[type] && !(match = preFilters[type](match)) || (matched = match.shift(), 
                tokens.push({
                    value: matched,
                    type: type,
                    matches: match
                }), soFar = soFar.slice(matched.length));
                if (!matched) break;
            }
            // Return the length of the invalid excess
            // if we're just parsing
            // Otherwise, throw an error or return tokens
            // Cache the tokens
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        }, compile = Sizzle.compile = function(selector, match) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
                for (match || (match = tokenize(selector)), i = match.length; i--; ) cached = matcherFromTokens(match[i]), 
                cached[expando] ? setMatchers.push(cached) : elementMatchers.push(cached);
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)), 
                cached.selector = selector;
            }
            return cached;
        }, select = Sizzle.select = function(selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = "function" == typeof selector && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            if (results = results || [], 1 === match.length) {
                if (tokens = match[0] = match[0].slice(0), tokens.length > 2 && "ID" === (token = tokens[0]).type && support.getById && 9 === context.nodeType && documentIsHTML && Expr.relative[tokens[1].type]) {
                    if (context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0], 
                    !context) return results;
                    compiled && (context = context.parentNode), selector = selector.slice(tokens.shift().value.length);
                }
                for (i = matchExpr.needsContext.test(selector) ? 0 : tokens.length; i-- && (token = tokens[i], 
                !Expr.relative[type = token.type]); ) if ((find = Expr.find[type]) && (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
                    if (tokens.splice(i, 1), selector = seed.length && toSelector(tokens), !selector) return push.apply(results, seed), 
                    results;
                    break;
                }
            }
            return (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context), 
            results;
        }, support.sortStable = expando.split("").sort(sortOrder).join("") === expando, 
        support.detectDuplicates = !!hasDuplicate, setDocument(), support.sortDetached = assert(function(div1) {
            return 1 & div1.compareDocumentPosition(document.createElement("div"));
        }), assert(function(div) {
            return div.innerHTML = "<a href='#'></a>", "#" === div.firstChild.getAttribute("href");
        }) || addHandle("type|href|height|width", function(elem, name, isXML) {
            return isXML ? void 0 : elem.getAttribute(name, "type" === name.toLowerCase() ? 1 : 2);
        }), support.attributes && assert(function(div) {
            return div.innerHTML = "<input/>", div.firstChild.setAttribute("value", ""), "" === div.firstChild.getAttribute("value");
        }) || addHandle("value", function(elem, name, isXML) {
            return isXML || "input" !== elem.nodeName.toLowerCase() ? void 0 : elem.defaultValue;
        }), assert(function(div) {
            return null == div.getAttribute("disabled");
        }) || addHandle(booleans, function(elem, name, isXML) {
            var val;
            return isXML ? void 0 : elem[name] === !0 ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }), Sizzle;
    }(window);
    jQuery.find = Sizzle, jQuery.expr = Sizzle.selectors, jQuery.expr[":"] = jQuery.expr.pseudos, 
    jQuery.unique = Sizzle.uniqueSort, jQuery.text = Sizzle.getText, jQuery.isXMLDoc = Sizzle.isXML, 
    jQuery.contains = Sizzle.contains;
    var rneedsContext = jQuery.expr.match.needsContext, rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, risSimple = /^.[^:#\[\.,]*$/;
    jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        return not && (expr = ":not(" + expr + ")"), 1 === elems.length && 1 === elem.nodeType ? jQuery.find.matchesSelector(elem, expr) ? [ elem ] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
            return 1 === elem.nodeType;
        }));
    }, jQuery.fn.extend({
        find: function(selector) {
            var i, ret = [], self = this, len = self.length;
            if ("string" != typeof selector) return this.pushStack(jQuery(selector).filter(function() {
                for (i = 0; len > i; i++) if (jQuery.contains(self[i], this)) return !0;
            }));
            for (i = 0; len > i; i++) jQuery.find(selector, self[i], ret);
            // Needed because $( selector, context ) becomes $( context ).find( selector )
            return ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret), ret.selector = this.selector ? this.selector + " " + selector : selector, 
            ret;
        },
        filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], !1));
        },
        not: function(selector) {
            return this.pushStack(winnow(this, selector || [], !0));
        },
        is: function(selector) {
            // If this is a positional/relative selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
            return !!winnow(this, "string" == typeof selector && rneedsContext.test(selector) ? jQuery(selector) : selector || [], !1).length;
        }
    });
    // Initialize a jQuery object
    // A central reference to the root jQuery(document)
    var rootjQuery, // Use the correct document accordingly with window argument (sandbox)
    document = window.document, // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    // Strict HTML recognition (#11290: must start with <)
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery.fn.init = function(selector, context) {
        var match, elem;
        // HANDLE: $(""), $(null), $(undefined), $(false)
        if (!selector) return this;
        // Handle HTML strings
        if ("string" == typeof selector) {
            // Match html or make sure no context is specified for #id
            if (match = "<" === selector.charAt(0) && ">" === selector.charAt(selector.length - 1) && selector.length >= 3 ? [ null, selector, null ] : rquickExpr.exec(selector), 
            !match || !match[1] && context) return !context || context.jquery ? (context || rootjQuery).find(selector) : this.constructor(context).find(selector);
            // HANDLE: $(html) -> $(array)
            if (match[1]) {
                // HANDLE: $(html, props)
                if (context = context instanceof jQuery ? context[0] : context, jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, !0)), 
                rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) for (match in context) // Properties of context are called as methods if possible
                jQuery.isFunction(this[match]) ? this[match](context[match]) : this.attr(match, context[match]);
                return this;
            }
            // Check parentNode to catch when Blackberry 4.6 returns
            // nodes that are no longer in the document #6963
            if (elem = document.getElementById(match[2]), elem && elem.parentNode) {
                // Handle the case where IE and Opera return items
                // by name instead of ID
                if (elem.id !== match[2]) return rootjQuery.find(selector);
                // Otherwise, we inject the element directly into the jQuery object
                this.length = 1, this[0] = elem;
            }
            return this.context = document, this.selector = selector, this;
        }
        // Execute immediately if ready is not present
        return selector.nodeType ? (this.context = this[0] = selector, this.length = 1, 
        this) : jQuery.isFunction(selector) ? "undefined" != typeof rootjQuery.ready ? rootjQuery.ready(selector) : selector(jQuery) : (void 0 !== selector.selector && (this.selector = selector.selector, 
        this.context = selector.context), jQuery.makeArray(selector, this));
    };
    // Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn, // Initialize central reference
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, // methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };
    jQuery.extend({
        dir: function(elem, dir, until) {
            for (var matched = [], cur = elem[dir]; cur && 9 !== cur.nodeType && (void 0 === until || 1 !== cur.nodeType || !jQuery(cur).is(until)); ) 1 === cur.nodeType && matched.push(cur), 
            cur = cur[dir];
            return matched;
        },
        sibling: function(n, elem) {
            for (var r = []; n; n = n.nextSibling) 1 === n.nodeType && n !== elem && r.push(n);
            return r;
        }
    }), jQuery.fn.extend({
        has: function(target) {
            var i, targets = jQuery(target, this), len = targets.length;
            return this.filter(function() {
                for (i = 0; len > i; i++) if (jQuery.contains(this, targets[i])) return !0;
            });
        },
        closest: function(selectors, context) {
            for (var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || "string" != typeof selectors ? jQuery(selectors, context || this.context) : 0; l > i; i++) for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) // Always skip document fragments
            if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : 1 === cur.nodeType && jQuery.find.matchesSelector(cur, selectors))) {
                matched.push(cur);
                break;
            }
            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
        },
        // Determine the position of an element within
        // the matched set of elements
        index: function(elem) {
            // No argument, return index in parent
            // No argument, return index in parent
            // index in selector
            // If it receives a jQuery object, the first element is used
            return elem ? "string" == typeof elem ? jQuery.inArray(this[0], jQuery(elem)) : jQuery.inArray(elem.jquery ? elem[0] : elem, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        },
        add: function(selector, context) {
            return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function(selector) {
            return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector));
        }
    }), jQuery.each({
        parent: function(elem) {
            var parent = elem.parentNode;
            return parent && 11 !== parent.nodeType ? parent : null;
        },
        parents: function(elem) {
            return jQuery.dir(elem, "parentNode");
        },
        parentsUntil: function(elem, i, until) {
            return jQuery.dir(elem, "parentNode", until);
        },
        next: function(elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
            return jQuery.dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
            return jQuery.dir(elem, "previousSibling");
        },
        nextUntil: function(elem, i, until) {
            return jQuery.dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, i, until) {
            return jQuery.dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
            return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function(elem) {
            return jQuery.nodeName(elem, "iframe") ? elem.contentDocument || elem.contentWindow.document : jQuery.merge([], elem.childNodes);
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var ret = jQuery.map(this, fn, until);
            // Remove duplicates
            // Reverse order for parents* and prev-derivatives
            return "Until" !== name.slice(-5) && (selector = until), selector && "string" == typeof selector && (ret = jQuery.filter(selector, ret)), 
            this.length > 1 && (guaranteedUnique[name] || (ret = jQuery.unique(ret)), rparentsprev.test(name) && (ret = ret.reverse())), 
            this.pushStack(ret);
        };
    });
    var rnotwhite = /\S+/g, optionsCache = {};
    /*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
    jQuery.Callbacks = function(options) {
        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = "string" == typeof options ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
        var // Flag to know if list is currently firing
        firing, // Last fire value (for non-forgettable lists)
        memory, // Flag to know if list was already fired
        fired, // End of the loop when firing
        firingLength, // Index of currently firing callback (modified by remove if needed)
        firingIndex, // First callback to fire (used internally by add and fireWith)
        firingStart, // Actual callback list
        list = [], // Stack of fire calls for repeatable lists
        stack = !options.once && [], // Fire callbacks
        fire = function(data) {
            for (memory = options.memory && data, fired = !0, firingIndex = firingStart || 0, 
            firingStart = 0, firingLength = list.length, firing = !0; list && firingLength > firingIndex; firingIndex++) if (list[firingIndex].apply(data[0], data[1]) === !1 && options.stopOnFalse) {
                memory = !1;
                // To prevent further calls using add
                break;
            }
            firing = !1, list && (stack ? stack.length && fire(stack.shift()) : memory ? list = [] : self.disable());
        }, // Actual Callbacks object
        self = {
            // Add a callback or a collection of callbacks to the list
            add: function() {
                if (list) {
                    // First, we save the current length
                    var start = list.length;
                    !function add(args) {
                        jQuery.each(args, function(_, arg) {
                            var type = jQuery.type(arg);
                            "function" === type ? options.unique && self.has(arg) || list.push(arg) : arg && arg.length && "string" !== type && // Inspect recursively
                            add(arg);
                        });
                    }(arguments), // Do we need to add the callbacks to the
                    // current firing batch?
                    firing ? firingLength = list.length : memory && (firingStart = start, fire(memory));
                }
                return this;
            },
            // Remove a callback from the list
            remove: function() {
                return list && jQuery.each(arguments, function(_, arg) {
                    for (var index; (index = jQuery.inArray(arg, list, index)) > -1; ) list.splice(index, 1), 
                    // Handle firing indexes
                    firing && (firingLength >= index && firingLength--, firingIndex >= index && firingIndex--);
                }), this;
            },
            // Check if a given callback is in the list.
            // If no argument is given, return whether or not list has callbacks attached.
            has: function(fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : !(!list || !list.length);
            },
            // Remove all callbacks from the list
            empty: function() {
                return list = [], firingLength = 0, this;
            },
            // Have the list do nothing anymore
            disable: function() {
                return list = stack = memory = void 0, this;
            },
            // Is it disabled?
            disabled: function() {
                return !list;
            },
            // Lock the list in its current state
            lock: function() {
                return stack = void 0, memory || self.disable(), this;
            },
            // Is it locked?
            locked: function() {
                return !stack;
            },
            // Call all callbacks with the given context and arguments
            fireWith: function(context, args) {
                return !list || fired && !stack || (args = args || [], args = [ context, args.slice ? args.slice() : args ], 
                firing ? stack.push(args) : fire(args)), this;
            },
            // Call all the callbacks with the given arguments
            fire: function() {
                return self.fireWith(this, arguments), this;
            },
            // To know if the callbacks have already been called at least once
            fired: function() {
                return !!fired;
            }
        };
        return self;
    }, jQuery.extend({
        Deferred: function(func) {
            var tuples = [ // action, add listener, listener list, final state
            [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ], [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ], [ "notify", "progress", jQuery.Callbacks("memory") ] ], state = "pending", promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    return deferred.done(arguments).fail(arguments), this;
                },
                then: function() {
                    var fns = arguments;
                    return jQuery.Deferred(function(newDefer) {
                        jQuery.each(tuples, function(i, tuple) {
                            var fn = jQuery.isFunction(fns[i]) && fns[i];
                            // deferred[ done | fail | progress ] for forwarding actions to newDefer
                            deferred[tuple[1]](function() {
                                var returned = fn && fn.apply(this, arguments);
                                returned && jQuery.isFunction(returned.promise) ? returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify) : newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments);
                            });
                        }), fns = null;
                    }).promise();
                },
                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function(obj) {
                    return null != obj ? jQuery.extend(obj, promise) : promise;
                }
            }, deferred = {};
            // All done!
            // Keep pipe for back-compat
            // Add list-specific methods
            // Make the deferred a promise
            // Call given func if any
            return promise.pipe = promise.then, jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2], stateString = tuple[3];
                // promise[ done | fail | progress ] = list.add
                promise[tuple[1]] = list.add, // Handle state
                stateString && list.add(function() {
                    // state = [ resolved | rejected ]
                    state = stateString;
                }, tuples[1 ^ i][2].disable, tuples[2][2].lock), // deferred[ resolve | reject | notify ]
                deferred[tuple[0]] = function() {
                    return deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments), 
                    this;
                }, deferred[tuple[0] + "With"] = list.fireWith;
            }), promise.promise(deferred), func && func.call(deferred, deferred), deferred;
        },
        // Deferred helper
        when: function(subordinate) {
            var progressValues, progressContexts, resolveContexts, i = 0, resolveValues = slice.call(arguments), length = resolveValues.length, // the count of uncompleted subordinates
            remaining = 1 !== length || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
            deferred = 1 === remaining ? subordinate : jQuery.Deferred(), // Update function for both resolve and progress values
            updateFunc = function(i, contexts, values) {
                return function(value) {
                    contexts[i] = this, values[i] = arguments.length > 1 ? slice.call(arguments) : value, 
                    values === progressValues ? deferred.notifyWith(contexts, values) : --remaining || deferred.resolveWith(contexts, values);
                };
            };
            // add listeners to Deferred subordinates; treat others as resolved
            if (length > 1) for (progressValues = new Array(length), progressContexts = new Array(length), 
            resolveContexts = new Array(length); length > i; i++) resolveValues[i] && jQuery.isFunction(resolveValues[i].promise) ? resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues)) : --remaining;
            // if we're not waiting on anything, resolve the master
            return remaining || deferred.resolveWith(resolveContexts, resolveValues), deferred.promise();
        }
    });
    // The deferred used on DOM ready
    var readyList;
    jQuery.fn.ready = function(fn) {
        // Add the callback
        return jQuery.ready.promise().done(fn), this;
    }, jQuery.extend({
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: !1,
        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,
        // Hold (or release) the ready event
        holdReady: function(hold) {
            hold ? jQuery.readyWait++ : jQuery.ready(!0);
        },
        // Handle when the DOM is ready
        ready: function(wait) {
            // Abort if there are pending holds or we're already ready
            if (wait === !0 ? !--jQuery.readyWait : !jQuery.isReady) {
                // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                if (!document.body) return setTimeout(jQuery.ready);
                // Remember that the DOM is ready
                jQuery.isReady = !0, // If a normal DOM Ready event fired, decrement, and wait if need be
                wait !== !0 && --jQuery.readyWait > 0 || (// If there are functions bound, to execute
                readyList.resolveWith(document, [ jQuery ]), // Trigger any bound ready events
                jQuery.fn.triggerHandler && (jQuery(document).triggerHandler("ready"), jQuery(document).off("ready")));
            }
        }
    }), jQuery.ready.promise = function(obj) {
        if (!readyList) // Catch cases where $(document).ready() is called after the browser event has already occurred.
        // we once tried to use readyState "interactive" here, but it caused issues like the one
        // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
        if (readyList = jQuery.Deferred(), "complete" === document.readyState) // Handle it asynchronously to allow scripts the opportunity to delay ready
        setTimeout(jQuery.ready); else if (document.addEventListener) // Use the handy event callback
        document.addEventListener("DOMContentLoaded", completed, !1), // A fallback to window.onload, that will always work
        window.addEventListener("load", completed, !1); else {
            // Ensure firing before onload, maybe late but safe also for iframes
            document.attachEvent("onreadystatechange", completed), // A fallback to window.onload, that will always work
            window.attachEvent("onload", completed);
            // If IE and not a frame
            // continually check to see if the document is ready
            var top = !1;
            try {
                top = null == window.frameElement && document.documentElement;
            } catch (e) {}
            top && top.doScroll && !function doScrollCheck() {
                if (!jQuery.isReady) {
                    try {
                        // Use the trick by Diego Perini
                        // http://javascript.nwbox.com/IEContentLoaded/
                        top.doScroll("left");
                    } catch (e) {
                        return setTimeout(doScrollCheck, 50);
                    }
                    // detach all dom ready events
                    detach(), // and execute any waiting functions
                    jQuery.ready();
                }
            }();
        }
        return readyList.promise(obj);
    };
    var i, strundefined = "undefined";
    for (i in jQuery(support)) break;
    support.ownLast = "0" !== i, // Note: most support tests are defined in their respective modules.
    // false until the test is run
    support.inlineBlockNeedsLayout = !1, // Execute ASAP in case we need to set body.style.zoom
    jQuery(function() {
        // Minified: var a,b,c,d
        var val, div, body, container;
        body = document.getElementsByTagName("body")[0], body && body.style && (div = document.createElement("div"), 
        container = document.createElement("div"), container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", 
        body.appendChild(container).appendChild(div), typeof div.style.zoom !== strundefined && (div.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1", 
        support.inlineBlockNeedsLayout = val = 3 === div.offsetWidth, val && (body.style.zoom = 1)), 
        body.removeChild(container));
    }), function() {
        var div = document.createElement("div");
        // Execute the test only if not already executed in another module.
        if (null == support.deleteExpando) {
            // Support: IE<9
            support.deleteExpando = !0;
            try {
                delete div.test;
            } catch (e) {
                support.deleteExpando = !1;
            }
        }
        // Null elements to avoid leaks in IE.
        div = null;
    }(), /**
 * Determines whether an object can have data
 */
    jQuery.acceptData = function(elem) {
        var noData = jQuery.noData[(elem.nodeName + " ").toLowerCase()], nodeType = +elem.nodeType || 1;
        // Do not set data on non-element DOM nodes because it will not be cleared (#8335).
        // Nodes accept data unless otherwise specified; rejection can be conditional
        return 1 !== nodeType && 9 !== nodeType ? !1 : !noData || noData !== !0 && elem.getAttribute("classid") === noData;
    };
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /([A-Z])/g;
    jQuery.extend({
        cache: {},
        // The following elements (space-suffixed to avoid Object.prototype collisions)
        // throw uncatchable exceptions if you attempt to set expando properties
        noData: {
            "applet ": !0,
            "embed ": !0,
            // ...but Flash objects (which have this classid) *can* handle expandos
            "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
        },
        hasData: function(elem) {
            return elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando], 
            !!elem && !isEmptyDataObject(elem);
        },
        data: function(elem, name, data) {
            return internalData(elem, name, data);
        },
        removeData: function(elem, name) {
            return internalRemoveData(elem, name);
        },
        // For internal use only.
        _data: function(elem, name, data) {
            return internalData(elem, name, data, !0);
        },
        _removeData: function(elem, name) {
            return internalRemoveData(elem, name, !0);
        }
    }), jQuery.fn.extend({
        data: function(key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            // Special expections of .data basically thwart jQuery.access,
            // so implement the relevant behavior ourselves
            // Gets all values
            if (void 0 === key) {
                if (this.length && (data = jQuery.data(elem), 1 === elem.nodeType && !jQuery._data(elem, "parsedAttrs"))) {
                    for (i = attrs.length; i--; ) // Support: IE11+
                    // The attrs elements can be null (#14894)
                    attrs[i] && (name = attrs[i].name, 0 === name.indexOf("data-") && (name = jQuery.camelCase(name.slice(5)), 
                    dataAttr(elem, name, data[name])));
                    jQuery._data(elem, "parsedAttrs", !0);
                }
                return data;
            }
            // Sets multiple values
            // Sets multiple values
            // Sets one value
            // Gets one value
            // Try to fetch any internally stored data first
            return "object" == typeof key ? this.each(function() {
                jQuery.data(this, key);
            }) : arguments.length > 1 ? this.each(function() {
                jQuery.data(this, key, value);
            }) : elem ? dataAttr(elem, key, jQuery.data(elem, key)) : void 0;
        },
        removeData: function(key) {
            return this.each(function() {
                jQuery.removeData(this, key);
            });
        }
    }), jQuery.extend({
        queue: function(elem, type, data) {
            var queue;
            // Speed up dequeue by getting out quickly if this is just a lookup
            return elem ? (type = (type || "fx") + "queue", queue = jQuery._data(elem, type), 
            data && (!queue || jQuery.isArray(data) ? queue = jQuery._data(elem, type, jQuery.makeArray(data)) : queue.push(data)), 
            queue || []) : void 0;
        },
        dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
                jQuery.dequeue(elem, type);
            };
            // If the fx queue is dequeued, always remove the progress sentinel
            "inprogress" === fn && (fn = queue.shift(), startLength--), fn && (// Add a progress sentinel to prevent the fx queue from being
            // automatically dequeued
            "fx" === type && queue.unshift("inprogress"), // clear up the last queue stop function
            delete hooks.stop, fn.call(elem, next, hooks)), !startLength && hooks && hooks.empty.fire();
        },
        // not intended for public consumption - generates a queueHooks object, or returns the current one
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return jQuery._data(elem, key) || jQuery._data(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    jQuery._removeData(elem, type + "queue"), jQuery._removeData(elem, key);
                })
            });
        }
    }), jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;
            return "string" != typeof type && (data = type, type = "fx", setter--), arguments.length < setter ? jQuery.queue(this[0], type) : void 0 === data ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);
                // ensure a hooks for this queue
                jQuery._queueHooks(this, type), "fx" === type && "inprogress" !== queue[0] && jQuery.dequeue(this, type);
            });
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                --count || defer.resolveWith(elements, [ elements ]);
            };
            for ("string" != typeof type && (obj = type, type = void 0), type = type || "fx"; i--; ) tmp = jQuery._data(elements[i], type + "queueHooks"), 
            tmp && tmp.empty && (count++, tmp.empty.add(resolve));
            return resolve(), defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, cssExpand = [ "Top", "Right", "Bottom", "Left" ], isHidden = function(elem, el) {
        // isHidden might be called from jQuery#filter function;
        // in that case, element will be second argument
        return elem = el || elem, "none" === jQuery.css(elem, "display") || !jQuery.contains(elem.ownerDocument, elem);
    }, access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, length = elems.length, bulk = null == key;
        // Sets many values
        if ("object" === jQuery.type(key)) {
            chainable = !0;
            for (i in key) jQuery.access(elems, fn, i, key[i], !0, emptyGet, raw);
        } else if (void 0 !== value && (chainable = !0, jQuery.isFunction(value) || (raw = !0), 
        bulk && (raw ? (fn.call(elems, value), fn = null) : (bulk = fn, fn = function(elem, key, value) {
            return bulk.call(jQuery(elem), value);
        })), fn)) for (;length > i; i++) fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        // Gets
        return chainable ? elems : bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;
    }, rcheckableType = /^(?:checkbox|radio)$/i;
    !function() {
        // Minified: var a,b,c
        var input = document.createElement("input"), div = document.createElement("div"), fragment = document.createDocumentFragment();
        // Execute the test only if not already executed in another module.
        if (// Setup
        div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
        // IE strips leading whitespace when .innerHTML is used
        support.leadingWhitespace = 3 === div.firstChild.nodeType, // Make sure that tbody elements aren't automatically inserted
        // IE will insert them into empty tables
        support.tbody = !div.getElementsByTagName("tbody").length, // Make sure that link elements get serialized correctly by innerHTML
        // This requires a wrapper element in IE
        support.htmlSerialize = !!div.getElementsByTagName("link").length, // Makes sure cloning an html5 element does not cause problems
        // Where outerHTML is undefined, this still works
        support.html5Clone = "<:nav></:nav>" !== document.createElement("nav").cloneNode(!0).outerHTML, 
        // Check if a disconnected checkbox will retain its checked
        // value of true after appended to the DOM (IE6/7)
        input.type = "checkbox", input.checked = !0, fragment.appendChild(input), support.appendChecked = input.checked, 
        // Make sure textarea (and checkbox) defaultValue is properly cloned
        // Support: IE6-IE11+
        div.innerHTML = "<textarea>x</textarea>", support.noCloneChecked = !!div.cloneNode(!0).lastChild.defaultValue, 
        // #11217 - WebKit loses check when the name is after the checked attribute
        fragment.appendChild(div), div.innerHTML = "<input type='radio' checked='checked' name='t'/>", 
        // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
        // old WebKit doesn't clone checked state correctly in fragments
        support.checkClone = div.cloneNode(!0).cloneNode(!0).lastChild.checked, // Support: IE<9
        // Opera does not clone events (and typeof div.attachEvent === undefined).
        // IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
        support.noCloneEvent = !0, div.attachEvent && (div.attachEvent("onclick", function() {
            support.noCloneEvent = !1;
        }), div.cloneNode(!0).click()), null == support.deleteExpando) {
            // Support: IE<9
            support.deleteExpando = !0;
            try {
                delete div.test;
            } catch (e) {
                support.deleteExpando = !1;
            }
        }
    }(), function() {
        var i, eventName, div = document.createElement("div");
        // Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin event)
        for (i in {
            submit: !0,
            change: !0,
            focusin: !0
        }) eventName = "on" + i, (support[i + "Bubbles"] = eventName in window) || (div.setAttribute(eventName, "t"), 
        support[i + "Bubbles"] = div.attributes[eventName].expando === !1);
        // Null elements to avoid leaks in IE.
        div = null;
    }();
    var rformElems = /^(?:input|select|textarea)$/i, rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
    /*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
    jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
            var tmp, events, t, handleObjIn, special, eventHandle, handleObj, handlers, type, namespaces, origType, elemData = jQuery._data(elem);
            // Don't attach events to noData or text/comment nodes (but allow plain objects)
            if (elemData) {
                for (// Caller can pass in an object of custom data in lieu of the handler
                handler.handler && (handleObjIn = handler, handler = handleObjIn.handler, selector = handleObjIn.selector), 
                // Make sure that the handler has a unique ID, used to find/remove it later
                handler.guid || (handler.guid = jQuery.guid++), // Init the element's event structure and main handler, if this is the first
                (events = elemData.events) || (events = elemData.events = {}), (eventHandle = elemData.handle) || (eventHandle = elemData.handle = function(e) {
                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery === strundefined || e && jQuery.event.triggered === e.type ? void 0 : jQuery.event.dispatch.apply(eventHandle.elem, arguments);
                }, eventHandle.elem = elem), // Handle multiple events separated by a space
                types = (types || "").match(rnotwhite) || [ "" ], t = types.length; t--; ) tmp = rtypenamespace.exec(types[t]) || [], 
                type = origType = tmp[1], namespaces = (tmp[2] || "").split(".").sort(), type && (special = jQuery.event.special[type] || {}, 
                type = (selector ? special.delegateType : special.bindType) || type, special = jQuery.event.special[type] || {}, 
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn), (handlers = events[type]) || (handlers = events[type] = [], handlers.delegateCount = 0, 
                special.setup && special.setup.call(elem, data, namespaces, eventHandle) !== !1 || (elem.addEventListener ? elem.addEventListener(type, eventHandle, !1) : elem.attachEvent && elem.attachEvent("on" + type, eventHandle))), 
                special.add && (special.add.call(elem, handleObj), handleObj.handler.guid || (handleObj.handler.guid = handler.guid)), 
                selector ? handlers.splice(handlers.delegateCount++, 0, handleObj) : handlers.push(handleObj), 
                jQuery.event.global[type] = !0);
                // Nullify elem to prevent memory leaks in IE
                elem = null;
            }
        },
        // Detach an event or set of events from an element
        remove: function(elem, types, handler, selector, mappedTypes) {
            var j, handleObj, tmp, origCount, t, events, special, handlers, type, namespaces, origType, elemData = jQuery.hasData(elem) && jQuery._data(elem);
            if (elemData && (events = elemData.events)) {
                for (// Once for each type.namespace in types; type may be omitted
                types = (types || "").match(rnotwhite) || [ "" ], t = types.length; t--; ) // Unbind all events (on this namespace, if provided) for the element
                if (tmp = rtypenamespace.exec(types[t]) || [], type = origType = tmp[1], namespaces = (tmp[2] || "").split(".").sort(), 
                type) {
                    for (special = jQuery.event.special[type] || {}, type = (selector ? special.delegateType : special.bindType) || type, 
                    handlers = events[type] || [], tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"), 
                    // Remove matching events
                    origCount = j = handlers.length; j--; ) handleObj = handlers[j], !mappedTypes && origType !== handleObj.origType || handler && handler.guid !== handleObj.guid || tmp && !tmp.test(handleObj.namespace) || selector && selector !== handleObj.selector && ("**" !== selector || !handleObj.selector) || (handlers.splice(j, 1), 
                    handleObj.selector && handlers.delegateCount--, special.remove && special.remove.call(elem, handleObj));
                    // Remove generic event handler if we removed something and no more handlers exist
                    // (avoids potential for endless recursion during removal of special event handlers)
                    origCount && !handlers.length && (special.teardown && special.teardown.call(elem, namespaces, elemData.handle) !== !1 || jQuery.removeEvent(elem, type, elemData.handle), 
                    delete events[type]);
                } else for (type in events) jQuery.event.remove(elem, type + types[t], handler, selector, !0);
                // Remove the expando if it's no longer used
                jQuery.isEmptyObject(events) && (delete elemData.handle, // removeData also checks for emptiness and clears the expando if empty
                // so use it instead of delete
                jQuery._removeData(elem, "events"));
            }
        },
        trigger: function(event, data, elem, onlyHandlers) {
            var handle, ontype, cur, bubbleType, special, tmp, i, eventPath = [ elem || document ], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            // Don't do events on text and comment nodes
            if (cur = tmp = elem = elem || document, 3 !== elem.nodeType && 8 !== elem.nodeType && !rfocusMorph.test(type + jQuery.event.triggered) && (type.indexOf(".") >= 0 && (namespaces = type.split("."), 
            type = namespaces.shift(), namespaces.sort()), ontype = type.indexOf(":") < 0 && "on" + type, 
            event = event[jQuery.expando] ? event : new jQuery.Event(type, "object" == typeof event && event), 
            event.isTrigger = onlyHandlers ? 2 : 3, event.namespace = namespaces.join("."), 
            event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, 
            event.result = void 0, event.target || (event.target = elem), data = null == data ? [ event ] : jQuery.makeArray(data, [ event ]), 
            special = jQuery.event.special[type] || {}, onlyHandlers || !special.trigger || special.trigger.apply(elem, data) !== !1)) {
                // Determine event propagation path in advance, per W3C events spec (#9951)
                // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
                if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                    for (bubbleType = special.delegateType || type, rfocusMorph.test(bubbleType + type) || (cur = cur.parentNode); cur; cur = cur.parentNode) eventPath.push(cur), 
                    tmp = cur;
                    // Only add window if we got to document (e.g., not plain obj or detached DOM)
                    tmp === (elem.ownerDocument || document) && eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
                for (// Fire handlers on the event path
                i = 0; (cur = eventPath[i++]) && !event.isPropagationStopped(); ) event.type = i > 1 ? bubbleType : special.bindType || type, 
                handle = (jQuery._data(cur, "events") || {})[event.type] && jQuery._data(cur, "handle"), 
                handle && handle.apply(cur, data), handle = ontype && cur[ontype], handle && handle.apply && jQuery.acceptData(cur) && (event.result = handle.apply(cur, data), 
                event.result === !1 && event.preventDefault());
                // If nobody prevented the default action, do it now
                if (event.type = type, !onlyHandlers && !event.isDefaultPrevented() && (!special._default || special._default.apply(eventPath.pop(), data) === !1) && jQuery.acceptData(elem) && ontype && elem[type] && !jQuery.isWindow(elem)) {
                    // Don't re-trigger an onFOO event when we call its FOO() method
                    tmp = elem[ontype], tmp && (elem[ontype] = null), // Prevent re-triggering of the same event, since we already bubbled it above
                    jQuery.event.triggered = type;
                    try {
                        elem[type]();
                    } catch (e) {}
                    jQuery.event.triggered = void 0, tmp && (elem[ontype] = tmp);
                }
                return event.result;
            }
        },
        dispatch: function(event) {
            // Make a writable jQuery.Event from the native event object
            event = jQuery.event.fix(event);
            var i, ret, handleObj, matched, j, handlerQueue = [], args = slice.call(arguments), handlers = (jQuery._data(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if (// Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[0] = event, event.delegateTarget = this, !special.preDispatch || special.preDispatch.call(this, event) !== !1) {
                for (// Determine handlers
                handlerQueue = jQuery.event.handlers.call(this, event, handlers), // Run delegates first; they may want to stop propagation beneath us
                i = 0; (matched = handlerQueue[i++]) && !event.isPropagationStopped(); ) for (event.currentTarget = matched.elem, 
                j = 0; (handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped(); ) // Triggered event must either 1) have no namespace, or
                // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
                (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) && (event.handleObj = handleObj, 
                event.data = handleObj.data, ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args), 
                void 0 !== ret && (event.result = ret) === !1 && (event.preventDefault(), event.stopPropagation()));
                // Call the postDispatch hook for the mapped type
                return special.postDispatch && special.postDispatch.call(this, event), event.result;
            }
        },
        handlers: function(event, handlers) {
            var sel, handleObj, matches, i, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            // Find delegate handlers
            // Black-hole SVG <use> instance trees (#13180)
            // Avoid non-left-click bubbling in Firefox (#3861)
            if (delegateCount && cur.nodeType && (!event.button || "click" !== event.type)) /* jshint eqeqeq: false */
            for (;cur != this; cur = cur.parentNode || this) /* jshint eqeqeq: true */
            // Don't check non-elements (#13208)
            // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
            if (1 === cur.nodeType && (cur.disabled !== !0 || "click" !== event.type)) {
                for (matches = [], i = 0; delegateCount > i; i++) handleObj = handlers[i], sel = handleObj.selector + " ", 
                void 0 === matches[sel] && (matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [ cur ]).length), 
                matches[sel] && matches.push(handleObj);
                matches.length && handlerQueue.push({
                    elem: cur,
                    handlers: matches
                });
            }
            // Add the remaining (directly-bound) handlers
            return delegateCount < handlers.length && handlerQueue.push({
                elem: this,
                handlers: handlers.slice(delegateCount)
            }), handlerQueue;
        },
        fix: function(event) {
            if (event[jQuery.expando]) return event;
            // Create a writable copy of the event object and normalize some properties
            var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
            for (fixHook || (this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {}), 
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props, event = new jQuery.Event(originalEvent), 
            i = copy.length; i--; ) prop = copy[i], event[prop] = originalEvent[prop];
            // Support: IE<9
            // Fix target property (#1925)
            // Support: Chrome 23+, Safari?
            // Target should not be a text node (#504, #13143)
            // Support: IE<9
            // For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
            return event.target || (event.target = originalEvent.srcElement || document), 3 === event.target.nodeType && (event.target = event.target.parentNode), 
            event.metaKey = !!event.metaKey, fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },
        // Includes some event props shared by KeyEvent and MouseEvent
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(event, original) {
                // Add which for key events
                return null == event.which && (event.which = null != original.charCode ? original.charCode : original.keyCode), 
                event;
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(event, original) {
                var body, eventDoc, doc, button = original.button, fromElement = original.fromElement;
                // Calculate pageX/Y if missing and clientX/Y available
                // Add relatedTarget, if necessary
                // Add which for click: 1 === left; 2 === middle; 3 === right
                // Note: button is not normalized, so don't use it
                return null == event.pageX && null != original.clientX && (eventDoc = event.target.ownerDocument || document, 
                doc = eventDoc.documentElement, body = eventDoc.body, event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0), 
                event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0)), 
                !event.relatedTarget && fromElement && (event.relatedTarget = fromElement === event.target ? original.toElement : fromElement), 
                event.which || void 0 === button || (event.which = 1 & button ? 1 : 2 & button ? 3 : 4 & button ? 2 : 0), 
                event;
            }
        },
        special: {
            load: {
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: !0
            },
            focus: {
                // Fire native event if possible so blur/focus sequence is correct
                trigger: function() {
                    if (this !== safeActiveElement() && this.focus) try {
                        return this.focus(), !1;
                    } catch (e) {}
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    return this === safeActiveElement() && this.blur ? (this.blur(), !1) : void 0;
                },
                delegateType: "focusout"
            },
            click: {
                // For checkbox, fire native event so checked state will be right
                trigger: function() {
                    return jQuery.nodeName(this, "input") && "checkbox" === this.type && this.click ? (this.click(), 
                    !1) : void 0;
                },
                // For cross-browser consistency, don't fire native .click() on links
                _default: function(event) {
                    return jQuery.nodeName(event.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(event) {
                    // Support: Firefox 20+
                    // Firefox doesn't alert if the returnValue field is not set.
                    void 0 !== event.result && event.originalEvent && (event.originalEvent.returnValue = event.result);
                }
            }
        },
        simulate: function(type, elem, event, bubble) {
            // Piggyback on a donor event to simulate a different one.
            // Fake originalEvent to avoid donor's stopPropagation, but if the
            // simulated event prevents default then we do the same on the donor.
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: !0,
                originalEvent: {}
            });
            bubble ? jQuery.event.trigger(e, null, elem) : jQuery.event.dispatch.call(elem, e), 
            e.isDefaultPrevented() && event.preventDefault();
        }
    }, jQuery.removeEvent = document.removeEventListener ? function(elem, type, handle) {
        elem.removeEventListener && elem.removeEventListener(type, handle, !1);
    } : function(elem, type, handle) {
        var name = "on" + type;
        elem.detachEvent && (// #8545, #7054, preventing memory leaks for custom events in IE6-8
        // detachEvent needed property on element, by name of that event, to properly expose it to GC
        typeof elem[name] === strundefined && (elem[name] = null), elem.detachEvent(name, handle));
    }, jQuery.Event = function(src, props) {
        // Allow instantiation without the 'new' keyword
        // Allow instantiation without the 'new' keyword
        // Event object
        // Events bubbling up the document may have been marked as prevented
        // by a handler lower down the tree; reflect the correct value.
        // Support: IE < 9, Android < 4.0
        // Put explicitly provided properties onto the event object
        // Create a timestamp if incoming event doesn't have one
        // Mark it as fixed
        return this instanceof jQuery.Event ? (src && src.type ? (this.originalEvent = src, 
        this.type = src.type, this.isDefaultPrevented = src.defaultPrevented || void 0 === src.defaultPrevented && src.returnValue === !1 ? returnTrue : returnFalse) : this.type = src, 
        props && jQuery.extend(this, props), this.timeStamp = src && src.timeStamp || jQuery.now(), 
        void (this[jQuery.expando] = !0)) : new jQuery.Event(src, props);
    }, // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue, e && (// If preventDefault exists, run it on the original event
            e.preventDefault ? e.preventDefault() : e.returnValue = !1);
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue, e && (// If stopPropagation exists, run it on the original event
            e.stopPropagation && e.stopPropagation(), // Support: IE
            // Set the cancelBubble property of the original event to true
            e.cancelBubble = !0);
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue, e && e.stopImmediatePropagation && e.stopImmediatePropagation(), 
            this.stopPropagation();
        }
    }, // Create mouseenter/leave events using mouseover/out and event-time checks
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                // For mousenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                return (!related || related !== target && !jQuery.contains(target, related)) && (event.type = handleObj.origType, 
                ret = handleObj.handler.apply(this, arguments), event.type = fix), ret;
            }
        };
    }), // IE submit delegation
    support.submitBubbles || (jQuery.event.special.submit = {
        setup: function() {
            // Only need this for delegated form submit events
            // Only need this for delegated form submit events
            // Lazy-add a submit handler when a descendant form may potentially be submitted
            return jQuery.nodeName(this, "form") ? !1 : void jQuery.event.add(this, "click._submit keypress._submit", function(e) {
                // Node name check avoids a VML-related crash in IE (#9807)
                var elem = e.target, form = jQuery.nodeName(elem, "input") || jQuery.nodeName(elem, "button") ? elem.form : void 0;
                form && !jQuery._data(form, "submitBubbles") && (jQuery.event.add(form, "submit._submit", function(event) {
                    event._submit_bubble = !0;
                }), jQuery._data(form, "submitBubbles", !0));
            });
        },
        postDispatch: function(event) {
            // If form was submitted by the user, bubble the event up the tree
            event._submit_bubble && (delete event._submit_bubble, this.parentNode && !event.isTrigger && jQuery.event.simulate("submit", this.parentNode, event, !0));
        },
        teardown: function() {
            // Only need this for delegated form submit events
            // Only need this for delegated form submit events
            // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
            return jQuery.nodeName(this, "form") ? !1 : void jQuery.event.remove(this, "._submit");
        }
    }), // IE change delegation and checkbox/radio fix
    support.changeBubbles || (jQuery.event.special.change = {
        setup: function() {
            // IE doesn't fire change on a check/radio until blur; trigger it on click
            // after a propertychange. Eat the blur-change in special.change.handle.
            // This still fires onchange a second time for check/radio after blur.
            // Delegated event; lazy-add a change handler on descendant inputs
            return rformElems.test(this.nodeName) ? (("checkbox" === this.type || "radio" === this.type) && (jQuery.event.add(this, "propertychange._change", function(event) {
                "checked" === event.originalEvent.propertyName && (this._just_changed = !0);
            }), jQuery.event.add(this, "click._change", function(event) {
                this._just_changed && !event.isTrigger && (this._just_changed = !1), // Allow triggered, simulated change events (#11500)
                jQuery.event.simulate("change", this, event, !0);
            })), !1) : void jQuery.event.add(this, "beforeactivate._change", function(e) {
                var elem = e.target;
                rformElems.test(elem.nodeName) && !jQuery._data(elem, "changeBubbles") && (jQuery.event.add(elem, "change._change", function(event) {
                    !this.parentNode || event.isSimulated || event.isTrigger || jQuery.event.simulate("change", this.parentNode, event, !0);
                }), jQuery._data(elem, "changeBubbles", !0));
            });
        },
        handle: function(event) {
            var elem = event.target;
            // Swallow native change events from checkbox/radio, we already triggered them above
            // Swallow native change events from checkbox/radio, we already triggered them above
            return this !== elem || event.isSimulated || event.isTrigger || "radio" !== elem.type && "checkbox" !== elem.type ? event.handleObj.handler.apply(this, arguments) : void 0;
        },
        teardown: function() {
            return jQuery.event.remove(this, "._change"), !rformElems.test(this.nodeName);
        }
    }), // Create "bubbling" focus and blur events
    support.focusinBubbles || jQuery.each({
        focus: "focusin",
        blur: "focusout"
    }, function(orig, fix) {
        // Attach a single capturing handler on the document while someone wants focusin/focusout
        var handler = function(event) {
            jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), !0);
        };
        jQuery.event.special[fix] = {
            setup: function() {
                var doc = this.ownerDocument || this, attaches = jQuery._data(doc, fix);
                attaches || doc.addEventListener(orig, handler, !0), jQuery._data(doc, fix, (attaches || 0) + 1);
            },
            teardown: function() {
                var doc = this.ownerDocument || this, attaches = jQuery._data(doc, fix) - 1;
                attaches ? jQuery._data(doc, fix, attaches) : (doc.removeEventListener(orig, handler, !0), 
                jQuery._removeData(doc, fix));
            }
        };
    }), jQuery.fn.extend({
        on: function(types, selector, data, fn, /*INTERNAL*/ one) {
            var type, origFn;
            // Types can be a map of types/handlers
            if ("object" == typeof types) {
                // ( types-Object, selector, data )
                "string" != typeof selector && (data = data || selector, selector = void 0);
                for (type in types) this.on(type, selector, data, types[type], one);
                return this;
            }
            if (null == data && null == fn ? (fn = selector, data = selector = void 0) : null == fn && ("string" == typeof selector ? (fn = data, 
            data = void 0) : (fn = data, data = selector, selector = void 0)), fn === !1) fn = returnFalse; else if (!fn) return this;
            // Use same guid so caller can remove using origFn
            return 1 === one && (origFn = fn, fn = function(event) {
                return jQuery().off(event), origFn.apply(this, arguments);
            }, fn.guid = origFn.guid || (origFn.guid = jQuery.guid++)), this.each(function() {
                jQuery.event.add(this, types, fn, data, selector);
            });
        },
        one: function(types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) // ( event )  dispatched jQuery.Event
            return handleObj = types.handleObj, jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler), 
            this;
            if ("object" == typeof types) {
                // ( types-object [, selector] )
                for (type in types) this.off(type, selector, types[type]);
                return this;
            }
            // ( types [, fn] )
            return (selector === !1 || "function" == typeof selector) && (fn = selector, selector = void 0), 
            fn === !1 && (fn = returnFalse), this.each(function() {
                jQuery.event.remove(this, types, fn, selector);
            });
        },
        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function(type, data) {
            var elem = this[0];
            return elem ? jQuery.event.trigger(type, data, elem, !0) : void 0;
        }
    });
    var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video", rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g, rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"), rleadingWhitespace = /^\s+/, rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rtbody = /<tbody/i, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, // We have to close these tags to support XHTML (#13200)
    wrapMap = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        legend: [ 1, "<fieldset>", "</fieldset>" ],
        area: [ 1, "<map>", "</map>" ],
        param: [ 1, "<object>", "</object>" ],
        thead: [ 1, "<table>", "</table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
        // unless wrapped in a div with non-breaking characters in front of it.
        _default: support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>" ]
    }, safeFragment = createSafeFragment(document), fragmentDiv = safeFragment.appendChild(document.createElement("div"));
    wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, 
    wrapMap.th = wrapMap.td, jQuery.extend({
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var destElements, node, clone, i, srcElements, inPage = jQuery.contains(elem.ownerDocument, elem);
            if (support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test("<" + elem.nodeName + ">") ? clone = elem.cloneNode(!0) : (fragmentDiv.innerHTML = elem.outerHTML, 
            fragmentDiv.removeChild(clone = fragmentDiv.firstChild)), !(support.noCloneEvent && support.noCloneChecked || 1 !== elem.nodeType && 11 !== elem.nodeType || jQuery.isXMLDoc(elem))) // Fix all IE cloning issues
            for (destElements = getAll(clone), srcElements = getAll(elem), i = 0; null != (node = srcElements[i]); ++i) // Ensure that the destination node is not null; Fixes #9587
            destElements[i] && fixCloneNodeIssues(node, destElements[i]);
            // Copy the events from the original to the clone
            if (dataAndEvents) if (deepDataAndEvents) for (srcElements = srcElements || getAll(elem), 
            destElements = destElements || getAll(clone), i = 0; null != (node = srcElements[i]); i++) cloneCopyEvent(node, destElements[i]); else cloneCopyEvent(elem, clone);
            // Return the cloned set
            // Preserve script evaluation history
            return destElements = getAll(clone, "script"), destElements.length > 0 && setGlobalEval(destElements, !inPage && getAll(elem, "script")), 
            destElements = srcElements = node = null, clone;
        },
        buildFragment: function(elems, context, scripts, selection) {
            for (var j, elem, contains, tmp, tag, tbody, wrap, l = elems.length, // Ensure a safe fragment
            safe = createSafeFragment(context), nodes = [], i = 0; l > i; i++) if (elem = elems[i], 
            elem || 0 === elem) // Add nodes directly
            if ("object" === jQuery.type(elem)) jQuery.merge(nodes, elem.nodeType ? [ elem ] : elem); else if (rhtml.test(elem)) {
                for (tmp = tmp || safe.appendChild(context.createElement("div")), // Deserialize a standard representation
                tag = (rtagName.exec(elem) || [ "", "" ])[1].toLowerCase(), wrap = wrapMap[tag] || wrapMap._default, 
                tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2], // Descend through wrappers to the right content
                j = wrap[0]; j--; ) tmp = tmp.lastChild;
                // Remove IE's autoinserted <tbody> from table fragments
                if (// Manually add leading whitespace removed by IE
                !support.leadingWhitespace && rleadingWhitespace.test(elem) && nodes.push(context.createTextNode(rleadingWhitespace.exec(elem)[0])), 
                !support.tbody) for (// String was a <table>, *may* have spurious <tbody>
                elem = "table" !== tag || rtbody.test(elem) ? "<table>" !== wrap[1] || rtbody.test(elem) ? 0 : tmp : tmp.firstChild, 
                j = elem && elem.childNodes.length; j--; ) jQuery.nodeName(tbody = elem.childNodes[j], "tbody") && !tbody.childNodes.length && elem.removeChild(tbody);
                // Fix #12392 for oldIE
                for (jQuery.merge(nodes, tmp.childNodes), // Fix #12392 for WebKit and IE > 9
                tmp.textContent = ""; tmp.firstChild; ) tmp.removeChild(tmp.firstChild);
                // Remember the top-level container for proper cleanup
                tmp = safe.lastChild;
            } else nodes.push(context.createTextNode(elem));
            for (// Fix #11356: Clear elements from fragment
            tmp && safe.removeChild(tmp), // Reset defaultChecked for any radios and checkboxes
            // about to be appended to the DOM in IE 6/7 (#8060)
            support.appendChecked || jQuery.grep(getAll(nodes, "input"), fixDefaultChecked), 
            i = 0; elem = nodes[i++]; ) // #4087 - If origin and destination elements are the same, and this is
            // that element, do not do anything
            if ((!selection || -1 === jQuery.inArray(elem, selection)) && (contains = jQuery.contains(elem.ownerDocument, elem), 
            tmp = getAll(safe.appendChild(elem), "script"), contains && setGlobalEval(tmp), 
            scripts)) for (j = 0; elem = tmp[j++]; ) rscriptType.test(elem.type || "") && scripts.push(elem);
            return tmp = null, safe;
        },
        cleanData: function(elems, /* internal */ acceptData) {
            for (var elem, type, id, data, i = 0, internalKey = jQuery.expando, cache = jQuery.cache, deleteExpando = support.deleteExpando, special = jQuery.event.special; null != (elem = elems[i]); i++) if ((acceptData || jQuery.acceptData(elem)) && (id = elem[internalKey], 
            data = id && cache[id])) {
                if (data.events) for (type in data.events) special[type] ? jQuery.event.remove(elem, type) : jQuery.removeEvent(elem, type, data.handle);
                // Remove cache only if it was not already removed by jQuery.event.remove
                cache[id] && (delete cache[id], // IE does not allow us to delete expando properties from nodes,
                // nor does it have a removeAttribute function on Document nodes;
                // we must handle all of these cases
                deleteExpando ? delete elem[internalKey] : typeof elem.removeAttribute !== strundefined ? elem.removeAttribute(internalKey) : elem[internalKey] = null, 
                deletedIds.push(id));
            }
        }
    }), jQuery.fn.extend({
        text: function(value) {
            return access(this, function(value) {
                return void 0 === value ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
            }, null, value, arguments.length);
        },
        append: function() {
            return this.domManip(arguments, function(elem) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function() {
            return this.domManip(arguments, function(elem) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function() {
            return this.domManip(arguments, function(elem) {
                this.parentNode && this.parentNode.insertBefore(elem, this);
            });
        },
        after: function() {
            return this.domManip(arguments, function(elem) {
                this.parentNode && this.parentNode.insertBefore(elem, this.nextSibling);
            });
        },
        remove: function(selector, keepData) {
            for (var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0; null != (elem = elems[i]); i++) keepData || 1 !== elem.nodeType || jQuery.cleanData(getAll(elem)), 
            elem.parentNode && (keepData && jQuery.contains(elem.ownerDocument, elem) && setGlobalEval(getAll(elem, "script")), 
            elem.parentNode.removeChild(elem));
            return this;
        },
        empty: function() {
            for (var elem, i = 0; null != (elem = this[i]); i++) {
                // Remove any remaining nodes
                for (// Remove element nodes and prevent memory leaks
                1 === elem.nodeType && jQuery.cleanData(getAll(elem, !1)); elem.firstChild; ) elem.removeChild(elem.firstChild);
                // If this is a select, ensure that it displays empty (#12336)
                // Support: IE<9
                elem.options && jQuery.nodeName(elem, "select") && (elem.options.length = 0);
            }
            return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
            return dataAndEvents = null == dataAndEvents ? !1 : dataAndEvents, deepDataAndEvents = null == deepDataAndEvents ? dataAndEvents : deepDataAndEvents, 
            this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function(value) {
            return access(this, function(value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (void 0 === value) return 1 === elem.nodeType ? elem.innerHTML.replace(rinlinejQuery, "") : void 0;
                // See if we can take a shortcut and just use innerHTML
                if ("string" == typeof value && !rnoInnerhtml.test(value) && (support.htmlSerialize || !rnoshimcache.test(value)) && (support.leadingWhitespace || !rleadingWhitespace.test(value)) && !wrapMap[(rtagName.exec(value) || [ "", "" ])[1].toLowerCase()]) {
                    value = value.replace(rxhtmlTag, "<$1></$2>");
                    try {
                        for (;l > i; i++) elem = this[i] || {}, 1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)), 
                        elem.innerHTML = value);
                        elem = 0;
                    } catch (e) {}
                }
                elem && this.empty().append(value);
            }, null, value, arguments.length);
        },
        replaceWith: function() {
            var arg = arguments[0];
            // Force removal if there was no new content (e.g., from empty arguments)
            // Make the changes, replacing each context element with the new content
            return this.domManip(arguments, function(elem) {
                arg = this.parentNode, jQuery.cleanData(getAll(this)), arg && arg.replaceChild(elem, this);
            }), arg && (arg.length || arg.nodeType) ? this : this.remove();
        },
        detach: function(selector) {
            return this.remove(selector, !0);
        },
        domManip: function(args, callback) {
            // Flatten any nested arrays
            args = concat.apply([], args);
            var first, node, hasScripts, scripts, doc, fragment, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
            // We can't cloneNode fragments that contain checked, in WebKit
            if (isFunction || l > 1 && "string" == typeof value && !support.checkClone && rchecked.test(value)) return this.each(function(index) {
                var self = set.eq(index);
                isFunction && (args[0] = value.call(this, index, self.html())), self.domManip(args, callback);
            });
            if (l && (fragment = jQuery.buildFragment(args, this[0].ownerDocument, !1, this), 
            first = fragment.firstChild, 1 === fragment.childNodes.length && (fragment = first), 
            first)) {
                // Use the original fragment for the last item instead of the first because it can end up
                // being emptied incorrectly in certain situations (#8070).
                for (scripts = jQuery.map(getAll(fragment, "script"), disableScript), hasScripts = scripts.length; l > i; i++) node = fragment, 
                i !== iNoClone && (node = jQuery.clone(node, !0, !0), hasScripts && jQuery.merge(scripts, getAll(node, "script"))), 
                callback.call(this[i], node, i);
                if (hasScripts) // Evaluate executable scripts on first document insertion
                for (doc = scripts[scripts.length - 1].ownerDocument, jQuery.map(scripts, restoreScript), 
                i = 0; hasScripts > i; i++) node = scripts[i], rscriptType.test(node.type || "") && !jQuery._data(node, "globalEval") && jQuery.contains(doc, node) && (node.src ? jQuery._evalUrl && jQuery._evalUrl(node.src) : jQuery.globalEval((node.text || node.textContent || node.innerHTML || "").replace(rcleanScript, "")));
                // Fix #11809: Avoid leaking memory
                fragment = first = null;
            }
            return this;
        }
    }), jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            for (var elems, i = 0, ret = [], insert = jQuery(selector), last = insert.length - 1; last >= i; i++) elems = i === last ? this : this.clone(!0), 
            jQuery(insert[i])[original](elems), push.apply(ret, elems.get());
            return this.pushStack(ret);
        };
    });
    var iframe, elemdisplay = {};
    !function() {
        var shrinkWrapBlocksVal;
        support.shrinkWrapBlocks = function() {
            if (null != shrinkWrapBlocksVal) return shrinkWrapBlocksVal;
            // Will be changed later if needed.
            shrinkWrapBlocksVal = !1;
            // Minified: var b,c,d
            var div, body, container;
            // Setup
            // Support: IE6
            // Check if elements with layout shrink-wrap their children
            // Reset CSS: box-sizing; display; margin; border
            // Support: Firefox<29, Android 2.3
            // Vendor-prefix box-sizing
            return body = document.getElementsByTagName("body")[0], body && body.style ? (div = document.createElement("div"), 
            container = document.createElement("div"), container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", 
            body.appendChild(container).appendChild(div), typeof div.style.zoom !== strundefined && (div.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1", 
            div.appendChild(document.createElement("div")).style.width = "5px", shrinkWrapBlocksVal = 3 !== div.offsetWidth), 
            body.removeChild(container), shrinkWrapBlocksVal) : void 0;
        };
    }();
    var getStyles, curCSS, rmargin = /^margin/, rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i"), rposition = /^(top|right|bottom|left)$/;
    window.getComputedStyle ? (getStyles = function(elem) {
        // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        return elem.ownerDocument.defaultView.opener ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : window.getComputedStyle(elem, null);
    }, curCSS = function(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        return computed = computed || getStyles(elem), ret = computed ? computed.getPropertyValue(name) || computed[name] : void 0, 
        computed && ("" !== ret || jQuery.contains(elem.ownerDocument, elem) || (ret = jQuery.style(elem, name)), 
        rnumnonpx.test(ret) && rmargin.test(name) && (width = style.width, minWidth = style.minWidth, 
        maxWidth = style.maxWidth, style.minWidth = style.maxWidth = style.width = ret, 
        ret = computed.width, style.width = width, style.minWidth = minWidth, style.maxWidth = maxWidth)), 
        void 0 === ret ? ret : ret + "";
    }) : document.documentElement.currentStyle && (getStyles = function(elem) {
        return elem.currentStyle;
    }, curCSS = function(elem, name, computed) {
        var left, rs, rsLeft, ret, style = elem.style;
        return computed = computed || getStyles(elem), ret = computed ? computed[name] : void 0, 
        null == ret && style && style[name] && (ret = style[name]), rnumnonpx.test(ret) && !rposition.test(name) && (left = style.left, 
        rs = elem.runtimeStyle, rsLeft = rs && rs.left, rsLeft && (rs.left = elem.currentStyle.left), 
        style.left = "fontSize" === name ? "1em" : ret, ret = style.pixelLeft + "px", style.left = left, 
        rsLeft && (rs.left = rsLeft)), void 0 === ret ? ret : ret + "" || "auto";
    }), function() {
        function computeStyleTests() {
            // Minified: var b,c,d,j
            var div, body, container, contents;
            body = document.getElementsByTagName("body")[0], body && body.style && (div = document.createElement("div"), 
            container = document.createElement("div"), container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", 
            body.appendChild(container).appendChild(div), div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute", 
            pixelPositionVal = boxSizingReliableVal = !1, reliableMarginRightVal = !0, window.getComputedStyle && (pixelPositionVal = "1%" !== (window.getComputedStyle(div, null) || {}).top, 
            boxSizingReliableVal = "4px" === (window.getComputedStyle(div, null) || {
                width: "4px"
            }).width, contents = div.appendChild(document.createElement("div")), contents.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", 
            contents.style.marginRight = contents.style.width = "0", div.style.width = "1px", 
            reliableMarginRightVal = !parseFloat((window.getComputedStyle(contents, null) || {}).marginRight), 
            div.removeChild(contents)), div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>", 
            contents = div.getElementsByTagName("td"), contents[0].style.cssText = "margin:0;border:0;padding:0;display:none", 
            reliableHiddenOffsetsVal = 0 === contents[0].offsetHeight, reliableHiddenOffsetsVal && (contents[0].style.display = "", 
            contents[1].style.display = "none", reliableHiddenOffsetsVal = 0 === contents[0].offsetHeight), 
            body.removeChild(container));
        }
        // Minified: var b,c,d,e,f,g, h,i
        var div, style, a, pixelPositionVal, boxSizingReliableVal, reliableHiddenOffsetsVal, reliableMarginRightVal;
        div = document.createElement("div"), div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
        a = div.getElementsByTagName("a")[0], style = a && a.style, style && (style.cssText = "float:left;opacity:.5", 
        support.opacity = "0.5" === style.opacity, support.cssFloat = !!style.cssFloat, 
        div.style.backgroundClip = "content-box", div.cloneNode(!0).style.backgroundClip = "", 
        support.clearCloneStyle = "content-box" === div.style.backgroundClip, support.boxSizing = "" === style.boxSizing || "" === style.MozBoxSizing || "" === style.WebkitBoxSizing, 
        jQuery.extend(support, {
            reliableHiddenOffsets: function() {
                return null == reliableHiddenOffsetsVal && computeStyleTests(), reliableHiddenOffsetsVal;
            },
            boxSizingReliable: function() {
                return null == boxSizingReliableVal && computeStyleTests(), boxSizingReliableVal;
            },
            pixelPosition: function() {
                return null == pixelPositionVal && computeStyleTests(), pixelPositionVal;
            },
            reliableMarginRight: function() {
                return null == reliableMarginRightVal && computeStyleTests(), reliableMarginRightVal;
            }
        }));
    }(), // A method for quickly swapping in/out CSS properties to get correct calculations.
    jQuery.swap = function(elem, options, callback, args) {
        var ret, name, old = {};
        // Remember the old values, and insert the new ones
        for (name in options) old[name] = elem.style[name], elem.style[name] = options[name];
        ret = callback.apply(elem, args || []);
        // Revert the old values
        for (name in options) elem.style[name] = old[name];
        return ret;
    };
    var ralpha = /alpha\([^)]*\)/i, ropacity = /opacity\s*=\s*([^)]*)/, // swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
    // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/, rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"), rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"), cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
    }, cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];
    jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {
                        // We should always get a number back from opacity
                        var ret = curCSS(elem, "opacity");
                        return "" === ret ? "1" : ret;
                    }
                }
            }
        },
        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
            columnCount: !0,
            fillOpacity: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
            // normalize float css property
            "float": support.cssFloat ? "cssFloat" : "styleFloat"
        },
        // Get and set the style property on a DOM Node
        style: function(elem, name, value, extra) {
            // Don't set styles on text and comment nodes
            if (elem && 3 !== elem.nodeType && 8 !== elem.nodeType && elem.style) {
                // Make sure that we're working with the right name
                var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
                // Check if we're setting a value
                if (name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName)), 
                hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName], void 0 === value) // If a hook was provided get the non-computed value from there
                // If a hook was provided get the non-computed value from there
                return hooks && "get" in hooks && void 0 !== (ret = hooks.get(elem, !1, extra)) ? ret : style[name];
                // Make sure that null and NaN values aren't set. See: #7116
                if (type = typeof value, "string" === type && (ret = rrelNum.exec(value)) && (value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name)), 
                type = "number"), null != value && value === value && ("number" !== type || jQuery.cssNumber[origName] || (value += "px"), 
                support.clearCloneStyle || "" !== value || 0 !== name.indexOf("background") || (style[name] = "inherit"), 
                !(hooks && "set" in hooks && void 0 === (value = hooks.set(elem, value, extra))))) // Support: IE
                // Swallow errors from 'invalid' CSS values (#5509)
                try {
                    style[name] = value;
                } catch (e) {}
            }
        },
        css: function(elem, name, extra, styles) {
            var num, val, hooks, origName = jQuery.camelCase(name);
            return name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName)), 
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName], hooks && "get" in hooks && (val = hooks.get(elem, !0, extra)), 
            void 0 === val && (val = curCSS(elem, name, styles)), "normal" === val && name in cssNormalTransform && (val = cssNormalTransform[name]), 
            "" === extra || extra ? (num = parseFloat(val), extra === !0 || jQuery.isNumeric(num) ? num || 0 : val) : val;
        }
    }), jQuery.each([ "height", "width" ], function(i, name) {
        jQuery.cssHooks[name] = {
            get: function(elem, computed, extra) {
                return computed ? rdisplayswap.test(jQuery.css(elem, "display")) && 0 === elem.offsetWidth ? jQuery.swap(elem, cssShow, function() {
                    return getWidthOrHeight(elem, name, extra);
                }) : getWidthOrHeight(elem, name, extra) : void 0;
            },
            set: function(elem, value, extra) {
                var styles = extra && getStyles(elem);
                return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, support.boxSizing && "border-box" === jQuery.css(elem, "boxSizing", !1, styles), styles) : 0);
            }
        };
    }), support.opacity || (jQuery.cssHooks.opacity = {
        get: function(elem, computed) {
            // IE uses filters for opacity
            return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : computed ? "1" : "";
        },
        set: function(elem, value) {
            var style = elem.style, currentStyle = elem.currentStyle, opacity = jQuery.isNumeric(value) ? "alpha(opacity=" + 100 * value + ")" : "", filter = currentStyle && currentStyle.filter || style.filter || "";
            // IE has trouble with opacity if it does not have layout
            // Force it by setting the zoom level
            style.zoom = 1, // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
            // if value === "", then remove inline opacity #12685
            (value >= 1 || "" === value) && "" === jQuery.trim(filter.replace(ralpha, "")) && style.removeAttribute && (style.removeAttribute("filter"), 
            "" === value || currentStyle && !currentStyle.filter) || (// otherwise, set new filter values
            style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : filter + " " + opacity);
        }
    }), jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
        return computed ? jQuery.swap(elem, {
            display: "inline-block"
        }, curCSS, [ elem, "marginRight" ]) : void 0;
    }), // These hooks are used by animate to expand properties
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                for (var i = 0, expanded = {}, // assumes a single number if not a string
                parts = "string" == typeof value ? value.split(" ") : [ value ]; 4 > i; i++) expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                return expanded;
            }
        }, rmargin.test(prefix) || (jQuery.cssHooks[prefix + suffix].set = setPositiveNumber);
    }), jQuery.fn.extend({
        css: function(name, value) {
            return access(this, function(elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (jQuery.isArray(name)) {
                    for (styles = getStyles(elem), len = name.length; len > i; i++) map[name[i]] = jQuery.css(elem, name[i], !1, styles);
                    return map;
                }
                return void 0 !== value ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        },
        show: function() {
            return showHide(this, !0);
        },
        hide: function() {
            return showHide(this);
        },
        toggle: function(state) {
            return "boolean" == typeof state ? state ? this.show() : this.hide() : this.each(function() {
                isHidden(this) ? jQuery(this).show() : jQuery(this).hide();
            });
        }
    }), jQuery.Tween = Tween, Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem, this.prop = prop, this.easing = easing || "swing", this.options = options, 
            this.start = this.now = this.cur(), this.end = end, this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            return this.options.duration ? this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration) : this.pos = eased = percent, 
            this.now = (this.end - this.start) * eased + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), 
            hooks && hooks.set ? hooks.set(this) : Tween.propHooks._default.set(this), this;
        }
    }, Tween.prototype.init.prototype = Tween.prototype, Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;
                // passing an empty string as a 3rd parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails
                // so, simple values such as "10px" are parsed to Float.
                // complex values such as "rotate(1rad)" are returned as is.
                return null == tween.elem[tween.prop] || tween.elem.style && null != tween.elem.style[tween.prop] ? (result = jQuery.css(tween.elem, tween.prop, ""), 
                result && "auto" !== result ? result : 0) : tween.elem[tween.prop];
            },
            set: function(tween) {
                // use step hook for back compat - use cssHook if its there - use .style if its
                // available and use plain properties where available
                jQuery.fx.step[tween.prop] ? jQuery.fx.step[tween.prop](tween) : tween.elem.style && (null != tween.elem.style[jQuery.cssProps[tween.prop]] || jQuery.cssHooks[tween.prop]) ? jQuery.style(tween.elem, tween.prop, tween.now + tween.unit) : tween.elem[tween.prop] = tween.now;
            }
        }
    }, // Support: IE <=9
    // Panic based approach to setting things on disconnected nodes
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            tween.elem.nodeType && tween.elem.parentNode && (tween.elem[tween.prop] = tween.now);
        }
    }, jQuery.easing = {
        linear: function(p) {
            return p;
        },
        swing: function(p) {
            return .5 - Math.cos(p * Math.PI) / 2;
        }
    }, jQuery.fx = Tween.prototype.init, // Back Compat <1.8 extension point
    jQuery.fx.step = {};
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"), rrun = /queueHooks$/, animationPrefilters = [ defaultPrefilter ], tweeners = {
        "*": [ function(prop, value) {
            var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"), // Starting value computation is required for potential unit mismatches
            start = (jQuery.cssNumber[prop] || "px" !== unit && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
            if (start && start[3] !== unit) {
                // Trust units reported by jQuery.css
                unit = unit || start[3], // Make sure we update the tween properties later on
                parts = parts || [], // Iteratively approximate from a nonzero starting point
                start = +target || 1;
                do scale = scale || ".5", start /= scale, jQuery.style(tween.elem, prop, start + unit); while (scale !== (scale = tween.cur() / target) && 1 !== scale && --maxIterations);
            }
            // Update tween properties
            // If a +=/-= token was provided, we're doing a relative animation
            return parts && (start = tween.start = +start || +target || 0, tween.unit = unit, 
            tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2]), tween;
        } ]
    };
    jQuery.Animation = jQuery.extend(Animation, {
        tweener: function(props, callback) {
            jQuery.isFunction(props) ? (callback = props, props = [ "*" ]) : props = props.split(" ");
            for (var prop, index = 0, length = props.length; length > index; index++) prop = props[index], 
            tweeners[prop] = tweeners[prop] || [], tweeners[prop].unshift(callback);
        },
        prefilter: function(callback, prepend) {
            prepend ? animationPrefilters.unshift(callback) : animationPrefilters.push(callback);
        }
    }), jQuery.speed = function(speed, easing, fn) {
        var opt = speed && "object" == typeof speed ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        // normalize opt.queue - true/undefined/null -> "fx"
        // Queueing
        return opt.duration = jQuery.fx.off ? 0 : "number" == typeof opt.duration ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default, 
        (null == opt.queue || opt.queue === !0) && (opt.queue = "fx"), opt.old = opt.complete, 
        opt.complete = function() {
            jQuery.isFunction(opt.old) && opt.old.call(this), opt.queue && jQuery.dequeue(this, opt.queue);
        }, opt;
    }, jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
            // show any hidden elements after setting opacity to 0
            return this.filter(isHidden).css("opacity", 0).show().end().animate({
                opacity: to
            }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
                // Operate on a copy of prop so per-property easing won't be lost
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                // Empty animations, or finishing resolves immediately
                (empty || jQuery._data(this, "finish")) && anim.stop(!0);
            };
            return doAnimation.finish = doAnimation, empty || optall.queue === !1 ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop, stop(gotoEnd);
            };
            return "string" != typeof type && (gotoEnd = clearQueue, clearQueue = type, type = void 0), 
            clearQueue && type !== !1 && this.queue(type || "fx", []), this.each(function() {
                var dequeue = !0, index = null != type && type + "queueHooks", timers = jQuery.timers, data = jQuery._data(this);
                if (index) data[index] && data[index].stop && stopQueue(data[index]); else for (index in data) data[index] && data[index].stop && rrun.test(index) && stopQueue(data[index]);
                for (index = timers.length; index--; ) timers[index].elem !== this || null != type && timers[index].queue !== type || (timers[index].anim.stop(gotoEnd), 
                dequeue = !1, timers.splice(index, 1));
                // start the next in the queue if the last step wasn't forced
                // timers currently will call their complete callbacks, which will dequeue
                // but only if they were gotoEnd
                (dequeue || !gotoEnd) && jQuery.dequeue(this, type);
            });
        },
        finish: function(type) {
            return type !== !1 && (type = type || "fx"), this.each(function() {
                var index, data = jQuery._data(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                // look for any active animations, and finish them
                for (// enable finishing flag on private data
                data.finish = !0, // empty the queue first
                jQuery.queue(this, type, []), hooks && hooks.stop && hooks.stop.call(this, !0), 
                index = timers.length; index--; ) timers[index].elem === this && timers[index].queue === type && (timers[index].anim.stop(!0), 
                timers.splice(index, 1));
                // look for any animations in the old queue and finish them
                for (index = 0; length > index; index++) queue[index] && queue[index].finish && queue[index].finish.call(this);
                // turn off finishing flag
                delete data.finish;
            });
        }
    }), jQuery.each([ "toggle", "show", "hide" ], function(i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return null == speed || "boolean" == typeof speed ? cssFn.apply(this, arguments) : this.animate(genFx(name, !0), speed, easing, callback);
        };
    }), // Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    }), jQuery.timers = [], jQuery.fx.tick = function() {
        var timer, timers = jQuery.timers, i = 0;
        for (fxNow = jQuery.now(); i < timers.length; i++) timer = timers[i], timer() || timers[i] !== timer || timers.splice(i--, 1);
        timers.length || jQuery.fx.stop(), fxNow = void 0;
    }, jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer), timer() ? jQuery.fx.start() : jQuery.timers.pop();
    }, jQuery.fx.interval = 13, jQuery.fx.start = function() {
        timerId || (timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval));
    }, jQuery.fx.stop = function() {
        clearInterval(timerId), timerId = null;
    }, jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400
    }, // Based off of the plugin by Clint Helfers, with permission.
    // http://blindsignals.com/index.php/2009/07/jquery-delay/
    jQuery.fn.delay = function(time, type) {
        return time = jQuery.fx ? jQuery.fx.speeds[time] || time : time, type = type || "fx", 
        this.queue(type, function(next, hooks) {
            var timeout = setTimeout(next, time);
            hooks.stop = function() {
                clearTimeout(timeout);
            };
        });
    }, function() {
        // Minified: var a,b,c,d,e
        var input, div, select, a, opt;
        div = document.createElement("div"), div.setAttribute("className", "t"), div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
        a = div.getElementsByTagName("a")[0], select = document.createElement("select"), 
        opt = select.appendChild(document.createElement("option")), input = div.getElementsByTagName("input")[0], 
        a.style.cssText = "top:1px", support.getSetAttribute = "t" !== div.className, support.style = /top/.test(a.getAttribute("style")), 
        support.hrefNormalized = "/a" === a.getAttribute("href"), support.checkOn = !!input.value, 
        support.optSelected = opt.selected, support.enctype = !!document.createElement("form").enctype, 
        select.disabled = !0, support.optDisabled = !opt.disabled, input = document.createElement("input"), 
        input.setAttribute("value", ""), support.input = "" === input.getAttribute("value"), 
        input.value = "t", input.setAttribute("type", "radio"), support.radioValue = "t" === input.value;
    }();
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function(value) {
            var hooks, ret, isFunction, elem = this[0];
            {
                if (arguments.length) return isFunction = jQuery.isFunction(value), this.each(function(i) {
                    var val;
                    1 === this.nodeType && (val = isFunction ? value.call(this, i, jQuery(this).val()) : value, 
                    null == val ? val = "" : "number" == typeof val ? val += "" : jQuery.isArray(val) && (val = jQuery.map(val, function(value) {
                        return null == value ? "" : value + "";
                    })), hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()], 
                    hooks && "set" in hooks && void 0 !== hooks.set(this, val, "value") || (this.value = val));
                });
                if (elem) // handle most common string cases
                // handle cases where value is null/undef or number
                return hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()], 
                hooks && "get" in hooks && void 0 !== (ret = hooks.get(elem, "value")) ? ret : (ret = elem.value, 
                "string" == typeof ret ? ret.replace(rreturn, "") : null == ret ? "" : ret);
            }
        }
    }), jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {
                    var val = jQuery.find.attr(elem, "value");
                    // Support: IE10-11+
                    // option.text throws exceptions (#14686, #14858)
                    return null != val ? val : jQuery.trim(jQuery.text(elem));
                }
            },
            select: {
                get: function(elem) {
                    // Loop through all the selected options
                    for (var value, option, options = elem.options, index = elem.selectedIndex, one = "select-one" === elem.type || 0 > index, values = one ? null : [], max = one ? index + 1 : options.length, i = 0 > index ? max : one ? index : 0; max > i; i++) // oldIE doesn't update selected after form reset (#2551)
                    if (option = options[i], (option.selected || i === index) && (support.optDisabled ? !option.disabled : null === option.getAttribute("disabled")) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                        // We don't need an array for one selects
                        if (value = jQuery(option).val(), one) return value;
                        // Multi-Selects return an array
                        values.push(value);
                    }
                    return values;
                },
                set: function(elem, value) {
                    for (var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length; i--; ) if (option = options[i], 
                    jQuery.inArray(jQuery.valHooks.option.get(option), values) >= 0) // Support: IE6
                    // When new option element is added to select box we need to
                    // force reflow of newly added node in order to workaround delay
                    // of initialization properties
                    try {
                        option.selected = optionSet = !0;
                    } catch (_) {
                        // Will be executed only in IE6
                        option.scrollHeight;
                    } else option.selected = !1;
                    // Force browsers to behave consistently when non-matching value is set
                    return optionSet || (elem.selectedIndex = -1), options;
                }
            }
        }
    }), // Radios and checkboxes getter/setter
    jQuery.each([ "radio", "checkbox" ], function() {
        jQuery.valHooks[this] = {
            set: function(elem, value) {
                return jQuery.isArray(value) ? elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0 : void 0;
            }
        }, support.checkOn || (jQuery.valHooks[this].get = function(elem) {
            // Support: Webkit
            // "" is returned instead of "on" if a value isn't specified
            return null === elem.getAttribute("value") ? "on" : elem.value;
        });
    });
    var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle, ruseDefault = /^(?:checked|selected)$/i, getSetAttribute = support.getSetAttribute, getSetInput = support.input;
    jQuery.fn.extend({
        attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name);
            });
        }
    }), jQuery.extend({
        attr: function(elem, name, value) {
            var hooks, ret, nType = elem.nodeType;
            // don't get/set attributes on text, comment and attribute nodes
            if (elem && 3 !== nType && 8 !== nType && 2 !== nType) // Fallback to prop when attributes are not supported
            // Fallback to prop when attributes are not supported
            // All attributes are lowercase
            // Grab necessary hook if one is defined
            return typeof elem.getAttribute === strundefined ? jQuery.prop(elem, name, value) : (1 === nType && jQuery.isXMLDoc(elem) || (name = name.toLowerCase(), 
            hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook)), 
            void 0 === value ? hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : (ret = jQuery.find.attr(elem, name), 
            null == ret ? void 0 : ret) : null !== value ? hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : (elem.setAttribute(name, value + ""), 
            value) : void jQuery.removeAttr(elem, name));
        },
        removeAttr: function(elem, value) {
            var name, propName, i = 0, attrNames = value && value.match(rnotwhite);
            if (attrNames && 1 === elem.nodeType) for (;name = attrNames[i++]; ) propName = jQuery.propFix[name] || name, 
            jQuery.expr.match.bool.test(name) ? getSetInput && getSetAttribute || !ruseDefault.test(name) ? elem[propName] = !1 : elem[jQuery.camelCase("default-" + name)] = elem[propName] = !1 : jQuery.attr(elem, name, ""), 
            elem.removeAttribute(getSetAttribute ? name : propName);
        },
        attrHooks: {
            type: {
                set: function(elem, value) {
                    if (!support.radioValue && "radio" === value && jQuery.nodeName(elem, "input")) {
                        // Setting the type on a radio button after the value resets the value in IE6-9
                        // Reset value to default in case type is set after value during creation
                        var val = elem.value;
                        return elem.setAttribute("type", value), val && (elem.value = val), value;
                    }
                }
            }
        }
    }), boolHook = {
        set: function(elem, value, name) {
            // Remove boolean attributes when set to false
            // IE<8 needs the *property* name
            return value === !1 ? jQuery.removeAttr(elem, name) : getSetInput && getSetAttribute || !ruseDefault.test(name) ? elem.setAttribute(!getSetAttribute && jQuery.propFix[name] || name, name) : elem[jQuery.camelCase("default-" + name)] = elem[name] = !0, 
            name;
        }
    }, jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = getSetInput && getSetAttribute || !ruseDefault.test(name) ? function(elem, name, isXML) {
            var ret, handle;
            return isXML || (handle = attrHandle[name], attrHandle[name] = ret, ret = null != getter(elem, name, isXML) ? name.toLowerCase() : null, 
            attrHandle[name] = handle), ret;
        } : function(elem, name, isXML) {
            return isXML ? void 0 : elem[jQuery.camelCase("default-" + name)] ? name.toLowerCase() : null;
        };
    }), getSetInput && getSetAttribute || (jQuery.attrHooks.value = {
        set: function(elem, value, name) {
            return jQuery.nodeName(elem, "input") ? void (elem.defaultValue = value) : nodeHook && nodeHook.set(elem, value, name);
        }
    }), getSetAttribute || (nodeHook = {
        set: function(elem, value, name) {
            var ret = elem.getAttributeNode(name);
            return ret || elem.setAttributeNode(ret = elem.ownerDocument.createAttribute(name)), 
            ret.value = value += "", "value" === name || value === elem.getAttribute(name) ? value : void 0;
        }
    }, attrHandle.id = attrHandle.name = attrHandle.coords = function(elem, name, isXML) {
        var ret;
        return isXML ? void 0 : (ret = elem.getAttributeNode(name)) && "" !== ret.value ? ret.value : null;
    }, jQuery.valHooks.button = {
        get: function(elem, name) {
            var ret = elem.getAttributeNode(name);
            return ret && ret.specified ? ret.value : void 0;
        },
        set: nodeHook.set
    }, jQuery.attrHooks.contenteditable = {
        set: function(elem, value, name) {
            nodeHook.set(elem, "" === value ? !1 : value, name);
        }
    }, jQuery.each([ "width", "height" ], function(i, name) {
        jQuery.attrHooks[name] = {
            set: function(elem, value) {
                return "" === value ? (elem.setAttribute(name, "auto"), value) : void 0;
            }
        };
    })), support.style || (jQuery.attrHooks.style = {
        get: function(elem) {
            return elem.style.cssText || void 0;
        },
        set: function(elem, value) {
            return elem.style.cssText = value + "";
        }
    });
    var rfocusable = /^(?:input|select|textarea|button|object)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
        prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
            return name = jQuery.propFix[name] || name, this.each(function() {
                try {
                    this[name] = void 0, delete this[name];
                } catch (e) {}
            });
        }
    }), jQuery.extend({
        propFix: {
            "for": "htmlFor",
            "class": "className"
        },
        prop: function(elem, name, value) {
            var ret, hooks, notxml, nType = elem.nodeType;
            // don't get/set properties on text, comment and attribute nodes
            if (elem && 3 !== nType && 8 !== nType && 2 !== nType) return notxml = 1 !== nType || !jQuery.isXMLDoc(elem), 
            notxml && (name = jQuery.propFix[name] || name, hooks = jQuery.propHooks[name]), 
            void 0 !== value ? hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : elem[name] = value : hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : elem[name];
        },
        propHooks: {
            tabIndex: {
                get: function(elem) {
                    // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                    // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    // Use proper attribute retrieval(#12072)
                    var tabindex = jQuery.find.attr(elem, "tabindex");
                    return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
                }
            }
        }
    }), // Some attributes require a special call on IE
    // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
    support.hrefNormalized || // href/src property should get the full normalized URL (#10299/#12915)
    jQuery.each([ "href", "src" ], function(i, name) {
        jQuery.propHooks[name] = {
            get: function(elem) {
                return elem.getAttribute(name, 4);
            }
        };
    }), // Support: Safari, IE9+
    // mis-reports the default selected property of an option
    // Accessing the parent's selectedIndex property fixes it
    support.optSelected || (jQuery.propHooks.selected = {
        get: function(elem) {
            var parent = elem.parentNode;
            // Make sure that it also works with optgroups, see #5701
            return parent && (parent.selectedIndex, parent.parentNode && parent.parentNode.selectedIndex), 
            null;
        }
    }), jQuery.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
        jQuery.propFix[this.toLowerCase()] = this;
    }), // IE6/7 call enctype encoding
    support.enctype || (jQuery.propFix.enctype = "encoding");
    var rclass = /[\t\r\n\f]/g;
    jQuery.fn.extend({
        addClass: function(value) {
            var classes, elem, cur, clazz, j, finalValue, i = 0, len = this.length, proceed = "string" == typeof value && value;
            if (jQuery.isFunction(value)) return this.each(function(j) {
                jQuery(this).addClass(value.call(this, j, this.className));
            });
            if (proceed) for (// The disjunction here is for better compressibility (see removeClass)
            classes = (value || "").match(rnotwhite) || []; len > i; i++) if (elem = this[i], 
            cur = 1 === elem.nodeType && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ")) {
                for (j = 0; clazz = classes[j++]; ) cur.indexOf(" " + clazz + " ") < 0 && (cur += clazz + " ");
                // only assign if different to avoid unneeded rendering.
                finalValue = jQuery.trim(cur), elem.className !== finalValue && (elem.className = finalValue);
            }
            return this;
        },
        removeClass: function(value) {
            var classes, elem, cur, clazz, j, finalValue, i = 0, len = this.length, proceed = 0 === arguments.length || "string" == typeof value && value;
            if (jQuery.isFunction(value)) return this.each(function(j) {
                jQuery(this).removeClass(value.call(this, j, this.className));
            });
            if (proceed) for (classes = (value || "").match(rnotwhite) || []; len > i; i++) if (elem = this[i], 
            cur = 1 === elem.nodeType && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "")) {
                for (j = 0; clazz = classes[j++]; ) // Remove *all* instances
                for (;cur.indexOf(" " + clazz + " ") >= 0; ) cur = cur.replace(" " + clazz + " ", " ");
                // only assign if different to avoid unneeded rendering.
                finalValue = value ? jQuery.trim(cur) : "", elem.className !== finalValue && (elem.className = finalValue);
            }
            return this;
        },
        toggleClass: function(value, stateVal) {
            var type = typeof value;
            return "boolean" == typeof stateVal && "string" === type ? stateVal ? this.addClass(value) : this.removeClass(value) : jQuery.isFunction(value) ? this.each(function(i) {
                jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
            }) : this.each(function() {
                if ("string" === type) for (var className, i = 0, self = jQuery(this), classNames = value.match(rnotwhite) || []; className = classNames[i++]; ) self.hasClass(className) ? self.removeClass(className) : self.addClass(className); else (type === strundefined || "boolean" === type) && (this.className && jQuery._data(this, "__className__", this.className), 
                this.className = this.className || value === !1 ? "" : jQuery._data(this, "__className__") || "");
            });
        },
        hasClass: function(selector) {
            for (var className = " " + selector + " ", i = 0, l = this.length; l > i; i++) if (1 === this[i].nodeType && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) return !0;
            return !1;
        }
    }), // Return jQuery for attributes-only inclusion
    jQuery.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(i, name) {
        // Handle event binding
        jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    }), jQuery.fn.extend({
        hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        },
        bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
            // ( namespace ) or ( selector, types [, fn] )
            return 1 === arguments.length ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        }
    });
    var nonce = jQuery.now(), rquery = /\?/, rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
    jQuery.parseJSON = function(data) {
        // Attempt to parse using the native JSON parser first
        if (window.JSON && window.JSON.parse) // Support: Android 2.3
        // Workaround failure to string-cast null input
        return window.JSON.parse(data + "");
        var requireNonComma, depth = null, str = jQuery.trim(data + "");
        // Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
        // after removing valid tokens
        return str && !jQuery.trim(str.replace(rvalidtokens, function(token, comma, open, close) {
            return requireNonComma && comma && (depth = 0), 0 === depth ? token : (requireNonComma = open || comma, 
            depth += !close - !open, "");
        })) ? Function("return " + str)() : jQuery.error("Invalid JSON: " + data);
    }, // Cross-browser xml parsing
    jQuery.parseXML = function(data) {
        var xml, tmp;
        if (!data || "string" != typeof data) return null;
        try {
            window.DOMParser ? (tmp = new DOMParser(), xml = tmp.parseFromString(data, "text/xml")) : (xml = new ActiveXObject("Microsoft.XMLDOM"), 
            xml.async = "false", xml.loadXML(data));
        } catch (e) {
            xml = void 0;
        }
        return xml && xml.documentElement && !xml.getElementsByTagName("parsererror").length || jQuery.error("Invalid XML: " + data), 
        xml;
    };
    var // Document location
    ajaxLocParts, ajaxLocation, rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm, // IE leaves an \r character at EOL
    // #7653, #8125, #8152: local protocol detection
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
    prefilters = {}, /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
    transports = {}, // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    allTypes = "*/".concat("*");
    // #8138, IE may throw an exception when accessing
    // a field from window.location if document.domain has been set
    try {
        ajaxLocation = location.href;
    } catch (e) {
        // Use the href attribute of an A element
        // since IE will modify it given document.location
        ajaxLocation = document.createElement("a"), ajaxLocation.href = "", ajaxLocation = ajaxLocation.href;
    }
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [], jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: ajaxLocation,
            type: "GET",
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": jQuery.parseJSON,
                "text xml": jQuery.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function(target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function(url, options) {
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                2 !== state && (state = 2, timeoutTimer && clearTimeout(timeoutTimer), transport = void 0, 
                responseHeadersString = headers || "", jqXHR.readyState = status > 0 ? 4 : 0, isSuccess = status >= 200 && 300 > status || 304 === status, 
                responses && (response = ajaxHandleResponses(s, jqXHR, responses)), response = ajaxConvert(s, response, jqXHR, isSuccess), 
                isSuccess ? (s.ifModified && (modified = jqXHR.getResponseHeader("Last-Modified"), 
                modified && (jQuery.lastModified[cacheURL] = modified), modified = jqXHR.getResponseHeader("etag"), 
                modified && (jQuery.etag[cacheURL] = modified)), 204 === status || "HEAD" === s.type ? statusText = "nocontent" : 304 === status ? statusText = "notmodified" : (statusText = response.state, 
                success = response.data, error = response.error, isSuccess = !error)) : (error = statusText, 
                (status || !statusText) && (statusText = "error", 0 > status && (status = 0))), 
                jqXHR.status = status, jqXHR.statusText = (nativeStatusText || statusText) + "", 
                isSuccess ? deferred.resolveWith(callbackContext, [ success, statusText, jqXHR ]) : deferred.rejectWith(callbackContext, [ jqXHR, statusText, error ]), 
                jqXHR.statusCode(statusCode), statusCode = void 0, fireGlobals && globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [ jqXHR, s, isSuccess ? success : error ]), 
                completeDeferred.fireWith(callbackContext, [ jqXHR, statusText ]), fireGlobals && (globalEventContext.trigger("ajaxComplete", [ jqXHR, s ]), 
                --jQuery.active || jQuery.event.trigger("ajaxStop")));
            }
            "object" == typeof url && (options = url, url = void 0), options = options || {};
            var parts, i, cacheURL, responseHeadersString, timeoutTimer, fireGlobals, transport, responseHeaders, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = "canceled", jqXHR = {
                readyState: 0,
                getResponseHeader: function(key) {
                    var match;
                    if (2 === state) {
                        if (!responseHeaders) for (responseHeaders = {}; match = rheaders.exec(responseHeadersString); ) responseHeaders[match[1].toLowerCase()] = match[2];
                        match = responseHeaders[key.toLowerCase()];
                    }
                    return null == match ? null : match;
                },
                getAllResponseHeaders: function() {
                    return 2 === state ? responseHeadersString : null;
                },
                setRequestHeader: function(name, value) {
                    var lname = name.toLowerCase();
                    return state || (name = requestHeadersNames[lname] = requestHeadersNames[lname] || name, 
                    requestHeaders[name] = value), this;
                },
                overrideMimeType: function(type) {
                    return state || (s.mimeType = type), this;
                },
                statusCode: function(map) {
                    var code;
                    if (map) if (2 > state) for (code in map) statusCode[code] = [ statusCode[code], map[code] ]; else jqXHR.always(map[jqXHR.status]);
                    return this;
                },
                abort: function(statusText) {
                    var finalText = statusText || strAbort;
                    return transport && transport.abort(finalText), done(0, finalText), this;
                }
            };
            if (deferred.promise(jqXHR).complete = completeDeferred.add, jqXHR.success = jqXHR.done, 
            jqXHR.error = jqXHR.fail, s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//"), 
            s.type = options.method || options.type || s.method || s.type, s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [ "" ], 
            null == s.crossDomain && (parts = rurl.exec(s.url.toLowerCase()), s.crossDomain = !(!parts || parts[1] === ajaxLocParts[1] && parts[2] === ajaxLocParts[2] && (parts[3] || ("http:" === parts[1] ? "80" : "443")) === (ajaxLocParts[3] || ("http:" === ajaxLocParts[1] ? "80" : "443")))), 
            s.data && s.processData && "string" != typeof s.data && (s.data = jQuery.param(s.data, s.traditional)), 
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR), 2 === state) return jqXHR;
            fireGlobals = jQuery.event && s.global, fireGlobals && 0 === jQuery.active++ && jQuery.event.trigger("ajaxStart"), 
            s.type = s.type.toUpperCase(), s.hasContent = !rnoContent.test(s.type), cacheURL = s.url, 
            s.hasContent || (s.data && (cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data, 
            delete s.data), s.cache === !1 && (s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++)), 
            s.ifModified && (jQuery.lastModified[cacheURL] && jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]), 
            jQuery.etag[cacheURL] && jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL])), 
            (s.data && s.hasContent && s.contentType !== !1 || options.contentType) && jqXHR.setRequestHeader("Content-Type", s.contentType), 
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + ("*" !== s.dataTypes[0] ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            for (i in s.headers) jqXHR.setRequestHeader(i, s.headers[i]);
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === !1 || 2 === state)) return jqXHR.abort();
            strAbort = "abort";
            for (i in {
                success: 1,
                error: 1,
                complete: 1
            }) jqXHR[i](s[i]);
            if (transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR)) {
                jqXHR.readyState = 1, fireGlobals && globalEventContext.trigger("ajaxSend", [ jqXHR, s ]), 
                s.async && s.timeout > 0 && (timeoutTimer = setTimeout(function() {
                    jqXHR.abort("timeout");
                }, s.timeout));
                try {
                    state = 1, transport.send(requestHeaders, done);
                } catch (e) {
                    if (!(2 > state)) throw e;
                    done(-1, e);
                }
            } else done(-1, "No Transport");
            return jqXHR;
        },
        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
            return jQuery.get(url, void 0, callback, "script");
        }
    }), jQuery.each([ "get", "post" ], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
            return jQuery.isFunction(data) && (type = type || callback, callback = data, data = void 0), 
            jQuery.ajax({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            });
        };
    }), jQuery._evalUrl = function(url) {
        return jQuery.ajax({
            url: url,
            type: "GET",
            dataType: "script",
            async: !1,
            global: !1,
            "throws": !0
        });
    }, jQuery.fn.extend({
        wrapAll: function(html) {
            if (jQuery.isFunction(html)) return this.each(function(i) {
                jQuery(this).wrapAll(html.call(this, i));
            });
            if (this[0]) {
                var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(!0);
                this[0].parentNode && wrap.insertBefore(this[0]), wrap.map(function() {
                    for (var elem = this; elem.firstChild && 1 === elem.firstChild.nodeType; ) elem = elem.firstChild;
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(html) {
            return jQuery.isFunction(html) ? this.each(function(i) {
                jQuery(this).wrapInner(html.call(this, i));
            }) : this.each(function() {
                var self = jQuery(this), contents = self.contents();
                contents.length ? contents.wrapAll(html) : self.append(html);
            });
        },
        wrap: function(html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function(i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function() {
            return this.parent().each(function() {
                jQuery.nodeName(this, "body") || jQuery(this).replaceWith(this.childNodes);
            }).end();
        }
    }), jQuery.expr.filters.hidden = function(elem) {
        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 || !support.reliableHiddenOffsets() && "none" === (elem.style && elem.style.display || jQuery.css(elem, "display"));
    }, jQuery.expr.filters.visible = function(elem) {
        return !jQuery.expr.filters.hidden(elem);
    };
    var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    // Serialize an array of form elements or a set of
    // key/values into a query string
    jQuery.param = function(a, traditional) {
        var prefix, s = [], add = function(key, value) {
            value = jQuery.isFunction(value) ? value() : null == value ? "" : value, s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
        };
        // If an array was passed in, assume that it is an array of form elements.
        if (// Set traditional to true for jQuery <= 1.3.2 behavior.
        void 0 === traditional && (traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional), 
        jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) // Serialize the form elements
        jQuery.each(a, function() {
            add(this.name, this.value);
        }); else // If traditional, encode the "old" way (the way 1.3.2 or older
        // did it), otherwise encode params recursively.
        for (prefix in a) buildParams(prefix, a[prefix], traditional, add);
        // Return the resulting serialization
        return s.join("&").replace(r20, "+");
    }, jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                // Can add propHook for "elements" to filter or add form elements
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function() {
                var type = this.type;
                // Use .is(":disabled") so that fieldset[disabled] works
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(i, elem) {
                var val = jQuery(this).val();
                return null == val ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    };
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, "\r\n")
                };
            }).get();
        }
    }), // Create the request object
    // (This is still attached to ajaxSettings for backward compatibility)
    jQuery.ajaxSettings.xhr = void 0 !== window.ActiveXObject ? // Support: IE6+
    function() {
        // XHR cannot access local files, always use ActiveX for that case
        // Support: IE7-8
        // oldIE XHR does not support non-RFC2616 methods (#13240)
        // See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
        // and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
        // Although this check for six methods instead of eight
        // since IE also does not support "trace" and "connect"
        return !this.isLocal && /^(get|post|head|put|delete|options)$/i.test(this.type) && createStandardXHR() || createActiveXHR();
    } : // For all other browsers, use the standard XMLHttpRequest object
    createStandardXHR;
    var xhrId = 0, xhrCallbacks = {}, xhrSupported = jQuery.ajaxSettings.xhr();
    // Support: IE<10
    // Open requests must be manually aborted on unload (#5280)
    // See https://support.microsoft.com/kb/2856746 for more info
    window.attachEvent && window.attachEvent("onunload", function() {
        for (var key in xhrCallbacks) xhrCallbacks[key](void 0, !0);
    }), // Determine support properties
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported, xhrSupported = support.ajax = !!xhrSupported, 
    xhrSupported && jQuery.ajaxTransport(function(options) {
        if (!options.crossDomain || support.cors) {
            var callback;
            return {
                send: function(headers, complete) {
                    var i, xhr = options.xhr(), id = ++xhrId;
                    if (xhr.open(options.type, options.url, options.async, options.username, options.password), 
                    options.xhrFields) for (i in options.xhrFields) xhr[i] = options.xhrFields[i];
                    options.mimeType && xhr.overrideMimeType && xhr.overrideMimeType(options.mimeType), 
                    options.crossDomain || headers["X-Requested-With"] || (headers["X-Requested-With"] = "XMLHttpRequest");
                    for (i in headers) void 0 !== headers[i] && xhr.setRequestHeader(i, headers[i] + "");
                    xhr.send(options.hasContent && options.data || null), callback = function(_, isAbort) {
                        var status, statusText, responses;
                        if (callback && (isAbort || 4 === xhr.readyState)) if (delete xhrCallbacks[id], 
                        callback = void 0, xhr.onreadystatechange = jQuery.noop, isAbort) 4 !== xhr.readyState && xhr.abort(); else {
                            responses = {}, status = xhr.status, "string" == typeof xhr.responseText && (responses.text = xhr.responseText);
                            try {
                                statusText = xhr.statusText;
                            } catch (e) {
                                statusText = "";
                            }
                            status || !options.isLocal || options.crossDomain ? 1223 === status && (status = 204) : status = responses.text ? 200 : 404;
                        }
                        responses && complete(status, statusText, responses, xhr.getAllResponseHeaders());
                    }, options.async ? 4 === xhr.readyState ? setTimeout(callback) : xhr.onreadystatechange = xhrCallbacks[id] = callback : callback();
                },
                abort: function() {
                    callback && callback(void 0, !0);
                }
            };
        }
    }), jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function(text) {
                return jQuery.globalEval(text), text;
            }
        }
    }), jQuery.ajaxPrefilter("script", function(s) {
        void 0 === s.cache && (s.cache = !1), s.crossDomain && (s.type = "GET", s.global = !1);
    }), jQuery.ajaxTransport("script", function(s) {
        if (s.crossDomain) {
            var script, head = document.head || jQuery("head")[0] || document.documentElement;
            return {
                send: function(_, callback) {
                    script = document.createElement("script"), script.async = !0, s.scriptCharset && (script.charset = s.scriptCharset), 
                    script.src = s.url, script.onload = script.onreadystatechange = function(_, isAbort) {
                        (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) && (script.onload = script.onreadystatechange = null, 
                        script.parentNode && script.parentNode.removeChild(script), script = null, isAbort || callback(200, "success"));
                    }, head.insertBefore(script, head.firstChild);
                },
                abort: function() {
                    script && script.onload(void 0, !0);
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    // Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
            return this[callback] = !0, callback;
        }
    }), // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== !1 && (rjsonp.test(s.url) ? "url" : "string" == typeof s.data && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        // Get callback name, remembering preexisting value associated with it
        // Insert callback into url or form data
        // Use data converter to retrieve json after script execution
        // force json dataType
        // Install callback
        // Clean-up function (fires after converters)
        return jsonProp || "jsonp" === s.dataTypes[0] ? (callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback, 
        jsonProp ? s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName) : s.jsonp !== !1 && (s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName), 
        s.converters["script json"] = function() {
            return responseContainer || jQuery.error(callbackName + " was not called"), responseContainer[0];
        }, s.dataTypes[0] = "json", overwritten = window[callbackName], window[callbackName] = function() {
            responseContainer = arguments;
        }, jqXHR.always(function() {
            window[callbackName] = overwritten, s[callbackName] && (s.jsonpCallback = originalSettings.jsonpCallback, 
            oldCallbacks.push(callbackName)), responseContainer && jQuery.isFunction(overwritten) && overwritten(responseContainer[0]), 
            responseContainer = overwritten = void 0;
        }), "script") : void 0;
    }), // data: string of html
    // context (optional): If specified, the fragment will be created in this context, defaults to document
    // keepScripts (optional): If true, will include scripts passed in the html string
    jQuery.parseHTML = function(data, context, keepScripts) {
        if (!data || "string" != typeof data) return null;
        "boolean" == typeof context && (keepScripts = context, context = !1), context = context || document;
        var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
        // Single tag
        // Single tag
        return parsed ? [ context.createElement(parsed[1]) ] : (parsed = jQuery.buildFragment([ data ], context, scripts), 
        scripts && scripts.length && jQuery(scripts).remove(), jQuery.merge([], parsed.childNodes));
    };
    // Keep a copy of the old load method
    var _load = jQuery.fn.load;
    /**
 * Load a url into a page
 */
    jQuery.fn.load = function(url, params, callback) {
        if ("string" != typeof url && _load) return _load.apply(this, arguments);
        var selector, response, type, self = this, off = url.indexOf(" ");
        // If it's a function
        // We assume that it's the callback
        // If we have elements to modify, make the request
        return off >= 0 && (selector = jQuery.trim(url.slice(off, url.length)), url = url.slice(0, off)), 
        jQuery.isFunction(params) ? (callback = params, params = void 0) : params && "object" == typeof params && (type = "POST"), 
        self.length > 0 && jQuery.ajax({
            url: url,
            // if "type" variable is undefined, then "GET" method will be used
            type: type,
            dataType: "html",
            data: params
        }).done(function(responseText) {
            response = arguments, self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
        }).complete(callback && function(jqXHR, status) {
            self.each(callback, response || [ jqXHR.responseText, status, jqXHR ]);
        }), this;
    }, // Attach a bunch of functions for handling common AJAX events
    jQuery.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(i, type) {
        jQuery.fn[type] = function(fn) {
            return this.on(type, fn);
        };
    }), jQuery.expr.filters.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
            return elem === fn.elem;
        }).length;
    };
    var docElem = window.document.documentElement;
    jQuery.offset = {
        setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
            // set position first, in-case top/left are set even on static elem
            "static" === position && (elem.style.position = "relative"), curOffset = curElem.offset(), 
            curCSSTop = jQuery.css(elem, "top"), curCSSLeft = jQuery.css(elem, "left"), calculatePosition = ("absolute" === position || "fixed" === position) && jQuery.inArray("auto", [ curCSSTop, curCSSLeft ]) > -1, 
            calculatePosition ? (curPosition = curElem.position(), curTop = curPosition.top, 
            curLeft = curPosition.left) : (curTop = parseFloat(curCSSTop) || 0, curLeft = parseFloat(curCSSLeft) || 0), 
            jQuery.isFunction(options) && (options = options.call(elem, i, curOffset)), null != options.top && (props.top = options.top - curOffset.top + curTop), 
            null != options.left && (props.left = options.left - curOffset.left + curLeft), 
            "using" in options ? options.using.call(elem, props) : curElem.css(props);
        }
    }, jQuery.fn.extend({
        offset: function(options) {
            if (arguments.length) return void 0 === options ? this : this.each(function(i) {
                jQuery.offset.setOffset(this, options, i);
            });
            var docElem, win, box = {
                top: 0,
                left: 0
            }, elem = this[0], doc = elem && elem.ownerDocument;
            if (doc) // Make sure it's not a disconnected DOM node
            // Make sure it's not a disconnected DOM node
            // If we don't have gBCR, just use 0,0 rather than error
            // BlackBerry 5, iOS 3 (original iPhone)
            return docElem = doc.documentElement, jQuery.contains(docElem, elem) ? (typeof elem.getBoundingClientRect !== strundefined && (box = elem.getBoundingClientRect()), 
            win = getWindow(doc), {
                top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
                left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
            }) : box;
        },
        position: function() {
            if (this[0]) {
                var offsetParent, offset, parentOffset = {
                    top: 0,
                    left: 0
                }, elem = this[0];
                // Subtract parent offsets and element margins
                // note: when an element has margin: auto the offsetLeft and marginLeft
                // are the same in Safari causing offset.left to incorrectly be 0
                // fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
                // we assume that getBoundingClientRect is available when computed position is fixed
                // Get *real* offsetParent
                // Get correct offsets
                // Add offsetParent borders
                return "fixed" === jQuery.css(elem, "position") ? offset = elem.getBoundingClientRect() : (offsetParent = this.offsetParent(), 
                offset = this.offset(), jQuery.nodeName(offsetParent[0], "html") || (parentOffset = offsetParent.offset()), 
                parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", !0), parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", !0)), 
                {
                    top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", !0),
                    left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", !0)
                };
            }
        },
        offsetParent: function() {
            return this.map(function() {
                for (var offsetParent = this.offsetParent || docElem; offsetParent && !jQuery.nodeName(offsetParent, "html") && "static" === jQuery.css(offsetParent, "position"); ) offsetParent = offsetParent.offsetParent;
                return offsetParent || docElem;
            });
        }
    }), // Create scrollLeft and scrollTop methods
    jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(method, prop) {
        var top = /Y/.test(prop);
        jQuery.fn[method] = function(val) {
            return access(this, function(elem, method, val) {
                var win = getWindow(elem);
                return void 0 === val ? win ? prop in win ? win[prop] : win.document.documentElement[method] : elem[method] : void (win ? win.scrollTo(top ? jQuery(win).scrollLeft() : val, top ? val : jQuery(win).scrollTop()) : elem[method] = val);
            }, method, val, arguments.length, null);
        };
    }), // Add the top/left cssHooks using jQuery.fn.position
    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // getComputedStyle returns percent when specified for top/left/bottom/right
    // rather than make the css module depend on the offset module, we just check for it here
    jQuery.each([ "top", "left" ], function(i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
            return computed ? (computed = curCSS(elem, prop), rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed) : void 0;
        });
    }), // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each({
        Height: "height",
        Width: "width"
    }, function(name, type) {
        jQuery.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
        }, function(defaultExtra, funcName) {
            // margin is only for outerHeight, outerWidth
            jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || "boolean" != typeof margin), extra = defaultExtra || (margin === !0 || value === !0 ? "margin" : "border");
                return access(this, function(elem, type, value) {
                    var doc;
                    // Get document width or height
                    // Get width or height on the element, requesting but not forcing parseFloat
                    // Set width or height on the element
                    return jQuery.isWindow(elem) ? elem.document.documentElement["client" + name] : 9 === elem.nodeType ? (doc = elem.documentElement, 
                    Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name])) : void 0 === value ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : void 0, chainable, null);
            };
        });
    }), // The number of elements contained in the matched element set
    jQuery.fn.size = function() {
        return this.length;
    }, jQuery.fn.andSelf = jQuery.fn.addBack, // Register as a named AMD module, since jQuery can be concatenated with other
    // files that may use define, but not via a proper concatenation script that
    // understands anonymous AMD modules. A named AMD is safest and most robust
    // way to register. Lowercase jquery is used because AMD module names are
    // derived from file names, and jQuery is normally delivered in a lowercase
    // file name. Do this after creating the global so that if an AMD module wants
    // to call noConflict to hide this version of jQuery, it will work.
    // Note that for maximum portability, libraries that are not jQuery should
    // declare themselves as anonymous modules, and avoid setting a global if an
    // AMD loader is present. jQuery is a special case. For more information, see
    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
    "function" == typeof define && define.amd && define("jquery", [], function() {
        return jQuery;
    });
    var // Map over jQuery in case of overwrite
    _jQuery = window.jQuery, // Map over the $ in case of overwrite
    _$ = window.$;
    // Expose jQuery and $ identifiers, even in
    // AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
    // and CommonJS for browser emulators (#13566)
    return jQuery.noConflict = function(deep) {
        return window.$ === jQuery && (window.$ = _$), deep && window.jQuery === jQuery && (window.jQuery = _jQuery), 
        jQuery;
    }, typeof noGlobal === strundefined && (window.jQuery = window.$ = jQuery), jQuery;
}), /*! jQuery UI - v1.11.4 - 2015-03-11
* http://jqueryui.com
* Includes: core.js, widget.js, mouse.js, position.js, accordion.js, autocomplete.js, button.js, datepicker.js, dialog.js, draggable.js, droppable.js, effect.js, effect-blind.js, effect-bounce.js, effect-clip.js, effect-drop.js, effect-explode.js, effect-fade.js, effect-fold.js, effect-highlight.js, effect-puff.js, effect-pulsate.js, effect-scale.js, effect-shake.js, effect-size.js, effect-slide.js, effect-transfer.js, menu.js, progressbar.js, resizable.js, selectable.js, selectmenu.js, slider.js, sortable.js, spinner.js, tabs.js, tooltip.js
* Copyright 2015 jQuery Foundation and other contributors; Licensed MIT */
function(factory) {
    "function" == typeof define && define.amd ? // AMD. Register as an anonymous module.
    define([ "jquery" ], factory) : // Browser globals
    factory(jQuery);
}(function($) {
    // selectors
    function focusable(element, isTabIndexNotNaN) {
        var map, mapName, img, nodeName = element.nodeName.toLowerCase();
        // the element and all of its ancestors must be visible
        return "area" === nodeName ? (map = element.parentNode, mapName = map.name, element.href && mapName && "map" === map.nodeName.toLowerCase() ? (img = $("img[usemap='#" + mapName + "']")[0], 
        !!img && visible(img)) : !1) : (/^(input|select|textarea|button|object)$/.test(nodeName) ? !element.disabled : "a" === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) && visible(element);
    }
    function visible(element) {
        return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function() {
            return "hidden" === $.css(this, "visibility");
        }).length;
    }
    function datepicker_getZindex(elem) {
        for (var position, value; elem.length && elem[0] !== document; ) {
            if (position = elem.css("position"), ("absolute" === position || "relative" === position || "fixed" === position) && (value = parseInt(elem.css("zIndex"), 10), 
            !isNaN(value) && 0 !== value)) return value;
            elem = elem.parent();
        }
        return 0;
    }
    /* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */
    function Datepicker() {
        this._curInst = null, // The current instance in use
        this._keyEvent = !1, // If the last event was a key event
        this._disabledInputs = [], // List of date picker inputs that have been disabled
        this._datepickerShowing = !1, // True if the popup picker is showing , false if not
        this._inDialog = !1, // True if showing within a "dialog", false if not
        this._mainDivId = "ui-datepicker-div", // The ID of the main datepicker division
        this._inlineClass = "ui-datepicker-inline", // The name of the inline marker class
        this._appendClass = "ui-datepicker-append", // The name of the append marker class
        this._triggerClass = "ui-datepicker-trigger", // The name of the trigger marker class
        this._dialogClass = "ui-datepicker-dialog", // The name of the dialog marker class
        this._disableClass = "ui-datepicker-disabled", // The name of the disabled covering marker class
        this._unselectableClass = "ui-datepicker-unselectable", // The name of the unselectable cell marker class
        this._currentClass = "ui-datepicker-current-day", // The name of the current day marker class
        this._dayOverClass = "ui-datepicker-days-cell-over", // The name of the day hover marker class
        this.regional = [], // Available regional settings, indexed by language code
        this.regional[""] = {
            // Default regional settings
            closeText: "Done",
            // Display text for close link
            prevText: "Prev",
            // Display text for previous month link
            nextText: "Next",
            // Display text for next month link
            currentText: "Today",
            // Display text for current month link
            monthNames: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
            // Names of months for drop-down and formatting
            monthNamesShort: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
            // For formatting
            dayNames: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
            // For formatting
            dayNamesShort: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
            // For formatting
            dayNamesMin: [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ],
            // Column headings for days starting at Sunday
            weekHeader: "Wk",
            // Column header for week of the year
            dateFormat: "mm/dd/yy",
            // See format options on parseDate
            firstDay: 0,
            // The first day of the week, Sun = 0, Mon = 1, ...
            isRTL: !1,
            // True if right-to-left language, false if left-to-right
            showMonthAfterYear: !1,
            // True if the year select precedes month, false for month then year
            yearSuffix: ""
        }, this._defaults = {
            // Global defaults for all the date picker instances
            showOn: "focus",
            // "focus" for popup on focus,
            // "button" for trigger button, or "both" for either
            showAnim: "fadeIn",
            // Name of jQuery animation for popup
            showOptions: {},
            // Options for enhanced animations
            defaultDate: null,
            // Used when field is blank: actual date,
            // +/-number for offset from today, null for today
            appendText: "",
            // Display text following the input box, e.g. showing the format
            buttonText: "...",
            // Text for trigger button
            buttonImage: "",
            // URL for trigger button image
            buttonImageOnly: !1,
            // True if the image appears alone, false if it appears on a button
            hideIfNoPrevNext: !1,
            // True to hide next/previous month links
            // if not applicable, false to just disable them
            navigationAsDateFormat: !1,
            // True if date formatting applied to prev/today/next links
            gotoCurrent: !1,
            // True if today link goes back to current selection instead
            changeMonth: !1,
            // True if month can be selected directly, false if only prev/next
            changeYear: !1,
            // True if year can be selected directly, false if only prev/next
            yearRange: "c-10:c+10",
            // Range of years to display in drop-down,
            // either relative to today's year (-nn:+nn), relative to currently displayed year
            // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
            showOtherMonths: !1,
            // True to show dates in other months, false to leave blank
            selectOtherMonths: !1,
            // True to allow selection of dates in other months, false for unselectable
            showWeek: !1,
            // True to show week of the year, false to not show it
            calculateWeek: this.iso8601Week,
            // How to calculate the week of the year,
            // takes a Date and returns the number of the week for it
            shortYearCutoff: "+10",
            // Short year values < this are in the current century,
            // > this are in the previous century,
            // string value starting with "+" for current year + value
            minDate: null,
            // The earliest selectable date, or null for no limit
            maxDate: null,
            // The latest selectable date, or null for no limit
            duration: "fast",
            // Duration of display/closure
            beforeShowDay: null,
            // Function that takes a date and returns an array with
            // [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
            // [2] = cell title (optional), e.g. $.datepicker.noWeekends
            beforeShow: null,
            // Function that takes an input field and
            // returns a set of custom settings for the date picker
            onSelect: null,
            // Define a callback function when a date is selected
            onChangeMonthYear: null,
            // Define a callback function when the month or year is changed
            onClose: null,
            // Define a callback function when the datepicker is closed
            numberOfMonths: 1,
            // Number of months to show at a time
            showCurrentAtPos: 0,
            // The position in multipe months at which to show the current month (starting at 0)
            stepMonths: 1,
            // Number of months to step back/forward
            stepBigMonths: 12,
            // Number of months to step back/forward for the big links
            altField: "",
            // Selector for an alternate field to store selected dates into
            altFormat: "",
            // The date format to use for the alternate field
            constrainInput: !0,
            // The input is constrained by the current date format
            showButtonPanel: !1,
            // True to show button panel, false to not show it
            autoSize: !1,
            // True to size the input for the date format, false to leave as is
            disabled: !1
        }, $.extend(this._defaults, this.regional[""]), this.regional.en = $.extend(!0, {}, this.regional[""]), 
        this.regional["en-US"] = $.extend(!0, {}, this.regional.en), this.dpDiv = datepicker_bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
    }
    /*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
    function datepicker_bindHover(dpDiv) {
        var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
        return dpDiv.delegate(selector, "mouseout", function() {
            $(this).removeClass("ui-state-hover"), -1 !== this.className.indexOf("ui-datepicker-prev") && $(this).removeClass("ui-datepicker-prev-hover"), 
            -1 !== this.className.indexOf("ui-datepicker-next") && $(this).removeClass("ui-datepicker-next-hover");
        }).delegate(selector, "mouseover", datepicker_handleMouseover);
    }
    function datepicker_handleMouseover() {
        $.datepicker._isDisabledDatepicker(datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[0] : datepicker_instActive.input[0]) || ($(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"), 
        $(this).addClass("ui-state-hover"), -1 !== this.className.indexOf("ui-datepicker-prev") && $(this).addClass("ui-datepicker-prev-hover"), 
        -1 !== this.className.indexOf("ui-datepicker-next") && $(this).addClass("ui-datepicker-next-hover"));
    }
    /* jQuery extend now ignores nulls! */
    function datepicker_extendRemove(target, props) {
        $.extend(target, props);
        for (var name in props) null == props[name] && (target[name] = props[name]);
        return target;
    }
    /*!
 * jQuery UI Spinner 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/spinner/
 */
    function spinner_modifier(fn) {
        return function() {
            var previous = this.element.val();
            fn.apply(this, arguments), this._refresh(), previous !== this.element.val() && this._trigger("change");
        };
    }
    /*!
 * jQuery UI Core 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */
    // $.ui might exist from components with no dependencies, e.g., $.ui.position
    $.ui = $.ui || {}, $.extend($.ui, {
        version: "1.11.4",
        keyCode: {
            BACKSPACE: 8,
            COMMA: 188,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            LEFT: 37,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38
        }
    }), // plugins
    $.fn.extend({
        scrollParent: function(includeHidden) {
            var position = this.css("position"), excludeStaticParent = "absolute" === position, overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/, scrollParent = this.parents().filter(function() {
                var parent = $(this);
                return excludeStaticParent && "static" === parent.css("position") ? !1 : overflowRegex.test(parent.css("overflow") + parent.css("overflow-y") + parent.css("overflow-x"));
            }).eq(0);
            return "fixed" !== position && scrollParent.length ? scrollParent : $(this[0].ownerDocument || document);
        },
        uniqueId: function() {
            var uuid = 0;
            return function() {
                return this.each(function() {
                    this.id || (this.id = "ui-id-" + ++uuid);
                });
            };
        }(),
        removeUniqueId: function() {
            return this.each(function() {
                /^ui-id-\d+$/.test(this.id) && $(this).removeAttr("id");
            });
        }
    }), $.extend($.expr[":"], {
        data: $.expr.createPseudo ? $.expr.createPseudo(function(dataName) {
            return function(elem) {
                return !!$.data(elem, dataName);
            };
        }) : // support: jQuery <1.8
        function(elem, i, match) {
            return !!$.data(elem, match[3]);
        },
        focusable: function(element) {
            return focusable(element, !isNaN($.attr(element, "tabindex")));
        },
        tabbable: function(element) {
            var tabIndex = $.attr(element, "tabindex"), isTabIndexNaN = isNaN(tabIndex);
            return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
        }
    }), // support: jQuery <1.8
    $("<a>").outerWidth(1).jquery || $.each([ "Width", "Height" ], function(i, name) {
        function reduce(elem, size, border, margin) {
            return $.each(side, function() {
                size -= parseFloat($.css(elem, "padding" + this)) || 0, border && (size -= parseFloat($.css(elem, "border" + this + "Width")) || 0), 
                margin && (size -= parseFloat($.css(elem, "margin" + this)) || 0);
            }), size;
        }
        var side = "Width" === name ? [ "Left", "Right" ] : [ "Top", "Bottom" ], type = name.toLowerCase(), orig = {
            innerWidth: $.fn.innerWidth,
            innerHeight: $.fn.innerHeight,
            outerWidth: $.fn.outerWidth,
            outerHeight: $.fn.outerHeight
        };
        $.fn["inner" + name] = function(size) {
            return void 0 === size ? orig["inner" + name].call(this) : this.each(function() {
                $(this).css(type, reduce(this, size) + "px");
            });
        }, $.fn["outer" + name] = function(size, margin) {
            return "number" != typeof size ? orig["outer" + name].call(this, size) : this.each(function() {
                $(this).css(type, reduce(this, size, !0, margin) + "px");
            });
        };
    }), // support: jQuery <1.8
    $.fn.addBack || ($.fn.addBack = function(selector) {
        return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector));
    }), // support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
    $("<a>").data("a-b", "a").removeData("a-b").data("a-b") && ($.fn.removeData = function(removeData) {
        return function(key) {
            return arguments.length ? removeData.call(this, $.camelCase(key)) : removeData.call(this);
        };
    }($.fn.removeData)), // deprecated
    $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()), $.fn.extend({
        focus: function(orig) {
            return function(delay, fn) {
                return "number" == typeof delay ? this.each(function() {
                    var elem = this;
                    setTimeout(function() {
                        $(elem).focus(), fn && fn.call(elem);
                    }, delay);
                }) : orig.apply(this, arguments);
            };
        }($.fn.focus),
        disableSelection: function() {
            var eventType = "onselectstart" in document.createElement("div") ? "selectstart" : "mousedown";
            return function() {
                return this.bind(eventType + ".ui-disableSelection", function(event) {
                    event.preventDefault();
                });
            };
        }(),
        enableSelection: function() {
            return this.unbind(".ui-disableSelection");
        },
        zIndex: function(zIndex) {
            if (void 0 !== zIndex) return this.css("zIndex", zIndex);
            if (this.length) for (var position, value, elem = $(this[0]); elem.length && elem[0] !== document; ) {
                if (position = elem.css("position"), ("absolute" === position || "relative" === position || "fixed" === position) && (value = parseInt(elem.css("zIndex"), 10), 
                !isNaN(value) && 0 !== value)) return value;
                elem = elem.parent();
            }
            return 0;
        }
    }), // $.ui.plugin is deprecated. Use $.widget() extensions instead.
    $.ui.plugin = {
        add: function(module, option, set) {
            var i, proto = $.ui[module].prototype;
            for (i in set) proto.plugins[i] = proto.plugins[i] || [], proto.plugins[i].push([ option, set[i] ]);
        },
        call: function(instance, name, args, allowDisconnected) {
            var i, set = instance.plugins[name];
            if (set && (allowDisconnected || instance.element[0].parentNode && 11 !== instance.element[0].parentNode.nodeType)) for (i = 0; i < set.length; i++) instance.options[set[i][0]] && set[i][1].apply(instance.element, args);
        }
    };
    /*!
 * jQuery UI Widget 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */
    var widget_uuid = 0, widget_slice = Array.prototype.slice;
    $.cleanData = function(orig) {
        return function(elems) {
            var events, elem, i;
            for (i = 0; null != (elem = elems[i]); i++) try {
                // Only trigger remove when necessary to save time
                events = $._data(elem, "events"), events && events.remove && $(elem).triggerHandler("remove");
            } catch (e) {}
            orig(elems);
        };
    }($.cleanData), $.widget = function(name, base, prototype) {
        var fullName, existingConstructor, constructor, basePrototype, // proxiedPrototype allows the provided prototype to remain unmodified
        // so that it can be used as a mixin for multiple widgets (#8876)
        proxiedPrototype = {}, namespace = name.split(".")[0];
        // create selector for plugin
        // extend with the existing constructor to carry over any static properties
        // we need to make the options hash a property directly on the new instance
        // otherwise we'll modify the options hash on the prototype that we're
        // inheriting from
        // If this widget is being redefined then we need to find all widgets that
        // are inheriting from it and redefine all of them so that they inherit from
        // the new version of this widget. We're essentially trying to replace one
        // level in the prototype chain.
        // remove the list of existing child constructors from the old constructor
        // so the old child constructors can be garbage collected
        return name = name.split(".")[1], fullName = namespace + "-" + name, prototype || (prototype = base, 
        base = $.Widget), $.expr[":"][fullName.toLowerCase()] = function(elem) {
            return !!$.data(elem, fullName);
        }, $[namespace] = $[namespace] || {}, existingConstructor = $[namespace][name], 
        constructor = $[namespace][name] = function(options, element) {
            return this._createWidget ? void (arguments.length && this._createWidget(options, element)) : new constructor(options, element);
        }, $.extend(constructor, existingConstructor, {
            version: prototype.version,
            _proto: $.extend({}, prototype),
            _childConstructors: []
        }), basePrototype = new base(), basePrototype.options = $.widget.extend({}, basePrototype.options), 
        $.each(prototype, function(prop, value) {
            return $.isFunction(value) ? void (proxiedPrototype[prop] = function() {
                var _super = function() {
                    return base.prototype[prop].apply(this, arguments);
                }, _superApply = function(args) {
                    return base.prototype[prop].apply(this, args);
                };
                return function() {
                    var returnValue, __super = this._super, __superApply = this._superApply;
                    return this._super = _super, this._superApply = _superApply, returnValue = value.apply(this, arguments), 
                    this._super = __super, this._superApply = __superApply, returnValue;
                };
            }()) : void (proxiedPrototype[prop] = value);
        }), constructor.prototype = $.widget.extend(basePrototype, {
            widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix || name : name
        }, proxiedPrototype, {
            constructor: constructor,
            namespace: namespace,
            widgetName: name,
            widgetFullName: fullName
        }), existingConstructor ? ($.each(existingConstructor._childConstructors, function(i, child) {
            var childPrototype = child.prototype;
            $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
        }), delete existingConstructor._childConstructors) : base._childConstructors.push(constructor), 
        $.widget.bridge(name, constructor), constructor;
    }, $.widget.extend = function(target) {
        for (var key, value, input = widget_slice.call(arguments, 1), inputIndex = 0, inputLength = input.length; inputLength > inputIndex; inputIndex++) for (key in input[inputIndex]) value = input[inputIndex][key], 
        input[inputIndex].hasOwnProperty(key) && void 0 !== value && ($.isPlainObject(value) ? target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : $.widget.extend({}, value) : target[key] = value);
        return target;
    }, $.widget.bridge = function(name, object) {
        var fullName = object.prototype.widgetFullName || name;
        $.fn[name] = function(options) {
            var isMethodCall = "string" == typeof options, args = widget_slice.call(arguments, 1), returnValue = this;
            // Allow multiple hashes to be passed on init
            return isMethodCall ? this.each(function() {
                var methodValue, instance = $.data(this, fullName);
                return "instance" === options ? (returnValue = instance, !1) : instance ? $.isFunction(instance[options]) && "_" !== options.charAt(0) ? (methodValue = instance[options].apply(instance, args), 
                methodValue !== instance && void 0 !== methodValue ? (returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue, 
                !1) : void 0) : $.error("no such method '" + options + "' for " + name + " widget instance") : $.error("cannot call methods on " + name + " prior to initialization; attempted to call method '" + options + "'");
            }) : (args.length && (options = $.widget.extend.apply(null, [ options ].concat(args))), 
            this.each(function() {
                var instance = $.data(this, fullName);
                instance ? (instance.option(options || {}), instance._init && instance._init()) : $.data(this, fullName, new object(options, this));
            })), returnValue;
        };
    }, $.Widget = function() {}, $.Widget._childConstructors = [], $.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
        options: {
            disabled: !1,
            // callbacks
            create: null
        },
        _createWidget: function(options, element) {
            element = $(element || this.defaultElement || this)[0], this.element = $(element), 
            this.uuid = widget_uuid++, this.eventNamespace = "." + this.widgetName + this.uuid, 
            this.bindings = $(), this.hoverable = $(), this.focusable = $(), element !== this && ($.data(element, this.widgetFullName, this), 
            this._on(!0, this.element, {
                remove: function(event) {
                    event.target === element && this.destroy();
                }
            }), this.document = $(element.style ? element.ownerDocument : element.document || element), 
            this.window = $(this.document[0].defaultView || this.document[0].parentWindow)), 
            this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options), 
            this._create(), this._trigger("create", null, this._getCreateEventData()), this._init();
        },
        _getCreateOptions: $.noop,
        _getCreateEventData: $.noop,
        _create: $.noop,
        _init: $.noop,
        destroy: function() {
            this._destroy(), // we can probably remove the unbind calls in 2.0
            // all event bindings should go through this._on()
            this.element.unbind(this.eventNamespace).removeData(this.widgetFullName).removeData($.camelCase(this.widgetFullName)), 
            this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName + "-disabled ui-state-disabled"), 
            // clean up events and states
            this.bindings.unbind(this.eventNamespace), this.hoverable.removeClass("ui-state-hover"), 
            this.focusable.removeClass("ui-state-focus");
        },
        _destroy: $.noop,
        widget: function() {
            return this.element;
        },
        option: function(key, value) {
            var parts, curOption, i, options = key;
            if (0 === arguments.length) // don't return a reference to the internal hash
            return $.widget.extend({}, this.options);
            if ("string" == typeof key) if (options = {}, parts = key.split("."), key = parts.shift(), 
            parts.length) {
                for (curOption = options[key] = $.widget.extend({}, this.options[key]), i = 0; i < parts.length - 1; i++) curOption[parts[i]] = curOption[parts[i]] || {}, 
                curOption = curOption[parts[i]];
                if (key = parts.pop(), 1 === arguments.length) return void 0 === curOption[key] ? null : curOption[key];
                curOption[key] = value;
            } else {
                if (1 === arguments.length) return void 0 === this.options[key] ? null : this.options[key];
                options[key] = value;
            }
            return this._setOptions(options), this;
        },
        _setOptions: function(options) {
            var key;
            for (key in options) this._setOption(key, options[key]);
            return this;
        },
        _setOption: function(key, value) {
            // If the widget is becoming disabled, then nothing is interactive
            return this.options[key] = value, "disabled" === key && (this.widget().toggleClass(this.widgetFullName + "-disabled", !!value), 
            value && (this.hoverable.removeClass("ui-state-hover"), this.focusable.removeClass("ui-state-focus"))), 
            this;
        },
        enable: function() {
            return this._setOptions({
                disabled: !1
            });
        },
        disable: function() {
            return this._setOptions({
                disabled: !0
            });
        },
        _on: function(suppressDisabledCheck, element, handlers) {
            var delegateElement, instance = this;
            "boolean" != typeof suppressDisabledCheck && (handlers = element, element = suppressDisabledCheck, 
            suppressDisabledCheck = !1), // no element argument, shuffle and use this.element
            handlers ? (element = delegateElement = $(element), this.bindings = this.bindings.add(element)) : (handlers = element, 
            element = this.element, delegateElement = this.widget()), $.each(handlers, function(event, handler) {
                function handlerProxy() {
                    // allow widgets to customize the disabled handling
                    // - disabled as an array instead of boolean
                    // - disabled class as method for disabling individual parts
                    // allow widgets to customize the disabled handling
                    // - disabled as an array instead of boolean
                    // - disabled class as method for disabling individual parts
                    return suppressDisabledCheck || instance.options.disabled !== !0 && !$(this).hasClass("ui-state-disabled") ? ("string" == typeof handler ? instance[handler] : handler).apply(instance, arguments) : void 0;
                }
                // copy the guid so direct unbinding works
                "string" != typeof handler && (handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++);
                var match = event.match(/^([\w:-]*)\s*(.*)$/), eventName = match[1] + instance.eventNamespace, selector = match[2];
                selector ? delegateElement.delegate(selector, eventName, handlerProxy) : element.bind(eventName, handlerProxy);
            });
        },
        _off: function(element, eventName) {
            eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace, 
            element.unbind(eventName).undelegate(eventName), this.bindings = $(this.bindings.not(element).get()), 
            this.focusable = $(this.focusable.not(element).get()), this.hoverable = $(this.hoverable.not(element).get());
        },
        _delay: function(handler, delay) {
            function handlerProxy() {
                return ("string" == typeof handler ? instance[handler] : handler).apply(instance, arguments);
            }
            var instance = this;
            return setTimeout(handlerProxy, delay || 0);
        },
        _hoverable: function(element) {
            this.hoverable = this.hoverable.add(element), this._on(element, {
                mouseenter: function(event) {
                    $(event.currentTarget).addClass("ui-state-hover");
                },
                mouseleave: function(event) {
                    $(event.currentTarget).removeClass("ui-state-hover");
                }
            });
        },
        _focusable: function(element) {
            this.focusable = this.focusable.add(element), this._on(element, {
                focusin: function(event) {
                    $(event.currentTarget).addClass("ui-state-focus");
                },
                focusout: function(event) {
                    $(event.currentTarget).removeClass("ui-state-focus");
                }
            });
        },
        _trigger: function(type, event, data) {
            var prop, orig, callback = this.options[type];
            if (data = data || {}, event = $.Event(event), event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase(), 
            event.target = this.element[0], orig = event.originalEvent) for (prop in orig) prop in event || (event[prop] = orig[prop]);
            return this.element.trigger(event, data), !($.isFunction(callback) && callback.apply(this.element[0], [ event ].concat(data)) === !1 || event.isDefaultPrevented());
        }
    }, $.each({
        show: "fadeIn",
        hide: "fadeOut"
    }, function(method, defaultEffect) {
        $.Widget.prototype["_" + method] = function(element, options, callback) {
            "string" == typeof options && (options = {
                effect: options
            });
            var hasOptions, effectName = options ? options === !0 || "number" == typeof options ? defaultEffect : options.effect || defaultEffect : method;
            options = options || {}, "number" == typeof options && (options = {
                duration: options
            }), hasOptions = !$.isEmptyObject(options), options.complete = callback, options.delay && element.delay(options.delay), 
            hasOptions && $.effects && $.effects.effect[effectName] ? element[method](options) : effectName !== method && element[effectName] ? element[effectName](options.duration, options.easing, callback) : element.queue(function(next) {
                $(this)[method](), callback && callback.call(element[0]), next();
            });
        };
    });
    var mouseHandled = ($.widget, !1);
    $(document).mouseup(function() {
        mouseHandled = !1;
    });
    $.widget("ui.mouse", {
        version: "1.11.4",
        options: {
            cancel: "input,textarea,button,select,option",
            distance: 1,
            delay: 0
        },
        _mouseInit: function() {
            var that = this;
            this.element.bind("mousedown." + this.widgetName, function(event) {
                return that._mouseDown(event);
            }).bind("click." + this.widgetName, function(event) {
                return !0 === $.data(event.target, that.widgetName + ".preventClickEvent") ? ($.removeData(event.target, that.widgetName + ".preventClickEvent"), 
                event.stopImmediatePropagation(), !1) : void 0;
            }), this.started = !1;
        },
        // TODO: make sure destroying one instance of mouse doesn't mess with
        // other instances of mouse
        _mouseDestroy: function() {
            this.element.unbind("." + this.widgetName), this._mouseMoveDelegate && this.document.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
        },
        _mouseDown: function(event) {
            // don't let more than one widget handle mouseStart
            if (!mouseHandled) {
                this._mouseMoved = !1, // we may have missed mouseup (out of window)
                this._mouseStarted && this._mouseUp(event), this._mouseDownEvent = event;
                var that = this, btnIsLeft = 1 === event.which, // event.target.nodeName works around a bug in IE 8 with
                // disabled inputs (#7620)
                elIsCancel = "string" == typeof this.options.cancel && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : !1;
                // Click event may never have fired (Gecko & Opera)
                // these delegates are required to keep context
                return btnIsLeft && !elIsCancel && this._mouseCapture(event) ? (this.mouseDelayMet = !this.options.delay, 
                this.mouseDelayMet || (this._mouseDelayTimer = setTimeout(function() {
                    that.mouseDelayMet = !0;
                }, this.options.delay)), this._mouseDistanceMet(event) && this._mouseDelayMet(event) && (this._mouseStarted = this._mouseStart(event) !== !1, 
                !this._mouseStarted) ? (event.preventDefault(), !0) : (!0 === $.data(event.target, this.widgetName + ".preventClickEvent") && $.removeData(event.target, this.widgetName + ".preventClickEvent"), 
                this._mouseMoveDelegate = function(event) {
                    return that._mouseMove(event);
                }, this._mouseUpDelegate = function(event) {
                    return that._mouseUp(event);
                }, this.document.bind("mousemove." + this.widgetName, this._mouseMoveDelegate).bind("mouseup." + this.widgetName, this._mouseUpDelegate), 
                event.preventDefault(), mouseHandled = !0, !0)) : !0;
            }
        },
        _mouseMove: function(event) {
            // Only check for mouseups outside the document if you've moved inside the document
            // at least once. This prevents the firing of mouseup in the case of IE<9, which will
            // fire a mousemove event if content is placed under the cursor. See #7778
            // Support: IE <9
            if (this._mouseMoved) {
                // IE mouseup check - mouseup happened when mouse was out of window
                if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) return this._mouseUp(event);
                if (!event.which) return this._mouseUp(event);
            }
            return (event.which || event.button) && (this._mouseMoved = !0), this._mouseStarted ? (this._mouseDrag(event), 
            event.preventDefault()) : (this._mouseDistanceMet(event) && this._mouseDelayMet(event) && (this._mouseStarted = this._mouseStart(this._mouseDownEvent, event) !== !1, 
            this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event)), !this._mouseStarted);
        },
        _mouseUp: function(event) {
            return this.document.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate), 
            this._mouseStarted && (this._mouseStarted = !1, event.target === this._mouseDownEvent.target && $.data(event.target, this.widgetName + ".preventClickEvent", !0), 
            this._mouseStop(event)), mouseHandled = !1, !1;
        },
        _mouseDistanceMet: function(event) {
            return Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance;
        },
        _mouseDelayMet: function() {
            return this.mouseDelayMet;
        },
        // These are placeholder methods, to be overriden by extending plugin
        _mouseStart: function() {},
        _mouseDrag: function() {},
        _mouseStop: function() {},
        _mouseCapture: function() {
            return !0;
        }
    });
    /*!
 * jQuery UI Position 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */
    !function() {
        function getOffsets(offsets, width, height) {
            return [ parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1), parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1) ];
        }
        function parseCss(element, property) {
            return parseInt($.css(element, property), 10) || 0;
        }
        function getDimensions(elem) {
            var raw = elem[0];
            return 9 === raw.nodeType ? {
                width: elem.width(),
                height: elem.height(),
                offset: {
                    top: 0,
                    left: 0
                }
            } : $.isWindow(raw) ? {
                width: elem.width(),
                height: elem.height(),
                offset: {
                    top: elem.scrollTop(),
                    left: elem.scrollLeft()
                }
            } : raw.preventDefault ? {
                width: 0,
                height: 0,
                offset: {
                    top: raw.pageY,
                    left: raw.pageX
                }
            } : {
                width: elem.outerWidth(),
                height: elem.outerHeight(),
                offset: elem.offset()
            };
        }
        $.ui = $.ui || {};
        var cachedScrollbarWidth, supportsOffsetFractions, max = Math.max, abs = Math.abs, round = Math.round, rhorizontal = /left|center|right/, rvertical = /top|center|bottom/, roffset = /[\+\-]\d+(\.[\d]+)?%?/, rposition = /^\w+/, rpercent = /%$/, _position = $.fn.position;
        $.position = {
            scrollbarWidth: function() {
                if (void 0 !== cachedScrollbarWidth) return cachedScrollbarWidth;
                var w1, w2, div = $("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"), innerDiv = div.children()[0];
                return $("body").append(div), w1 = innerDiv.offsetWidth, div.css("overflow", "scroll"), 
                w2 = innerDiv.offsetWidth, w1 === w2 && (w2 = div[0].clientWidth), div.remove(), 
                cachedScrollbarWidth = w1 - w2;
            },
            getScrollInfo: function(within) {
                var overflowX = within.isWindow || within.isDocument ? "" : within.element.css("overflow-x"), overflowY = within.isWindow || within.isDocument ? "" : within.element.css("overflow-y"), hasOverflowX = "scroll" === overflowX || "auto" === overflowX && within.width < within.element[0].scrollWidth, hasOverflowY = "scroll" === overflowY || "auto" === overflowY && within.height < within.element[0].scrollHeight;
                return {
                    width: hasOverflowY ? $.position.scrollbarWidth() : 0,
                    height: hasOverflowX ? $.position.scrollbarWidth() : 0
                };
            },
            getWithinInfo: function(element) {
                var withinElement = $(element || window), isWindow = $.isWindow(withinElement[0]), isDocument = !!withinElement[0] && 9 === withinElement[0].nodeType;
                return {
                    element: withinElement,
                    isWindow: isWindow,
                    isDocument: isDocument,
                    offset: withinElement.offset() || {
                        left: 0,
                        top: 0
                    },
                    scrollLeft: withinElement.scrollLeft(),
                    scrollTop: withinElement.scrollTop(),
                    // support: jQuery 1.6.x
                    // jQuery 1.6 doesn't support .outerWidth/Height() on documents or windows
                    width: isWindow || isDocument ? withinElement.width() : withinElement.outerWidth(),
                    height: isWindow || isDocument ? withinElement.height() : withinElement.outerHeight()
                };
            }
        }, $.fn.position = function(options) {
            if (!options || !options.of) return _position.apply(this, arguments);
            // make a copy, we don't want to modify arguments
            options = $.extend({}, options);
            var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions, target = $(options.of), within = $.position.getWithinInfo(options.within), scrollInfo = $.position.getScrollInfo(within), collision = (options.collision || "flip").split(" "), offsets = {};
            // force left top to allow flipping
            // clone to reuse original targetOffset later
            // force my and at to have valid horizontal and vertical positions
            // if a value is missing or invalid, it will be converted to center
            // normalize collision option
            return dimensions = getDimensions(target), target[0].preventDefault && (options.at = "left top"), 
            targetWidth = dimensions.width, targetHeight = dimensions.height, targetOffset = dimensions.offset, 
            basePosition = $.extend({}, targetOffset), $.each([ "my", "at" ], function() {
                var horizontalOffset, verticalOffset, pos = (options[this] || "").split(" ");
                1 === pos.length && (pos = rhorizontal.test(pos[0]) ? pos.concat([ "center" ]) : rvertical.test(pos[0]) ? [ "center" ].concat(pos) : [ "center", "center" ]), 
                pos[0] = rhorizontal.test(pos[0]) ? pos[0] : "center", pos[1] = rvertical.test(pos[1]) ? pos[1] : "center", 
                horizontalOffset = roffset.exec(pos[0]), verticalOffset = roffset.exec(pos[1]), 
                offsets[this] = [ horizontalOffset ? horizontalOffset[0] : 0, verticalOffset ? verticalOffset[0] : 0 ], 
                options[this] = [ rposition.exec(pos[0])[0], rposition.exec(pos[1])[0] ];
            }), 1 === collision.length && (collision[1] = collision[0]), "right" === options.at[0] ? basePosition.left += targetWidth : "center" === options.at[0] && (basePosition.left += targetWidth / 2), 
            "bottom" === options.at[1] ? basePosition.top += targetHeight : "center" === options.at[1] && (basePosition.top += targetHeight / 2), 
            atOffset = getOffsets(offsets.at, targetWidth, targetHeight), basePosition.left += atOffset[0], 
            basePosition.top += atOffset[1], this.each(function() {
                var collisionPosition, using, elem = $(this), elemWidth = elem.outerWidth(), elemHeight = elem.outerHeight(), marginLeft = parseCss(this, "marginLeft"), marginTop = parseCss(this, "marginTop"), collisionWidth = elemWidth + marginLeft + parseCss(this, "marginRight") + scrollInfo.width, collisionHeight = elemHeight + marginTop + parseCss(this, "marginBottom") + scrollInfo.height, position = $.extend({}, basePosition), myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());
                "right" === options.my[0] ? position.left -= elemWidth : "center" === options.my[0] && (position.left -= elemWidth / 2), 
                "bottom" === options.my[1] ? position.top -= elemHeight : "center" === options.my[1] && (position.top -= elemHeight / 2), 
                position.left += myOffset[0], position.top += myOffset[1], supportsOffsetFractions || (position.left = round(position.left), 
                position.top = round(position.top)), collisionPosition = {
                    marginLeft: marginLeft,
                    marginTop: marginTop
                }, $.each([ "left", "top" ], function(i, dir) {
                    $.ui.position[collision[i]] && $.ui.position[collision[i]][dir](position, {
                        targetWidth: targetWidth,
                        targetHeight: targetHeight,
                        elemWidth: elemWidth,
                        elemHeight: elemHeight,
                        collisionPosition: collisionPosition,
                        collisionWidth: collisionWidth,
                        collisionHeight: collisionHeight,
                        offset: [ atOffset[0] + myOffset[0], atOffset[1] + myOffset[1] ],
                        my: options.my,
                        at: options.at,
                        within: within,
                        elem: elem
                    });
                }), options.using && (using = function(props) {
                    var left = targetOffset.left - position.left, right = left + targetWidth - elemWidth, top = targetOffset.top - position.top, bottom = top + targetHeight - elemHeight, feedback = {
                        target: {
                            element: target,
                            left: targetOffset.left,
                            top: targetOffset.top,
                            width: targetWidth,
                            height: targetHeight
                        },
                        element: {
                            element: elem,
                            left: position.left,
                            top: position.top,
                            width: elemWidth,
                            height: elemHeight
                        },
                        horizontal: 0 > right ? "left" : left > 0 ? "right" : "center",
                        vertical: 0 > bottom ? "top" : top > 0 ? "bottom" : "middle"
                    };
                    elemWidth > targetWidth && abs(left + right) < targetWidth && (feedback.horizontal = "center"), 
                    elemHeight > targetHeight && abs(top + bottom) < targetHeight && (feedback.vertical = "middle"), 
                    max(abs(left), abs(right)) > max(abs(top), abs(bottom)) ? feedback.important = "horizontal" : feedback.important = "vertical", 
                    options.using.call(this, props, feedback);
                }), elem.offset($.extend(position, {
                    using: using
                }));
            });
        }, $.ui.position = {
            fit: {
                left: function(position, data) {
                    var newOverRight, within = data.within, withinOffset = within.isWindow ? within.scrollLeft : within.offset.left, outerWidth = within.width, collisionPosLeft = position.left - data.collisionPosition.marginLeft, overLeft = withinOffset - collisionPosLeft, overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset;
                    // element is wider than within
                    data.collisionWidth > outerWidth ? // element is initially over the left side of within
                    overLeft > 0 && 0 >= overRight ? (newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset, 
                    position.left += overLeft - newOverRight) : overRight > 0 && 0 >= overLeft ? position.left = withinOffset : overLeft > overRight ? position.left = withinOffset + outerWidth - data.collisionWidth : position.left = withinOffset : overLeft > 0 ? position.left += overLeft : overRight > 0 ? position.left -= overRight : position.left = max(position.left - collisionPosLeft, position.left);
                },
                top: function(position, data) {
                    var newOverBottom, within = data.within, withinOffset = within.isWindow ? within.scrollTop : within.offset.top, outerHeight = data.within.height, collisionPosTop = position.top - data.collisionPosition.marginTop, overTop = withinOffset - collisionPosTop, overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset;
                    // element is taller than within
                    data.collisionHeight > outerHeight ? // element is initially over the top of within
                    overTop > 0 && 0 >= overBottom ? (newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset, 
                    position.top += overTop - newOverBottom) : overBottom > 0 && 0 >= overTop ? position.top = withinOffset : overTop > overBottom ? position.top = withinOffset + outerHeight - data.collisionHeight : position.top = withinOffset : overTop > 0 ? position.top += overTop : overBottom > 0 ? position.top -= overBottom : position.top = max(position.top - collisionPosTop, position.top);
                }
            },
            flip: {
                left: function(position, data) {
                    var newOverRight, newOverLeft, within = data.within, withinOffset = within.offset.left + within.scrollLeft, outerWidth = within.width, offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left, collisionPosLeft = position.left - data.collisionPosition.marginLeft, overLeft = collisionPosLeft - offsetLeft, overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft, myOffset = "left" === data.my[0] ? -data.elemWidth : "right" === data.my[0] ? data.elemWidth : 0, atOffset = "left" === data.at[0] ? data.targetWidth : "right" === data.at[0] ? -data.targetWidth : 0, offset = -2 * data.offset[0];
                    0 > overLeft ? (newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset, 
                    (0 > newOverRight || newOverRight < abs(overLeft)) && (position.left += myOffset + atOffset + offset)) : overRight > 0 && (newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft, 
                    (newOverLeft > 0 || abs(newOverLeft) < overRight) && (position.left += myOffset + atOffset + offset));
                },
                top: function(position, data) {
                    var newOverTop, newOverBottom, within = data.within, withinOffset = within.offset.top + within.scrollTop, outerHeight = within.height, offsetTop = within.isWindow ? within.scrollTop : within.offset.top, collisionPosTop = position.top - data.collisionPosition.marginTop, overTop = collisionPosTop - offsetTop, overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop, top = "top" === data.my[1], myOffset = top ? -data.elemHeight : "bottom" === data.my[1] ? data.elemHeight : 0, atOffset = "top" === data.at[1] ? data.targetHeight : "bottom" === data.at[1] ? -data.targetHeight : 0, offset = -2 * data.offset[1];
                    0 > overTop ? (newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset, 
                    (0 > newOverBottom || newOverBottom < abs(overTop)) && (position.top += myOffset + atOffset + offset)) : overBottom > 0 && (newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop, 
                    (newOverTop > 0 || abs(newOverTop) < overBottom) && (position.top += myOffset + atOffset + offset));
                }
            },
            flipfit: {
                left: function() {
                    $.ui.position.flip.left.apply(this, arguments), $.ui.position.fit.left.apply(this, arguments);
                },
                top: function() {
                    $.ui.position.flip.top.apply(this, arguments), $.ui.position.fit.top.apply(this, arguments);
                }
            }
        }, // fraction support test
        function() {
            var testElement, testElementParent, testElementStyle, offsetLeft, i, body = document.getElementsByTagName("body")[0], div = document.createElement("div");
            testElement = document.createElement(body ? "div" : "body"), testElementStyle = {
                visibility: "hidden",
                width: 0,
                height: 0,
                border: 0,
                margin: 0,
                background: "none"
            }, body && $.extend(testElementStyle, {
                position: "absolute",
                left: "-1000px",
                top: "-1000px"
            });
            for (i in testElementStyle) testElement.style[i] = testElementStyle[i];
            testElement.appendChild(div), testElementParent = body || document.documentElement, 
            testElementParent.insertBefore(testElement, testElementParent.firstChild), div.style.cssText = "position: absolute; left: 10.7432222px;", 
            offsetLeft = $(div).offset().left, supportsOffsetFractions = offsetLeft > 10 && 11 > offsetLeft, 
            testElement.innerHTML = "", testElementParent.removeChild(testElement);
        }();
    }();
    $.ui.position, $.widget("ui.accordion", {
        version: "1.11.4",
        options: {
            active: 0,
            animate: {},
            collapsible: !1,
            event: "click",
            header: "> li > :first-child,> :not(li):even",
            heightStyle: "auto",
            icons: {
                activeHeader: "ui-icon-triangle-1-s",
                header: "ui-icon-triangle-1-e"
            },
            // callbacks
            activate: null,
            beforeActivate: null
        },
        hideProps: {
            borderTopWidth: "hide",
            borderBottomWidth: "hide",
            paddingTop: "hide",
            paddingBottom: "hide",
            height: "hide"
        },
        showProps: {
            borderTopWidth: "show",
            borderBottomWidth: "show",
            paddingTop: "show",
            paddingBottom: "show",
            height: "show"
        },
        _create: function() {
            var options = this.options;
            this.prevShow = this.prevHide = $(), this.element.addClass("ui-accordion ui-widget ui-helper-reset").attr("role", "tablist"), 
            // don't allow collapsible: false and active: false / null
            options.collapsible || options.active !== !1 && null != options.active || (options.active = 0), 
            this._processPanels(), // handle negative values
            options.active < 0 && (options.active += this.headers.length), this._refresh();
        },
        _getCreateEventData: function() {
            return {
                header: this.active,
                panel: this.active.length ? this.active.next() : $()
            };
        },
        _createIcons: function() {
            var icons = this.options.icons;
            icons && ($("<span>").addClass("ui-accordion-header-icon ui-icon " + icons.header).prependTo(this.headers), 
            this.active.children(".ui-accordion-header-icon").removeClass(icons.header).addClass(icons.activeHeader), 
            this.headers.addClass("ui-accordion-icons"));
        },
        _destroyIcons: function() {
            this.headers.removeClass("ui-accordion-icons").children(".ui-accordion-header-icon").remove();
        },
        _destroy: function() {
            var contents;
            // clean up main element
            this.element.removeClass("ui-accordion ui-widget ui-helper-reset").removeAttr("role"), 
            // clean up headers
            this.headers.removeClass("ui-accordion-header ui-accordion-header-active ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top").removeAttr("role").removeAttr("aria-expanded").removeAttr("aria-selected").removeAttr("aria-controls").removeAttr("tabIndex").removeUniqueId(), 
            this._destroyIcons(), contents = this.headers.next().removeClass("ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled").css("display", "").removeAttr("role").removeAttr("aria-hidden").removeAttr("aria-labelledby").removeUniqueId(), 
            "content" !== this.options.heightStyle && contents.css("height", "");
        },
        _setOption: function(key, value) {
            // _activate() will handle invalid values and update this.options
            // setting collapsible: false while collapsed; open first panel
            // #5332 - opacity doesn't cascade to positioned elements in IE
            // so we need to add the disabled class to the headers and panels
            return "active" === key ? void this._activate(value) : ("event" === key && (this.options.event && this._off(this.headers, this.options.event), 
            this._setupEvents(value)), this._super(key, value), "collapsible" !== key || value || this.options.active !== !1 || this._activate(0), 
            "icons" === key && (this._destroyIcons(), value && this._createIcons()), void ("disabled" === key && (this.element.toggleClass("ui-state-disabled", !!value).attr("aria-disabled", value), 
            this.headers.add(this.headers.next()).toggleClass("ui-state-disabled", !!value))));
        },
        _keydown: function(event) {
            if (!event.altKey && !event.ctrlKey) {
                var keyCode = $.ui.keyCode, length = this.headers.length, currentIndex = this.headers.index(event.target), toFocus = !1;
                switch (event.keyCode) {
                  case keyCode.RIGHT:
                  case keyCode.DOWN:
                    toFocus = this.headers[(currentIndex + 1) % length];
                    break;

                  case keyCode.LEFT:
                  case keyCode.UP:
                    toFocus = this.headers[(currentIndex - 1 + length) % length];
                    break;

                  case keyCode.SPACE:
                  case keyCode.ENTER:
                    this._eventHandler(event);
                    break;

                  case keyCode.HOME:
                    toFocus = this.headers[0];
                    break;

                  case keyCode.END:
                    toFocus = this.headers[length - 1];
                }
                toFocus && ($(event.target).attr("tabIndex", -1), $(toFocus).attr("tabIndex", 0), 
                toFocus.focus(), event.preventDefault());
            }
        },
        _panelKeyDown: function(event) {
            event.keyCode === $.ui.keyCode.UP && event.ctrlKey && $(event.currentTarget).prev().focus();
        },
        refresh: function() {
            var options = this.options;
            this._processPanels(), // was collapsed or no panel
            options.active === !1 && options.collapsible === !0 || !this.headers.length ? (options.active = !1, 
            this.active = $()) : options.active === !1 ? this._activate(0) : this.active.length && !$.contains(this.element[0], this.active[0]) ? // all remaining panel are disabled
            this.headers.length === this.headers.find(".ui-state-disabled").length ? (options.active = !1, 
            this.active = $()) : this._activate(Math.max(0, options.active - 1)) : options.active = this.headers.index(this.active), 
            this._destroyIcons(), this._refresh();
        },
        _processPanels: function() {
            var prevHeaders = this.headers, prevPanels = this.panels;
            this.headers = this.element.find(this.options.header).addClass("ui-accordion-header ui-state-default ui-corner-all"), 
            this.panels = this.headers.next().addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom").filter(":not(.ui-accordion-content-active)").hide(), 
            // Avoid memory leaks (#10056)
            prevPanels && (this._off(prevHeaders.not(this.headers)), this._off(prevPanels.not(this.panels)));
        },
        _refresh: function() {
            var maxHeight, options = this.options, heightStyle = options.heightStyle, parent = this.element.parent();
            this.active = this._findActive(options.active).addClass("ui-accordion-header-active ui-state-active ui-corner-top").removeClass("ui-corner-all"), 
            this.active.next().addClass("ui-accordion-content-active").show(), this.headers.attr("role", "tab").each(function() {
                var header = $(this), headerId = header.uniqueId().attr("id"), panel = header.next(), panelId = panel.uniqueId().attr("id");
                header.attr("aria-controls", panelId), panel.attr("aria-labelledby", headerId);
            }).next().attr("role", "tabpanel"), this.headers.not(this.active).attr({
                "aria-selected": "false",
                "aria-expanded": "false",
                tabIndex: -1
            }).next().attr({
                "aria-hidden": "true"
            }).hide(), // make sure at least one header is in the tab order
            this.active.length ? this.active.attr({
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0
            }).next().attr({
                "aria-hidden": "false"
            }) : this.headers.eq(0).attr("tabIndex", 0), this._createIcons(), this._setupEvents(options.event), 
            "fill" === heightStyle ? (maxHeight = parent.height(), this.element.siblings(":visible").each(function() {
                var elem = $(this), position = elem.css("position");
                "absolute" !== position && "fixed" !== position && (maxHeight -= elem.outerHeight(!0));
            }), this.headers.each(function() {
                maxHeight -= $(this).outerHeight(!0);
            }), this.headers.next().each(function() {
                $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
            }).css("overflow", "auto")) : "auto" === heightStyle && (maxHeight = 0, this.headers.next().each(function() {
                maxHeight = Math.max(maxHeight, $(this).css("height", "").height());
            }).height(maxHeight));
        },
        _activate: function(index) {
            var active = this._findActive(index)[0];
            // trying to activate the already active panel
            active !== this.active[0] && (active = active || this.active[0], this._eventHandler({
                target: active,
                currentTarget: active,
                preventDefault: $.noop
            }));
        },
        _findActive: function(selector) {
            return "number" == typeof selector ? this.headers.eq(selector) : $();
        },
        _setupEvents: function(event) {
            var events = {
                keydown: "_keydown"
            };
            event && $.each(event.split(" "), function(index, eventName) {
                events[eventName] = "_eventHandler";
            }), this._off(this.headers.add(this.headers.next())), this._on(this.headers, events), 
            this._on(this.headers.next(), {
                keydown: "_panelKeyDown"
            }), this._hoverable(this.headers), this._focusable(this.headers);
        },
        _eventHandler: function(event) {
            var options = this.options, active = this.active, clicked = $(event.currentTarget), clickedIsActive = clicked[0] === active[0], collapsing = clickedIsActive && options.collapsible, toShow = collapsing ? $() : clicked.next(), toHide = active.next(), eventData = {
                oldHeader: active,
                oldPanel: toHide,
                newHeader: collapsing ? $() : clicked,
                newPanel: toShow
            };
            event.preventDefault(), clickedIsActive && !options.collapsible || this._trigger("beforeActivate", event, eventData) === !1 || (options.active = collapsing ? !1 : this.headers.index(clicked), 
            // when the call to ._toggle() comes after the class changes
            // it causes a very odd bug in IE 8 (see #6720)
            this.active = clickedIsActive ? $() : clicked, this._toggle(eventData), // switch classes
            // corner classes on the previously active header stay after the animation
            active.removeClass("ui-accordion-header-active ui-state-active"), options.icons && active.children(".ui-accordion-header-icon").removeClass(options.icons.activeHeader).addClass(options.icons.header), 
            clickedIsActive || (clicked.removeClass("ui-corner-all").addClass("ui-accordion-header-active ui-state-active ui-corner-top"), 
            options.icons && clicked.children(".ui-accordion-header-icon").removeClass(options.icons.header).addClass(options.icons.activeHeader), 
            clicked.next().addClass("ui-accordion-content-active")));
        },
        _toggle: function(data) {
            var toShow = data.newPanel, toHide = this.prevShow.length ? this.prevShow : data.oldPanel;
            // handle activating a panel during the animation for another activation
            this.prevShow.add(this.prevHide).stop(!0, !0), this.prevShow = toShow, this.prevHide = toHide, 
            this.options.animate ? this._animate(toShow, toHide, data) : (toHide.hide(), toShow.show(), 
            this._toggleComplete(data)), toHide.attr({
                "aria-hidden": "true"
            }), toHide.prev().attr({
                "aria-selected": "false",
                "aria-expanded": "false"
            }), // if we're switching panels, remove the old header from the tab order
            // if we're opening from collapsed state, remove the previous header from the tab order
            // if we're collapsing, then keep the collapsing header in the tab order
            toShow.length && toHide.length ? toHide.prev().attr({
                tabIndex: -1,
                "aria-expanded": "false"
            }) : toShow.length && this.headers.filter(function() {
                return 0 === parseInt($(this).attr("tabIndex"), 10);
            }).attr("tabIndex", -1), toShow.attr("aria-hidden", "false").prev().attr({
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0
            });
        },
        _animate: function(toShow, toHide, data) {
            var total, easing, duration, that = this, adjust = 0, boxSizing = toShow.css("box-sizing"), down = toShow.length && (!toHide.length || toShow.index() < toHide.index()), animate = this.options.animate || {}, options = down && animate.down || animate, complete = function() {
                that._toggleComplete(data);
            };
            // fall back from options to animation in case of partial down settings
            return "number" == typeof options && (duration = options), "string" == typeof options && (easing = options), 
            easing = easing || options.easing || animate.easing, duration = duration || options.duration || animate.duration, 
            toHide.length ? toShow.length ? (total = toShow.show().outerHeight(), toHide.animate(this.hideProps, {
                duration: duration,
                easing: easing,
                step: function(now, fx) {
                    fx.now = Math.round(now);
                }
            }), void toShow.hide().animate(this.showProps, {
                duration: duration,
                easing: easing,
                complete: complete,
                step: function(now, fx) {
                    fx.now = Math.round(now), "height" !== fx.prop ? "content-box" === boxSizing && (adjust += fx.now) : "content" !== that.options.heightStyle && (fx.now = Math.round(total - toHide.outerHeight() - adjust), 
                    adjust = 0);
                }
            })) : toHide.animate(this.hideProps, duration, easing, complete) : toShow.animate(this.showProps, duration, easing, complete);
        },
        _toggleComplete: function(data) {
            var toHide = data.oldPanel;
            toHide.removeClass("ui-accordion-content-active").prev().removeClass("ui-corner-top").addClass("ui-corner-all"), 
            // Work around for rendering bug in IE (#5421)
            toHide.length && (toHide.parent()[0].className = toHide.parent()[0].className), 
            this._trigger("activate", null, data);
        }
    }), $.widget("ui.menu", {
        version: "1.11.4",
        defaultElement: "<ul>",
        delay: 300,
        options: {
            icons: {
                submenu: "ui-icon-carat-1-e"
            },
            items: "> *",
            menus: "ul",
            position: {
                my: "left-1 top",
                at: "right top"
            },
            role: "menu",
            // callbacks
            blur: null,
            focus: null,
            select: null
        },
        _create: function() {
            this.activeMenu = this.element, // Flag used to prevent firing of the click handler
            // as the event bubbles up through nested menus
            this.mouseHandled = !1, this.element.uniqueId().addClass("ui-menu ui-widget ui-widget-content").toggleClass("ui-menu-icons", !!this.element.find(".ui-icon").length).attr({
                role: this.options.role,
                tabIndex: 0
            }), this.options.disabled && this.element.addClass("ui-state-disabled").attr("aria-disabled", "true"), 
            this._on({
                // Prevent focus from sticking to links inside menu after clicking
                // them (focus should always stay on UL during navigation).
                "mousedown .ui-menu-item": function(event) {
                    event.preventDefault();
                },
                "click .ui-menu-item": function(event) {
                    var target = $(event.target);
                    !this.mouseHandled && target.not(".ui-state-disabled").length && (this.select(event), 
                    // Only set the mouseHandled flag if the event will bubble, see #9469.
                    event.isPropagationStopped() || (this.mouseHandled = !0), // Open submenu on click
                    target.has(".ui-menu").length ? this.expand(event) : !this.element.is(":focus") && $(this.document[0].activeElement).closest(".ui-menu").length && (// Redirect focus to the menu
                    this.element.trigger("focus", [ !0 ]), // If the active item is on the top level, let it stay active.
                    // Otherwise, blur the active item since it is no longer visible.
                    this.active && 1 === this.active.parents(".ui-menu").length && clearTimeout(this.timer)));
                },
                "mouseenter .ui-menu-item": function(event) {
                    // Ignore mouse events while typeahead is active, see #10458.
                    // Prevents focusing the wrong item when typeahead causes a scroll while the mouse
                    // is over an item in the menu
                    if (!this.previousFilter) {
                        var target = $(event.currentTarget);
                        // Remove ui-state-active class from siblings of the newly focused menu item
                        // to avoid a jump caused by adjacent elements both having a class with a border
                        target.siblings(".ui-state-active").removeClass("ui-state-active"), this.focus(event, target);
                    }
                },
                mouseleave: "collapseAll",
                "mouseleave .ui-menu": "collapseAll",
                focus: function(event, keepActiveItem) {
                    // If there's already an active item, keep it active
                    // If not, activate the first item
                    var item = this.active || this.element.find(this.options.items).eq(0);
                    keepActiveItem || this.focus(event, item);
                },
                blur: function(event) {
                    this._delay(function() {
                        $.contains(this.element[0], this.document[0].activeElement) || this.collapseAll(event);
                    });
                },
                keydown: "_keydown"
            }), this.refresh(), // Clicks outside of a menu collapse any open menus
            this._on(this.document, {
                click: function(event) {
                    this._closeOnDocumentClick(event) && this.collapseAll(event), // Reset the mouseHandled flag
                    this.mouseHandled = !1;
                }
            });
        },
        _destroy: function() {
            // Destroy (sub)menus
            this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeClass("ui-menu ui-widget ui-widget-content ui-menu-icons ui-front").removeAttr("role").removeAttr("tabIndex").removeAttr("aria-labelledby").removeAttr("aria-expanded").removeAttr("aria-hidden").removeAttr("aria-disabled").removeUniqueId().show(), 
            // Destroy menu items
            this.element.find(".ui-menu-item").removeClass("ui-menu-item").removeAttr("role").removeAttr("aria-disabled").removeUniqueId().removeClass("ui-state-hover").removeAttr("tabIndex").removeAttr("role").removeAttr("aria-haspopup").children().each(function() {
                var elem = $(this);
                elem.data("ui-menu-submenu-carat") && elem.remove();
            }), // Destroy menu dividers
            this.element.find(".ui-menu-divider").removeClass("ui-menu-divider ui-widget-content");
        },
        _keydown: function(event) {
            var match, prev, character, skip, preventDefault = !0;
            switch (event.keyCode) {
              case $.ui.keyCode.PAGE_UP:
                this.previousPage(event);
                break;

              case $.ui.keyCode.PAGE_DOWN:
                this.nextPage(event);
                break;

              case $.ui.keyCode.HOME:
                this._move("first", "first", event);
                break;

              case $.ui.keyCode.END:
                this._move("last", "last", event);
                break;

              case $.ui.keyCode.UP:
                this.previous(event);
                break;

              case $.ui.keyCode.DOWN:
                this.next(event);
                break;

              case $.ui.keyCode.LEFT:
                this.collapse(event);
                break;

              case $.ui.keyCode.RIGHT:
                this.active && !this.active.is(".ui-state-disabled") && this.expand(event);
                break;

              case $.ui.keyCode.ENTER:
              case $.ui.keyCode.SPACE:
                this._activate(event);
                break;

              case $.ui.keyCode.ESCAPE:
                this.collapse(event);
                break;

              default:
                preventDefault = !1, prev = this.previousFilter || "", character = String.fromCharCode(event.keyCode), 
                skip = !1, clearTimeout(this.filterTimer), character === prev ? skip = !0 : character = prev + character, 
                match = this._filterMenuItems(character), match = skip && -1 !== match.index(this.active.next()) ? this.active.nextAll(".ui-menu-item") : match, 
                // If no matches on the current filter, reset to the last character pressed
                // to move down the menu to the first item that starts with that character
                match.length || (character = String.fromCharCode(event.keyCode), match = this._filterMenuItems(character)), 
                match.length ? (this.focus(event, match), this.previousFilter = character, this.filterTimer = this._delay(function() {
                    delete this.previousFilter;
                }, 1e3)) : delete this.previousFilter;
            }
            preventDefault && event.preventDefault();
        },
        _activate: function(event) {
            this.active.is(".ui-state-disabled") || (this.active.is("[aria-haspopup='true']") ? this.expand(event) : this.select(event));
        },
        refresh: function() {
            var menus, items, that = this, icon = this.options.icons.submenu, submenus = this.element.find(this.options.menus);
            this.element.toggleClass("ui-menu-icons", !!this.element.find(".ui-icon").length), 
            // Initialize nested menus
            submenus.filter(":not(.ui-menu)").addClass("ui-menu ui-widget ui-widget-content ui-front").hide().attr({
                role: this.options.role,
                "aria-hidden": "true",
                "aria-expanded": "false"
            }).each(function() {
                var menu = $(this), item = menu.parent(), submenuCarat = $("<span>").addClass("ui-menu-icon ui-icon " + icon).data("ui-menu-submenu-carat", !0);
                item.attr("aria-haspopup", "true").prepend(submenuCarat), menu.attr("aria-labelledby", item.attr("id"));
            }), menus = submenus.add(this.element), items = menus.find(this.options.items), 
            items.not(".ui-menu-item").each(function() {
                var item = $(this);
                that._isDivider(item) && item.addClass("ui-widget-content ui-menu-divider");
            }), items.not(".ui-menu-item, .ui-menu-divider").addClass("ui-menu-item").uniqueId().attr({
                tabIndex: -1,
                role: this._itemRole()
            }), items.filter(".ui-state-disabled").attr("aria-disabled", "true"), this.active && !$.contains(this.element[0], this.active[0]) && this.blur();
        },
        _itemRole: function() {
            return {
                menu: "menuitem",
                listbox: "option"
            }[this.options.role];
        },
        _setOption: function(key, value) {
            "icons" === key && this.element.find(".ui-menu-icon").removeClass(this.options.icons.submenu).addClass(value.submenu), 
            "disabled" === key && this.element.toggleClass("ui-state-disabled", !!value).attr("aria-disabled", value), 
            this._super(key, value);
        },
        focus: function(event, item) {
            var nested, focused;
            this.blur(event, event && "focus" === event.type), this._scrollIntoView(item), this.active = item.first(), 
            focused = this.active.addClass("ui-state-focus").removeClass("ui-state-active"), 
            this.options.role && this.element.attr("aria-activedescendant", focused.attr("id")), 
            this.active.parent().closest(".ui-menu-item").addClass("ui-state-active"), event && "keydown" === event.type ? this._close() : this.timer = this._delay(function() {
                this._close();
            }, this.delay), nested = item.children(".ui-menu"), nested.length && event && /^mouse/.test(event.type) && this._startOpening(nested), 
            this.activeMenu = item.parent(), this._trigger("focus", event, {
                item: item
            });
        },
        _scrollIntoView: function(item) {
            var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
            this._hasScroll() && (borderTop = parseFloat($.css(this.activeMenu[0], "borderTopWidth")) || 0, 
            paddingTop = parseFloat($.css(this.activeMenu[0], "paddingTop")) || 0, offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop, 
            scroll = this.activeMenu.scrollTop(), elementHeight = this.activeMenu.height(), 
            itemHeight = item.outerHeight(), 0 > offset ? this.activeMenu.scrollTop(scroll + offset) : offset + itemHeight > elementHeight && this.activeMenu.scrollTop(scroll + offset - elementHeight + itemHeight));
        },
        blur: function(event, fromFocus) {
            fromFocus || clearTimeout(this.timer), this.active && (this.active.removeClass("ui-state-focus"), 
            this.active = null, this._trigger("blur", event, {
                item: this.active
            }));
        },
        _startOpening: function(submenu) {
            clearTimeout(this.timer), // Don't open if already open fixes a Firefox bug that caused a .5 pixel
            // shift in the submenu position when mousing over the carat icon
            "true" === submenu.attr("aria-hidden") && (this.timer = this._delay(function() {
                this._close(), this._open(submenu);
            }, this.delay));
        },
        _open: function(submenu) {
            var position = $.extend({
                of: this.active
            }, this.options.position);
            clearTimeout(this.timer), this.element.find(".ui-menu").not(submenu.parents(".ui-menu")).hide().attr("aria-hidden", "true"), 
            submenu.show().removeAttr("aria-hidden").attr("aria-expanded", "true").position(position);
        },
        collapseAll: function(event, all) {
            clearTimeout(this.timer), this.timer = this._delay(function() {
                // If we were passed an event, look for the submenu that contains the event
                var currentMenu = all ? this.element : $(event && event.target).closest(this.element.find(".ui-menu"));
                // If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
                currentMenu.length || (currentMenu = this.element), this._close(currentMenu), this.blur(event), 
                this.activeMenu = currentMenu;
            }, this.delay);
        },
        // With no arguments, closes the currently active menu - if nothing is active
        // it closes all menus.  If passed an argument, it will search for menus BELOW
        _close: function(startMenu) {
            startMenu || (startMenu = this.active ? this.active.parent() : this.element), startMenu.find(".ui-menu").hide().attr("aria-hidden", "true").attr("aria-expanded", "false").end().find(".ui-state-active").not(".ui-state-focus").removeClass("ui-state-active");
        },
        _closeOnDocumentClick: function(event) {
            return !$(event.target).closest(".ui-menu").length;
        },
        _isDivider: function(item) {
            // Match hyphen, em dash, en dash
            return !/[^\-\u2014\u2013\s]/.test(item.text());
        },
        collapse: function(event) {
            var newItem = this.active && this.active.parent().closest(".ui-menu-item", this.element);
            newItem && newItem.length && (this._close(), this.focus(event, newItem));
        },
        expand: function(event) {
            var newItem = this.active && this.active.children(".ui-menu ").find(this.options.items).first();
            newItem && newItem.length && (this._open(newItem.parent()), // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
            this._delay(function() {
                this.focus(event, newItem);
            }));
        },
        next: function(event) {
            this._move("next", "first", event);
        },
        previous: function(event) {
            this._move("prev", "last", event);
        },
        isFirstItem: function() {
            return this.active && !this.active.prevAll(".ui-menu-item").length;
        },
        isLastItem: function() {
            return this.active && !this.active.nextAll(".ui-menu-item").length;
        },
        _move: function(direction, filter, event) {
            var next;
            this.active && (next = "first" === direction || "last" === direction ? this.active["first" === direction ? "prevAll" : "nextAll"](".ui-menu-item").eq(-1) : this.active[direction + "All"](".ui-menu-item").eq(0)), 
            next && next.length && this.active || (next = this.activeMenu.find(this.options.items)[filter]()), 
            this.focus(event, next);
        },
        nextPage: function(event) {
            var item, base, height;
            return this.active ? void (this.isLastItem() || (this._hasScroll() ? (base = this.active.offset().top, 
            height = this.element.height(), this.active.nextAll(".ui-menu-item").each(function() {
                return item = $(this), item.offset().top - base - height < 0;
            }), this.focus(event, item)) : this.focus(event, this.activeMenu.find(this.options.items)[this.active ? "last" : "first"]()))) : void this.next(event);
        },
        previousPage: function(event) {
            var item, base, height;
            return this.active ? void (this.isFirstItem() || (this._hasScroll() ? (base = this.active.offset().top, 
            height = this.element.height(), this.active.prevAll(".ui-menu-item").each(function() {
                return item = $(this), item.offset().top - base + height > 0;
            }), this.focus(event, item)) : this.focus(event, this.activeMenu.find(this.options.items).first()))) : void this.next(event);
        },
        _hasScroll: function() {
            return this.element.outerHeight() < this.element.prop("scrollHeight");
        },
        select: function(event) {
            // TODO: It should never be possible to not have an active item at this
            // point, but the tests don't trigger mouseenter before click.
            this.active = this.active || $(event.target).closest(".ui-menu-item");
            var ui = {
                item: this.active
            };
            this.active.has(".ui-menu").length || this.collapseAll(event, !0), this._trigger("select", event, ui);
        },
        _filterMenuItems: function(character) {
            var escapedCharacter = character.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"), regex = new RegExp("^" + escapedCharacter, "i");
            return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function() {
                return regex.test($.trim($(this).text()));
            });
        }
    });
    /*!
 * jQuery UI Autocomplete 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/autocomplete/
 */
    $.widget("ui.autocomplete", {
        version: "1.11.4",
        defaultElement: "<input>",
        options: {
            appendTo: null,
            autoFocus: !1,
            delay: 300,
            minLength: 1,
            position: {
                my: "left top",
                at: "left bottom",
                collision: "none"
            },
            source: null,
            // callbacks
            change: null,
            close: null,
            focus: null,
            open: null,
            response: null,
            search: null,
            select: null
        },
        requestIndex: 0,
        pending: 0,
        _create: function() {
            // Some browsers only repeat keydown events, not keypress events,
            // so we use the suppressKeyPress flag to determine if we've already
            // handled the keydown event. #7269
            // Unfortunately the code for & in keypress is the same as the up arrow,
            // so we use the suppressKeyPressRepeat flag to avoid handling keypress
            // events when we know the keydown event was used to modify the
            // search term. #7799
            var suppressKeyPress, suppressKeyPressRepeat, suppressInput, nodeName = this.element[0].nodeName.toLowerCase(), isTextarea = "textarea" === nodeName, isInput = "input" === nodeName;
            this.isMultiLine = isTextarea ? !0 : isInput ? !1 : // All other element types are determined by whether or not they're contentEditable
            this.element.prop("isContentEditable"), this.valueMethod = this.element[isTextarea || isInput ? "val" : "text"], 
            this.isNewMenu = !0, this.element.addClass("ui-autocomplete-input").attr("autocomplete", "off"), 
            this._on(this.element, {
                keydown: function(event) {
                    if (this.element.prop("readOnly")) return suppressKeyPress = !0, suppressInput = !0, 
                    void (suppressKeyPressRepeat = !0);
                    suppressKeyPress = !1, suppressInput = !1, suppressKeyPressRepeat = !1;
                    var keyCode = $.ui.keyCode;
                    switch (event.keyCode) {
                      case keyCode.PAGE_UP:
                        suppressKeyPress = !0, this._move("previousPage", event);
                        break;

                      case keyCode.PAGE_DOWN:
                        suppressKeyPress = !0, this._move("nextPage", event);
                        break;

                      case keyCode.UP:
                        suppressKeyPress = !0, this._keyEvent("previous", event);
                        break;

                      case keyCode.DOWN:
                        suppressKeyPress = !0, this._keyEvent("next", event);
                        break;

                      case keyCode.ENTER:
                        // when menu is open and has focus
                        this.menu.active && (suppressKeyPress = !0, event.preventDefault(), this.menu.select(event));
                        break;

                      case keyCode.TAB:
                        this.menu.active && this.menu.select(event);
                        break;

                      case keyCode.ESCAPE:
                        this.menu.element.is(":visible") && (this.isMultiLine || this._value(this.term), 
                        this.close(event), // Different browsers have different default behavior for escape
                        // Single press can mean undo or clear
                        // Double press in IE means clear the whole form
                        event.preventDefault());
                        break;

                      default:
                        suppressKeyPressRepeat = !0, // search timeout should be triggered before the input value is changed
                        this._searchTimeout(event);
                    }
                },
                keypress: function(event) {
                    if (suppressKeyPress) return suppressKeyPress = !1, void ((!this.isMultiLine || this.menu.element.is(":visible")) && event.preventDefault());
                    if (!suppressKeyPressRepeat) {
                        // replicate some key handlers to allow them to repeat in Firefox and Opera
                        var keyCode = $.ui.keyCode;
                        switch (event.keyCode) {
                          case keyCode.PAGE_UP:
                            this._move("previousPage", event);
                            break;

                          case keyCode.PAGE_DOWN:
                            this._move("nextPage", event);
                            break;

                          case keyCode.UP:
                            this._keyEvent("previous", event);
                            break;

                          case keyCode.DOWN:
                            this._keyEvent("next", event);
                        }
                    }
                },
                input: function(event) {
                    return suppressInput ? (suppressInput = !1, void event.preventDefault()) : void this._searchTimeout(event);
                },
                focus: function() {
                    this.selectedItem = null, this.previous = this._value();
                },
                blur: function(event) {
                    return this.cancelBlur ? void delete this.cancelBlur : (clearTimeout(this.searching), 
                    this.close(event), void this._change(event));
                }
            }), this._initSource(), this.menu = $("<ul>").addClass("ui-autocomplete ui-front").appendTo(this._appendTo()).menu({
                // disable ARIA support, the live region takes care of that
                role: null
            }).hide().menu("instance"), this._on(this.menu.element, {
                mousedown: function(event) {
                    // prevent moving focus out of the text field
                    event.preventDefault(), // IE doesn't prevent moving focus even with event.preventDefault()
                    // so we set a flag to know when we should ignore the blur event
                    this.cancelBlur = !0, this._delay(function() {
                        delete this.cancelBlur;
                    });
                    // clicking on the scrollbar causes focus to shift to the body
                    // but we can't detect a mouseup or a click immediately afterward
                    // so we have to track the next mousedown and close the menu if
                    // the user clicks somewhere outside of the autocomplete
                    var menuElement = this.menu.element[0];
                    $(event.target).closest(".ui-menu-item").length || this._delay(function() {
                        var that = this;
                        this.document.one("mousedown", function(event) {
                            event.target === that.element[0] || event.target === menuElement || $.contains(menuElement, event.target) || that.close();
                        });
                    });
                },
                menufocus: function(event, ui) {
                    var label, item;
                    // support: Firefox
                    // Prevent accidental activation of menu items in Firefox (#7024 #9118)
                    // support: Firefox
                    // Prevent accidental activation of menu items in Firefox (#7024 #9118)
                    // Announce the value in the liveRegion
                    return this.isNewMenu && (this.isNewMenu = !1, event.originalEvent && /^mouse/.test(event.originalEvent.type)) ? (this.menu.blur(), 
                    void this.document.one("mousemove", function() {
                        $(event.target).trigger(event.originalEvent);
                    })) : (item = ui.item.data("ui-autocomplete-item"), !1 !== this._trigger("focus", event, {
                        item: item
                    }) && event.originalEvent && /^key/.test(event.originalEvent.type) && this._value(item.value), 
                    label = ui.item.attr("aria-label") || item.value, void (label && $.trim(label).length && (this.liveRegion.children().hide(), 
                    $("<div>").text(label).appendTo(this.liveRegion))));
                },
                menuselect: function(event, ui) {
                    var item = ui.item.data("ui-autocomplete-item"), previous = this.previous;
                    // only trigger when focus was lost (click on menu)
                    this.element[0] !== this.document[0].activeElement && (this.element.focus(), this.previous = previous, 
                    // #6109 - IE triggers two focus events and the second
                    // is asynchronous, so we need to reset the previous
                    // term synchronously and asynchronously :-(
                    this._delay(function() {
                        this.previous = previous, this.selectedItem = item;
                    })), !1 !== this._trigger("select", event, {
                        item: item
                    }) && this._value(item.value), // reset the term after the select event
                    // this allows custom select handling to work properly
                    this.term = this._value(), this.close(event), this.selectedItem = item;
                }
            }), this.liveRegion = $("<span>", {
                role: "status",
                "aria-live": "assertive",
                "aria-relevant": "additions"
            }).addClass("ui-helper-hidden-accessible").appendTo(this.document[0].body), // turning off autocomplete prevents the browser from remembering the
            // value when navigating through history, so we re-enable autocomplete
            // if the page is unloaded before the widget is destroyed. #7790
            this._on(this.window, {
                beforeunload: function() {
                    this.element.removeAttr("autocomplete");
                }
            });
        },
        _destroy: function() {
            clearTimeout(this.searching), this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete"), 
            this.menu.element.remove(), this.liveRegion.remove();
        },
        _setOption: function(key, value) {
            this._super(key, value), "source" === key && this._initSource(), "appendTo" === key && this.menu.element.appendTo(this._appendTo()), 
            "disabled" === key && value && this.xhr && this.xhr.abort();
        },
        _appendTo: function() {
            var element = this.options.appendTo;
            return element && (element = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0)), 
            element && element[0] || (element = this.element.closest(".ui-front")), element.length || (element = this.document[0].body), 
            element;
        },
        _initSource: function() {
            var array, url, that = this;
            $.isArray(this.options.source) ? (array = this.options.source, this.source = function(request, response) {
                response($.ui.autocomplete.filter(array, request.term));
            }) : "string" == typeof this.options.source ? (url = this.options.source, this.source = function(request, response) {
                that.xhr && that.xhr.abort(), that.xhr = $.ajax({
                    url: url,
                    data: request,
                    dataType: "json",
                    success: function(data) {
                        response(data);
                    },
                    error: function() {
                        response([]);
                    }
                });
            }) : this.source = this.options.source;
        },
        _searchTimeout: function(event) {
            clearTimeout(this.searching), this.searching = this._delay(function() {
                // Search if the value has changed, or if the user retypes the same value (see #7434)
                var equalValues = this.term === this._value(), menuVisible = this.menu.element.is(":visible"), modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;
                (!equalValues || equalValues && !menuVisible && !modifierKey) && (this.selectedItem = null, 
                this.search(null, event));
            }, this.options.delay);
        },
        search: function(value, event) {
            // always save the actual value, not the one passed as an argument
            return value = null != value ? value : this._value(), this.term = this._value(), 
            value.length < this.options.minLength ? this.close(event) : this._trigger("search", event) !== !1 ? this._search(value) : void 0;
        },
        _search: function(value) {
            this.pending++, this.element.addClass("ui-autocomplete-loading"), this.cancelSearch = !1, 
            this.source({
                term: value
            }, this._response());
        },
        _response: function() {
            var index = ++this.requestIndex;
            return $.proxy(function(content) {
                index === this.requestIndex && this.__response(content), this.pending--, this.pending || this.element.removeClass("ui-autocomplete-loading");
            }, this);
        },
        __response: function(content) {
            content && (content = this._normalize(content)), this._trigger("response", null, {
                content: content
            }), !this.options.disabled && content && content.length && !this.cancelSearch ? (this._suggest(content), 
            this._trigger("open")) : // use ._close() instead of .close() so we don't cancel future searches
            this._close();
        },
        close: function(event) {
            this.cancelSearch = !0, this._close(event);
        },
        _close: function(event) {
            this.menu.element.is(":visible") && (this.menu.element.hide(), this.menu.blur(), 
            this.isNewMenu = !0, this._trigger("close", event));
        },
        _change: function(event) {
            this.previous !== this._value() && this._trigger("change", event, {
                item: this.selectedItem
            });
        },
        _normalize: function(items) {
            // assume all items have the right format when the first item is complete
            // assume all items have the right format when the first item is complete
            return items.length && items[0].label && items[0].value ? items : $.map(items, function(item) {
                return "string" == typeof item ? {
                    label: item,
                    value: item
                } : $.extend({}, item, {
                    label: item.label || item.value,
                    value: item.value || item.label
                });
            });
        },
        _suggest: function(items) {
            var ul = this.menu.element.empty();
            this._renderMenu(ul, items), this.isNewMenu = !0, this.menu.refresh(), // size and position menu
            ul.show(), this._resizeMenu(), ul.position($.extend({
                of: this.element
            }, this.options.position)), this.options.autoFocus && this.menu.next();
        },
        _resizeMenu: function() {
            var ul = this.menu.element;
            ul.outerWidth(Math.max(// Firefox wraps long text (possibly a rounding bug)
            // so we add 1px to avoid the wrapping (#7513)
            ul.width("").outerWidth() + 1, this.element.outerWidth()));
        },
        _renderMenu: function(ul, items) {
            var that = this;
            $.each(items, function(index, item) {
                that._renderItemData(ul, item);
            });
        },
        _renderItemData: function(ul, item) {
            return this._renderItem(ul, item).data("ui-autocomplete-item", item);
        },
        _renderItem: function(ul, item) {
            return $("<li>").text(item.label).appendTo(ul);
        },
        _move: function(direction, event) {
            return this.menu.element.is(":visible") ? this.menu.isFirstItem() && /^previous/.test(direction) || this.menu.isLastItem() && /^next/.test(direction) ? (this.isMultiLine || this._value(this.term), 
            void this.menu.blur()) : void this.menu[direction](event) : void this.search(null, event);
        },
        widget: function() {
            return this.menu.element;
        },
        _value: function() {
            return this.valueMethod.apply(this.element, arguments);
        },
        _keyEvent: function(keyEvent, event) {
            (!this.isMultiLine || this.menu.element.is(":visible")) && (this._move(keyEvent, event), 
            // prevents moving cursor to beginning/end of the text field in some browsers
            event.preventDefault());
        }
    }), $.extend($.ui.autocomplete, {
        escapeRegex: function(value) {
            return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
        },
        filter: function(array, term) {
            var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), "i");
            return $.grep(array, function(value) {
                return matcher.test(value.label || value.value || value);
            });
        }
    }), // live region extension, adding a `messages` option
    // NOTE: This is an experimental API. We are still investigating
    // a full solution for string manipulation and internationalization.
    $.widget("ui.autocomplete", $.ui.autocomplete, {
        options: {
            messages: {
                noResults: "No search results.",
                results: function(amount) {
                    return amount + (amount > 1 ? " results are" : " result is") + " available, use up and down arrow keys to navigate.";
                }
            }
        },
        __response: function(content) {
            var message;
            this._superApply(arguments), this.options.disabled || this.cancelSearch || (message = content && content.length ? this.options.messages.results(content.length) : this.options.messages.noResults, 
            this.liveRegion.children().hide(), $("<div>").text(message).appendTo(this.liveRegion));
        }
    });
    var lastActive, baseClasses = ($.ui.autocomplete, "ui-button ui-widget ui-state-default ui-corner-all"), typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only", formResetHandler = function() {
        var form = $(this);
        setTimeout(function() {
            form.find(":ui-button").button("refresh");
        }, 1);
    }, radioGroup = function(radio) {
        var name = radio.name, form = radio.form, radios = $([]);
        return name && (name = name.replace(/'/g, "\\'"), radios = form ? $(form).find("[name='" + name + "'][type=radio]") : $("[name='" + name + "'][type=radio]", radio.ownerDocument).filter(function() {
            return !this.form;
        })), radios;
    };
    $.widget("ui.button", {
        version: "1.11.4",
        defaultElement: "<button>",
        options: {
            disabled: null,
            text: !0,
            label: null,
            icons: {
                primary: null,
                secondary: null
            }
        },
        _create: function() {
            this.element.closest("form").unbind("reset" + this.eventNamespace).bind("reset" + this.eventNamespace, formResetHandler), 
            "boolean" != typeof this.options.disabled ? this.options.disabled = !!this.element.prop("disabled") : this.element.prop("disabled", this.options.disabled), 
            this._determineButtonType(), this.hasTitle = !!this.buttonElement.attr("title");
            var that = this, options = this.options, toggleButton = "checkbox" === this.type || "radio" === this.type, activeClass = toggleButton ? "" : "ui-state-active";
            null === options.label && (options.label = "input" === this.type ? this.buttonElement.val() : this.buttonElement.html()), 
            this._hoverable(this.buttonElement), this.buttonElement.addClass(baseClasses).attr("role", "button").bind("mouseenter" + this.eventNamespace, function() {
                options.disabled || this === lastActive && $(this).addClass("ui-state-active");
            }).bind("mouseleave" + this.eventNamespace, function() {
                options.disabled || $(this).removeClass(activeClass);
            }).bind("click" + this.eventNamespace, function(event) {
                options.disabled && (event.preventDefault(), event.stopImmediatePropagation());
            }), // Can't use _focusable() because the element that receives focus
            // and the element that gets the ui-state-focus class are different
            this._on({
                focus: function() {
                    this.buttonElement.addClass("ui-state-focus");
                },
                blur: function() {
                    this.buttonElement.removeClass("ui-state-focus");
                }
            }), toggleButton && this.element.bind("change" + this.eventNamespace, function() {
                that.refresh();
            }), "checkbox" === this.type ? this.buttonElement.bind("click" + this.eventNamespace, function() {
                return options.disabled ? !1 : void 0;
            }) : "radio" === this.type ? this.buttonElement.bind("click" + this.eventNamespace, function() {
                if (options.disabled) return !1;
                $(this).addClass("ui-state-active"), that.buttonElement.attr("aria-pressed", "true");
                var radio = that.element[0];
                radioGroup(radio).not(radio).map(function() {
                    return $(this).button("widget")[0];
                }).removeClass("ui-state-active").attr("aria-pressed", "false");
            }) : (this.buttonElement.bind("mousedown" + this.eventNamespace, function() {
                return options.disabled ? !1 : ($(this).addClass("ui-state-active"), lastActive = this, 
                void that.document.one("mouseup", function() {
                    lastActive = null;
                }));
            }).bind("mouseup" + this.eventNamespace, function() {
                return options.disabled ? !1 : void $(this).removeClass("ui-state-active");
            }).bind("keydown" + this.eventNamespace, function(event) {
                return options.disabled ? !1 : void ((event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER) && $(this).addClass("ui-state-active"));
            }).bind("keyup" + this.eventNamespace + " blur" + this.eventNamespace, function() {
                $(this).removeClass("ui-state-active");
            }), this.buttonElement.is("a") && this.buttonElement.keyup(function(event) {
                event.keyCode === $.ui.keyCode.SPACE && // TODO pass through original event correctly (just as 2nd argument doesn't work)
                $(this).click();
            })), this._setOption("disabled", options.disabled), this._resetButton();
        },
        _determineButtonType: function() {
            var ancestor, labelSelector, checked;
            this.element.is("[type=checkbox]") ? this.type = "checkbox" : this.element.is("[type=radio]") ? this.type = "radio" : this.element.is("input") ? this.type = "input" : this.type = "button", 
            "checkbox" === this.type || "radio" === this.type ? (ancestor = this.element.parents().last(), 
            labelSelector = "label[for='" + this.element.attr("id") + "']", this.buttonElement = ancestor.find(labelSelector), 
            this.buttonElement.length || (ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings(), 
            this.buttonElement = ancestor.filter(labelSelector), this.buttonElement.length || (this.buttonElement = ancestor.find(labelSelector))), 
            this.element.addClass("ui-helper-hidden-accessible"), checked = this.element.is(":checked"), 
            checked && this.buttonElement.addClass("ui-state-active"), this.buttonElement.prop("aria-pressed", checked)) : this.buttonElement = this.element;
        },
        widget: function() {
            return this.buttonElement;
        },
        _destroy: function() {
            this.element.removeClass("ui-helper-hidden-accessible"), this.buttonElement.removeClass(baseClasses + " ui-state-active " + typeClasses).removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html()), 
            this.hasTitle || this.buttonElement.removeAttr("title");
        },
        _setOption: function(key, value) {
            return this._super(key, value), "disabled" === key ? (this.widget().toggleClass("ui-state-disabled", !!value), 
            this.element.prop("disabled", !!value), void (value && ("checkbox" === this.type || "radio" === this.type ? this.buttonElement.removeClass("ui-state-focus") : this.buttonElement.removeClass("ui-state-focus ui-state-active")))) : void this._resetButton();
        },
        refresh: function() {
            //See #8237 & #8828
            var isDisabled = this.element.is("input, button") ? this.element.is(":disabled") : this.element.hasClass("ui-button-disabled");
            isDisabled !== this.options.disabled && this._setOption("disabled", isDisabled), 
            "radio" === this.type ? radioGroup(this.element[0]).each(function() {
                $(this).is(":checked") ? $(this).button("widget").addClass("ui-state-active").attr("aria-pressed", "true") : $(this).button("widget").removeClass("ui-state-active").attr("aria-pressed", "false");
            }) : "checkbox" === this.type && (this.element.is(":checked") ? this.buttonElement.addClass("ui-state-active").attr("aria-pressed", "true") : this.buttonElement.removeClass("ui-state-active").attr("aria-pressed", "false"));
        },
        _resetButton: function() {
            if ("input" === this.type) return void (this.options.label && this.element.val(this.options.label));
            var buttonElement = this.buttonElement.removeClass(typeClasses), buttonText = $("<span></span>", this.document[0]).addClass("ui-button-text").html(this.options.label).appendTo(buttonElement.empty()).text(), icons = this.options.icons, multipleIcons = icons.primary && icons.secondary, buttonClasses = [];
            icons.primary || icons.secondary ? (this.options.text && buttonClasses.push("ui-button-text-icon" + (multipleIcons ? "s" : icons.primary ? "-primary" : "-secondary")), 
            icons.primary && buttonElement.prepend("<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>"), 
            icons.secondary && buttonElement.append("<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>"), 
            this.options.text || (buttonClasses.push(multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only"), 
            this.hasTitle || buttonElement.attr("title", $.trim(buttonText)))) : buttonClasses.push("ui-button-text-only"), 
            buttonElement.addClass(buttonClasses.join(" "));
        }
    }), $.widget("ui.buttonset", {
        version: "1.11.4",
        options: {
            items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"
        },
        _create: function() {
            this.element.addClass("ui-buttonset");
        },
        _init: function() {
            this.refresh();
        },
        _setOption: function(key, value) {
            "disabled" === key && this.buttons.button("option", key, value), this._super(key, value);
        },
        refresh: function() {
            var rtl = "rtl" === this.element.css("direction"), allButtons = this.element.find(this.options.items), existingButtons = allButtons.filter(":ui-button");
            // Initialize new buttons
            allButtons.not(":ui-button").button(), // Refresh existing buttons
            existingButtons.button("refresh"), this.buttons = allButtons.map(function() {
                return $(this).button("widget")[0];
            }).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(rtl ? "ui-corner-right" : "ui-corner-left").end().filter(":last").addClass(rtl ? "ui-corner-left" : "ui-corner-right").end().end();
        },
        _destroy: function() {
            this.element.removeClass("ui-buttonset"), this.buttons.map(function() {
                return $(this).button("widget")[0];
            }).removeClass("ui-corner-left ui-corner-right").end().button("destroy");
        }
    });
    $.ui.button;
    /*!
 * jQuery UI Datepicker 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/datepicker/
 */
    $.extend($.ui, {
        datepicker: {
            version: "1.11.4"
        }
    });
    var datepicker_instActive;
    $.extend(Datepicker.prototype, {
        /* Class name added to elements to indicate already configured with a date picker. */
        markerClassName: "hasDatepicker",
        //Keep track of the maximum number of rows displayed (see #7043)
        maxRows: 4,
        // TODO rename to "widget" when switching to widget factory
        _widgetDatepicker: function() {
            return this.dpDiv;
        },
        /* Override the default settings for all instances of the date picker.
	 * @param  settings  object - the new settings to use as defaults (anonymous object)
	 * @return the manager object
	 */
        setDefaults: function(settings) {
            return datepicker_extendRemove(this._defaults, settings || {}), this;
        },
        /* Attach the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
	 */
        _attachDatepicker: function(target, settings) {
            var nodeName, inline, inst;
            nodeName = target.nodeName.toLowerCase(), inline = "div" === nodeName || "span" === nodeName, 
            target.id || (this.uuid += 1, target.id = "dp" + this.uuid), inst = this._newInst($(target), inline), 
            inst.settings = $.extend({}, settings || {}), "input" === nodeName ? this._connectDatepicker(target, inst) : inline && this._inlineDatepicker(target, inst);
        },
        /* Create a new instance object. */
        _newInst: function(target, inline) {
            var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1");
            // escape jQuery meta chars
            return {
                id: id,
                input: target,
                // associated target
                selectedDay: 0,
                selectedMonth: 0,
                selectedYear: 0,
                // current selection
                drawMonth: 0,
                drawYear: 0,
                // month being drawn
                inline: inline,
                // is datepicker inline or not
                dpDiv: inline ? // presentation div
                datepicker_bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")) : this.dpDiv
            };
        },
        /* Attach the date picker to an input field. */
        _connectDatepicker: function(target, inst) {
            var input = $(target);
            inst.append = $([]), inst.trigger = $([]), input.hasClass(this.markerClassName) || (this._attachments(input, inst), 
            input.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp), 
            this._autoSize(inst), $.data(target, "datepicker", inst), //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
            inst.settings.disabled && this._disableDatepicker(target));
        },
        /* Make attachments based on settings. */
        _attachments: function(input, inst) {
            var showOn, buttonText, buttonImage, appendText = this._get(inst, "appendText"), isRTL = this._get(inst, "isRTL");
            inst.append && inst.append.remove(), appendText && (inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>"), 
            input[isRTL ? "before" : "after"](inst.append)), input.unbind("focus", this._showDatepicker), 
            inst.trigger && inst.trigger.remove(), showOn = this._get(inst, "showOn"), ("focus" === showOn || "both" === showOn) && input.focus(this._showDatepicker), 
            ("button" === showOn || "both" === showOn) && (buttonText = this._get(inst, "buttonText"), 
            buttonImage = this._get(inst, "buttonImage"), inst.trigger = $(this._get(inst, "buttonImageOnly") ? $("<img/>").addClass(this._triggerClass).attr({
                src: buttonImage,
                alt: buttonText,
                title: buttonText
            }) : $("<button type='button'></button>").addClass(this._triggerClass).html(buttonImage ? $("<img/>").attr({
                src: buttonImage,
                alt: buttonText,
                title: buttonText
            }) : buttonText)), input[isRTL ? "before" : "after"](inst.trigger), inst.trigger.click(function() {
                return $.datepicker._datepickerShowing && $.datepicker._lastInput === input[0] ? $.datepicker._hideDatepicker() : $.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0] ? ($.datepicker._hideDatepicker(), 
                $.datepicker._showDatepicker(input[0])) : $.datepicker._showDatepicker(input[0]), 
                !1;
            }));
        },
        /* Apply the maximum length for the date format. */
        _autoSize: function(inst) {
            if (this._get(inst, "autoSize") && !inst.inline) {
                var findMax, max, maxI, i, date = new Date(2009, 11, 20), // Ensure double digits
                dateFormat = this._get(inst, "dateFormat");
                dateFormat.match(/[DM]/) && (findMax = function(names) {
                    for (max = 0, maxI = 0, i = 0; i < names.length; i++) names[i].length > max && (max = names[i].length, 
                    maxI = i);
                    return maxI;
                }, date.setMonth(findMax(this._get(inst, dateFormat.match(/MM/) ? "monthNames" : "monthNamesShort"))), 
                date.setDate(findMax(this._get(inst, dateFormat.match(/DD/) ? "dayNames" : "dayNamesShort")) + 20 - date.getDay())), 
                inst.input.attr("size", this._formatDate(inst, date).length);
            }
        },
        /* Attach an inline date picker to a div. */
        _inlineDatepicker: function(target, inst) {
            var divSpan = $(target);
            divSpan.hasClass(this.markerClassName) || (divSpan.addClass(this.markerClassName).append(inst.dpDiv), 
            $.data(target, "datepicker", inst), this._setDate(inst, this._getDefaultDate(inst), !0), 
            this._updateDatepicker(inst), this._updateAlternate(inst), //If disabled option is true, disable the datepicker before showing it (see ticket #5665)
            inst.settings.disabled && this._disableDatepicker(target), // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
            // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
            inst.dpDiv.css("display", "block"));
        },
        /* Pop-up the date picker in a "dialog" box.
	 * @param  input element - ignored
	 * @param  date	string or Date - the initial date to display
	 * @param  onSelect  function - the function to call when a date is selected
	 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	 * @param  pos int[2] - coordinates for the dialog's position within the screen or
	 *					event - with x/y coordinates or
	 *					leave empty for default (screen centre)
	 * @return the manager object
	 */
        _dialogDatepicker: function(input, date, onSelect, settings, pos) {
            var id, browserWidth, browserHeight, scrollX, scrollY, inst = this._dialogInst;
            // internal instance
            // should use actual width/height below
            // move input on screen for focus, but hidden behind dialog
            return inst || (this.uuid += 1, id = "dp" + this.uuid, this._dialogInput = $("<input type='text' id='" + id + "' style='position: absolute; top: -100px; width: 0px;'/>"), 
            this._dialogInput.keydown(this._doKeyDown), $("body").append(this._dialogInput), 
            inst = this._dialogInst = this._newInst(this._dialogInput, !1), inst.settings = {}, 
            $.data(this._dialogInput[0], "datepicker", inst)), datepicker_extendRemove(inst.settings, settings || {}), 
            date = date && date.constructor === Date ? this._formatDate(inst, date) : date, 
            this._dialogInput.val(date), this._pos = pos ? pos.length ? pos : [ pos.pageX, pos.pageY ] : null, 
            this._pos || (browserWidth = document.documentElement.clientWidth, browserHeight = document.documentElement.clientHeight, 
            scrollX = document.documentElement.scrollLeft || document.body.scrollLeft, scrollY = document.documentElement.scrollTop || document.body.scrollTop, 
            this._pos = [ browserWidth / 2 - 100 + scrollX, browserHeight / 2 - 150 + scrollY ]), 
            this._dialogInput.css("left", this._pos[0] + 20 + "px").css("top", this._pos[1] + "px"), 
            inst.settings.onSelect = onSelect, this._inDialog = !0, this.dpDiv.addClass(this._dialogClass), 
            this._showDatepicker(this._dialogInput[0]), $.blockUI && $.blockUI(this.dpDiv), 
            $.data(this._dialogInput[0], "datepicker", inst), this;
        },
        /* Detach a datepicker from its control.
	 * @param  target	element - the target input field or division or span
	 */
        _destroyDatepicker: function(target) {
            var nodeName, $target = $(target), inst = $.data(target, "datepicker");
            $target.hasClass(this.markerClassName) && (nodeName = target.nodeName.toLowerCase(), 
            $.removeData(target, "datepicker"), "input" === nodeName ? (inst.append.remove(), 
            inst.trigger.remove(), $target.removeClass(this.markerClassName).unbind("focus", this._showDatepicker).unbind("keydown", this._doKeyDown).unbind("keypress", this._doKeyPress).unbind("keyup", this._doKeyUp)) : ("div" === nodeName || "span" === nodeName) && $target.removeClass(this.markerClassName).empty(), 
            datepicker_instActive === inst && (datepicker_instActive = null));
        },
        /* Enable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
        _enableDatepicker: function(target) {
            var nodeName, inline, $target = $(target), inst = $.data(target, "datepicker");
            $target.hasClass(this.markerClassName) && (nodeName = target.nodeName.toLowerCase(), 
            "input" === nodeName ? (target.disabled = !1, inst.trigger.filter("button").each(function() {
                this.disabled = !1;
            }).end().filter("img").css({
                opacity: "1.0",
                cursor: ""
            })) : ("div" === nodeName || "span" === nodeName) && (inline = $target.children("." + this._inlineClass), 
            inline.children().removeClass("ui-state-disabled"), inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", !1)), 
            this._disabledInputs = $.map(this._disabledInputs, function(value) {
                return value === target ? null : value;
            }));
        },
        /* Disable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
        _disableDatepicker: function(target) {
            var nodeName, inline, $target = $(target), inst = $.data(target, "datepicker");
            $target.hasClass(this.markerClassName) && (nodeName = target.nodeName.toLowerCase(), 
            "input" === nodeName ? (target.disabled = !0, inst.trigger.filter("button").each(function() {
                this.disabled = !0;
            }).end().filter("img").css({
                opacity: "0.5",
                cursor: "default"
            })) : ("div" === nodeName || "span" === nodeName) && (inline = $target.children("." + this._inlineClass), 
            inline.children().addClass("ui-state-disabled"), inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", !0)), 
            this._disabledInputs = $.map(this._disabledInputs, function(value) {
                return value === target ? null : value;
            }), this._disabledInputs[this._disabledInputs.length] = target);
        },
        /* Is the first field in a jQuery collection disabled as a datepicker?
	 * @param  target	element - the target input field or division or span
	 * @return boolean - true if disabled, false if enabled
	 */
        _isDisabledDatepicker: function(target) {
            if (!target) return !1;
            for (var i = 0; i < this._disabledInputs.length; i++) if (this._disabledInputs[i] === target) return !0;
            return !1;
        },
        /* Retrieve the instance data for the target control.
	 * @param  target  element - the target input field or division or span
	 * @return  object - the associated instance data
	 * @throws  error if a jQuery problem getting data
	 */
        _getInst: function(target) {
            try {
                return $.data(target, "datepicker");
            } catch (err) {
                throw "Missing instance data for this datepicker";
            }
        },
        /* Update or retrieve the settings for a date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 * @param  name	object - the new settings to update or
	 *				string - the name of the setting to change or retrieve,
	 *				when retrieving also "all" for all instance settings or
	 *				"defaults" for all global defaults
	 * @param  value   any - the new value for the setting
	 *				(omit if above is an object or to retrieve a value)
	 */
        _optionDatepicker: function(target, name, value) {
            var settings, date, minDate, maxDate, inst = this._getInst(target);
            // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
            return 2 === arguments.length && "string" == typeof name ? "defaults" === name ? $.extend({}, $.datepicker._defaults) : inst ? "all" === name ? $.extend({}, inst.settings) : this._get(inst, name) : null : (settings = name || {}, 
            "string" == typeof name && (settings = {}, settings[name] = value), void (inst && (this._curInst === inst && this._hideDatepicker(), 
            date = this._getDateDatepicker(target, !0), minDate = this._getMinMaxDate(inst, "min"), 
            maxDate = this._getMinMaxDate(inst, "max"), datepicker_extendRemove(inst.settings, settings), 
            null !== minDate && void 0 !== settings.dateFormat && void 0 === settings.minDate && (inst.settings.minDate = this._formatDate(inst, minDate)), 
            null !== maxDate && void 0 !== settings.dateFormat && void 0 === settings.maxDate && (inst.settings.maxDate = this._formatDate(inst, maxDate)), 
            "disabled" in settings && (settings.disabled ? this._disableDatepicker(target) : this._enableDatepicker(target)), 
            this._attachments($(target), inst), this._autoSize(inst), this._setDate(inst, date), 
            this._updateAlternate(inst), this._updateDatepicker(inst))));
        },
        // change method deprecated
        _changeDatepicker: function(target, name, value) {
            this._optionDatepicker(target, name, value);
        },
        /* Redraw the date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 */
        _refreshDatepicker: function(target) {
            var inst = this._getInst(target);
            inst && this._updateDatepicker(inst);
        },
        /* Set the dates for a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  date	Date - the new date
	 */
        _setDateDatepicker: function(target, date) {
            var inst = this._getInst(target);
            inst && (this._setDate(inst, date), this._updateDatepicker(inst), this._updateAlternate(inst));
        },
        /* Get the date(s) for the first entry in a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  noDefault boolean - true if no default date is to be used
	 * @return Date - the current date
	 */
        _getDateDatepicker: function(target, noDefault) {
            var inst = this._getInst(target);
            return inst && !inst.inline && this._setDateFromField(inst, noDefault), inst ? this._getDate(inst) : null;
        },
        /* Handle keystrokes. */
        _doKeyDown: function(event) {
            var onSelect, dateStr, sel, inst = $.datepicker._getInst(event.target), handled = !0, isRTL = inst.dpDiv.is(".ui-datepicker-rtl");
            if (inst._keyEvent = !0, $.datepicker._datepickerShowing) switch (event.keyCode) {
              case 9:
                $.datepicker._hideDatepicker(), handled = !1;
                break;

              // hide on tab out
                case 13:
                // trigger custom callback
                return sel = $("td." + $.datepicker._dayOverClass + ":not(." + $.datepicker._currentClass + ")", inst.dpDiv), 
                sel[0] && $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]), 
                onSelect = $.datepicker._get(inst, "onSelect"), onSelect ? (dateStr = $.datepicker._formatDate(inst), 
                onSelect.apply(inst.input ? inst.input[0] : null, [ dateStr, inst ])) : $.datepicker._hideDatepicker(), 
                !1;

              // don't submit the form
                case 27:
                $.datepicker._hideDatepicker();
                break;

              // hide on escape
                case 33:
                $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths"), "M");
                break;

              // previous month/year on page up/+ ctrl
                case 34:
                $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths"), "M");
                break;

              // next month/year on page down/+ ctrl
                case 35:
                (event.ctrlKey || event.metaKey) && $.datepicker._clearDate(event.target), handled = event.ctrlKey || event.metaKey;
                break;

              // clear on ctrl or command +end
                case 36:
                (event.ctrlKey || event.metaKey) && $.datepicker._gotoToday(event.target), handled = event.ctrlKey || event.metaKey;
                break;

              // current on ctrl or command +home
                case 37:
                (event.ctrlKey || event.metaKey) && $.datepicker._adjustDate(event.target, isRTL ? 1 : -1, "D"), 
                handled = event.ctrlKey || event.metaKey, // -1 day on ctrl or command +left
                event.originalEvent.altKey && $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths"), "M");
                // next month/year on alt +left on Mac
                break;

              case 38:
                (event.ctrlKey || event.metaKey) && $.datepicker._adjustDate(event.target, -7, "D"), 
                handled = event.ctrlKey || event.metaKey;
                break;

              // -1 week on ctrl or command +up
                case 39:
                (event.ctrlKey || event.metaKey) && $.datepicker._adjustDate(event.target, isRTL ? -1 : 1, "D"), 
                handled = event.ctrlKey || event.metaKey, // +1 day on ctrl or command +right
                event.originalEvent.altKey && $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths"), "M");
                // next month/year on alt +right
                break;

              case 40:
                (event.ctrlKey || event.metaKey) && $.datepicker._adjustDate(event.target, 7, "D"), 
                handled = event.ctrlKey || event.metaKey;
                break;

              // +1 week on ctrl or command +down
                default:
                handled = !1;
            } else 36 === event.keyCode && event.ctrlKey ? // display the date picker on ctrl+home
            $.datepicker._showDatepicker(this) : handled = !1;
            handled && (event.preventDefault(), event.stopPropagation());
        },
        /* Filter entered characters - based on date format. */
        _doKeyPress: function(event) {
            var chars, chr, inst = $.datepicker._getInst(event.target);
            return $.datepicker._get(inst, "constrainInput") ? (chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat")), 
            chr = String.fromCharCode(null == event.charCode ? event.keyCode : event.charCode), 
            event.ctrlKey || event.metaKey || " " > chr || !chars || chars.indexOf(chr) > -1) : void 0;
        },
        /* Synchronise manual entry and field/alternate field. */
        _doKeyUp: function(event) {
            var date, inst = $.datepicker._getInst(event.target);
            if (inst.input.val() !== inst.lastVal) try {
                date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), inst.input ? inst.input.val() : null, $.datepicker._getFormatConfig(inst)), 
                date && (// only if valid
                $.datepicker._setDateFromField(inst), $.datepicker._updateAlternate(inst), $.datepicker._updateDatepicker(inst));
            } catch (err) {}
            return !0;
        },
        /* Pop-up the date picker for a given input field.
	 * If false returned from beforeShow event handler do not show.
	 * @param  input  element - the input field attached to the date picker or
	 *					event - if triggered by focus
	 */
        _showDatepicker: function(input) {
            if (input = input.target || input, "input" !== input.nodeName.toLowerCase() && (input = $("input", input.parentNode)[0]), 
            !$.datepicker._isDisabledDatepicker(input) && $.datepicker._lastInput !== input) {
                var inst, beforeShow, beforeShowSettings, isFixed, offset, showAnim, duration;
                inst = $.datepicker._getInst(input), $.datepicker._curInst && $.datepicker._curInst !== inst && ($.datepicker._curInst.dpDiv.stop(!0, !0), 
                inst && $.datepicker._datepickerShowing && $.datepicker._hideDatepicker($.datepicker._curInst.input[0])), 
                beforeShow = $.datepicker._get(inst, "beforeShow"), beforeShowSettings = beforeShow ? beforeShow.apply(input, [ input, inst ]) : {}, 
                beforeShowSettings !== !1 && (datepicker_extendRemove(inst.settings, beforeShowSettings), 
                inst.lastVal = null, $.datepicker._lastInput = input, $.datepicker._setDateFromField(inst), 
                $.datepicker._inDialog && (// hide cursor
                input.value = ""), $.datepicker._pos || (// position below input
                $.datepicker._pos = $.datepicker._findPos(input), $.datepicker._pos[1] += input.offsetHeight), 
                isFixed = !1, $(input).parents().each(function() {
                    return isFixed |= "fixed" === $(this).css("position"), !isFixed;
                }), offset = {
                    left: $.datepicker._pos[0],
                    top: $.datepicker._pos[1]
                }, $.datepicker._pos = null, inst.dpDiv.empty(), inst.dpDiv.css({
                    position: "absolute",
                    display: "block",
                    top: "-1000px"
                }), $.datepicker._updateDatepicker(inst), offset = $.datepicker._checkOffset(inst, offset, isFixed), 
                inst.dpDiv.css({
                    position: $.datepicker._inDialog && $.blockUI ? "static" : isFixed ? "fixed" : "absolute",
                    display: "none",
                    left: offset.left + "px",
                    top: offset.top + "px"
                }), inst.inline || (showAnim = $.datepicker._get(inst, "showAnim"), duration = $.datepicker._get(inst, "duration"), 
                inst.dpDiv.css("z-index", datepicker_getZindex($(input)) + 1), $.datepicker._datepickerShowing = !0, 
                $.effects && $.effects.effect[showAnim] ? inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration) : inst.dpDiv[showAnim || "show"](showAnim ? duration : null), 
                $.datepicker._shouldFocusInput(inst) && inst.input.focus(), $.datepicker._curInst = inst));
            }
        },
        /* Generate the date picker content. */
        _updateDatepicker: function(inst) {
            this.maxRows = 4, datepicker_instActive = inst, inst.dpDiv.empty().append(this._generateHTML(inst)), 
            this._attachHandlers(inst);
            var origyearshtml, numMonths = this._getNumberOfMonths(inst), cols = numMonths[1], width = 17, activeCell = inst.dpDiv.find("." + this._dayOverClass + " a");
            activeCell.length > 0 && datepicker_handleMouseover.apply(activeCell.get(0)), inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""), 
            cols > 1 && inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", width * cols + "em"), 
            inst.dpDiv[(1 !== numMonths[0] || 1 !== numMonths[1] ? "add" : "remove") + "Class"]("ui-datepicker-multi"), 
            inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") + "Class"]("ui-datepicker-rtl"), 
            inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst) && inst.input.focus(), 
            // deffered render of the years select (to avoid flashes on Firefox)
            inst.yearshtml && (origyearshtml = inst.yearshtml, setTimeout(function() {
                origyearshtml === inst.yearshtml && inst.yearshtml && inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml), 
                origyearshtml = inst.yearshtml = null;
            }, 0));
        },
        // #6694 - don't focus the input if it's already focused
        // this breaks the change event in IE
        // Support: IE and jQuery <1.9
        _shouldFocusInput: function(inst) {
            return inst.input && inst.input.is(":visible") && !inst.input.is(":disabled") && !inst.input.is(":focus");
        },
        /* Check positioning to remain on screen. */
        _checkOffset: function(inst, offset, isFixed) {
            var dpWidth = inst.dpDiv.outerWidth(), dpHeight = inst.dpDiv.outerHeight(), inputWidth = inst.input ? inst.input.outerWidth() : 0, inputHeight = inst.input ? inst.input.outerHeight() : 0, viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()), viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());
            // now check if datepicker is showing outside window viewport - move to a better place if so.
            return offset.left -= this._get(inst, "isRTL") ? dpWidth - inputWidth : 0, offset.left -= isFixed && offset.left === inst.input.offset().left ? $(document).scrollLeft() : 0, 
            offset.top -= isFixed && offset.top === inst.input.offset().top + inputHeight ? $(document).scrollTop() : 0, 
            offset.left -= Math.min(offset.left, offset.left + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offset.left + dpWidth - viewWidth) : 0), 
            offset.top -= Math.min(offset.top, offset.top + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight) : 0), 
            offset;
        },
        /* Find an object's position on the screen. */
        _findPos: function(obj) {
            for (var position, inst = this._getInst(obj), isRTL = this._get(inst, "isRTL"); obj && ("hidden" === obj.type || 1 !== obj.nodeType || $.expr.filters.hidden(obj)); ) obj = obj[isRTL ? "previousSibling" : "nextSibling"];
            return position = $(obj).offset(), [ position.left, position.top ];
        },
        /* Hide the date picker from view.
	 * @param  input  element - the input field attached to the date picker
	 */
        _hideDatepicker: function(input) {
            var showAnim, duration, postProcess, onClose, inst = this._curInst;
            !inst || input && inst !== $.data(input, "datepicker") || this._datepickerShowing && (showAnim = this._get(inst, "showAnim"), 
            duration = this._get(inst, "duration"), postProcess = function() {
                $.datepicker._tidyDialog(inst);
            }, $.effects && ($.effects.effect[showAnim] || $.effects[showAnim]) ? inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess) : inst.dpDiv["slideDown" === showAnim ? "slideUp" : "fadeIn" === showAnim ? "fadeOut" : "hide"](showAnim ? duration : null, postProcess), 
            showAnim || postProcess(), this._datepickerShowing = !1, onClose = this._get(inst, "onClose"), 
            onClose && onClose.apply(inst.input ? inst.input[0] : null, [ inst.input ? inst.input.val() : "", inst ]), 
            this._lastInput = null, this._inDialog && (this._dialogInput.css({
                position: "absolute",
                left: "0",
                top: "-100px"
            }), $.blockUI && ($.unblockUI(), $("body").append(this.dpDiv))), this._inDialog = !1);
        },
        /* Tidy up after a dialog display. */
        _tidyDialog: function(inst) {
            inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
        },
        /* Close date picker if clicked elsewhere. */
        _checkExternalClick: function(event) {
            if ($.datepicker._curInst) {
                var $target = $(event.target), inst = $.datepicker._getInst($target[0]);
                ($target[0].id !== $.datepicker._mainDivId && 0 === $target.parents("#" + $.datepicker._mainDivId).length && !$target.hasClass($.datepicker.markerClassName) && !$target.closest("." + $.datepicker._triggerClass).length && $.datepicker._datepickerShowing && (!$.datepicker._inDialog || !$.blockUI) || $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst) && $.datepicker._hideDatepicker();
            }
        },
        /* Adjust one of the date sub-fields. */
        _adjustDate: function(id, offset, period) {
            var target = $(id), inst = this._getInst(target[0]);
            this._isDisabledDatepicker(target[0]) || (this._adjustInstDate(inst, offset + ("M" === period ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
            period), this._updateDatepicker(inst));
        },
        /* Action for current link. */
        _gotoToday: function(id) {
            var date, target = $(id), inst = this._getInst(target[0]);
            this._get(inst, "gotoCurrent") && inst.currentDay ? (inst.selectedDay = inst.currentDay, 
            inst.drawMonth = inst.selectedMonth = inst.currentMonth, inst.drawYear = inst.selectedYear = inst.currentYear) : (date = new Date(), 
            inst.selectedDay = date.getDate(), inst.drawMonth = inst.selectedMonth = date.getMonth(), 
            inst.drawYear = inst.selectedYear = date.getFullYear()), this._notifyChange(inst), 
            this._adjustDate(target);
        },
        /* Action for selecting a new month/year. */
        _selectMonthYear: function(id, select, period) {
            var target = $(id), inst = this._getInst(target[0]);
            inst["selected" + ("M" === period ? "Month" : "Year")] = inst["draw" + ("M" === period ? "Month" : "Year")] = parseInt(select.options[select.selectedIndex].value, 10), 
            this._notifyChange(inst), this._adjustDate(target);
        },
        /* Action for selecting a day. */
        _selectDay: function(id, month, year, td) {
            var inst, target = $(id);
            $(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0]) || (inst = this._getInst(target[0]), 
            inst.selectedDay = inst.currentDay = $("a", td).html(), inst.selectedMonth = inst.currentMonth = month, 
            inst.selectedYear = inst.currentYear = year, this._selectDate(id, this._formatDate(inst, inst.currentDay, inst.currentMonth, inst.currentYear)));
        },
        /* Erase the input field and hide the date picker. */
        _clearDate: function(id) {
            var target = $(id);
            this._selectDate(target, "");
        },
        /* Update the input field with the selected date. */
        _selectDate: function(id, dateStr) {
            var onSelect, target = $(id), inst = this._getInst(target[0]);
            dateStr = null != dateStr ? dateStr : this._formatDate(inst), inst.input && inst.input.val(dateStr), 
            this._updateAlternate(inst), onSelect = this._get(inst, "onSelect"), onSelect ? onSelect.apply(inst.input ? inst.input[0] : null, [ dateStr, inst ]) : inst.input && inst.input.trigger("change"), 
            inst.inline ? this._updateDatepicker(inst) : (this._hideDatepicker(), this._lastInput = inst.input[0], 
            "object" != typeof inst.input[0] && inst.input.focus(), this._lastInput = null);
        },
        /* Update any alternate field to synchronise with the main field. */
        _updateAlternate: function(inst) {
            var altFormat, date, dateStr, altField = this._get(inst, "altField");
            altField && (altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat"), 
            date = this._getDate(inst), dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst)), 
            $(altField).each(function() {
                $(this).val(dateStr);
            }));
        },
        /* Set as beforeShowDay function to prevent selection of weekends.
	 * @param  date  Date - the date to customise
	 * @return [boolean, string] - is this date selectable?, what is its CSS class?
	 */
        noWeekends: function(date) {
            var day = date.getDay();
            return [ day > 0 && 6 > day, "" ];
        },
        /* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	 * @param  date  Date - the date to get the week for
	 * @return  number - the number of the week within the year that contains this date
	 */
        iso8601Week: function(date) {
            var time, checkDate = new Date(date.getTime());
            // Find Thursday of this week starting on Monday
            // Compare with Jan 1
            return checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)), time = checkDate.getTime(), 
            checkDate.setMonth(0), checkDate.setDate(1), Math.floor(Math.round((time - checkDate) / 864e5) / 7) + 1;
        },
        /* Parse a string value into a date object.
	 * See formatDate below for the possible formats.
	 *
	 * @param  format string - the expected format of the date
	 * @param  value string - the date in the above format
	 * @param  settings Object - attributes include:
	 *					shortYearCutoff  number - the cutoff year for determining the century (optional)
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  Date - the extracted date value or null if value is blank
	 */
        parseDate: function(format, value, settings) {
            if (null == format || null == value) throw "Invalid arguments";
            if (value = "object" == typeof value ? value.toString() : value + "", "" === value) return null;
            var iFormat, dim, extra, date, iValue = 0, shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff, shortYearCutoff = "string" != typeof shortYearCutoffTemp ? shortYearCutoffTemp : new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10), dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames, year = -1, month = -1, day = -1, doy = -1, literal = !1, // Check whether a format character is doubled
            lookAhead = function(match) {
                var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                return matches && iFormat++, matches;
            }, // Extract a number from the string value
            getNumber = function(match) {
                var isDoubled = lookAhead(match), size = "@" === match ? 14 : "!" === match ? 20 : "y" === match && isDoubled ? 4 : "o" === match ? 3 : 2, minSize = "y" === match ? size : 1, digits = new RegExp("^\\d{" + minSize + "," + size + "}"), num = value.substring(iValue).match(digits);
                if (!num) throw "Missing number at position " + iValue;
                return iValue += num[0].length, parseInt(num[0], 10);
            }, // Extract a name from the string value and convert to an index
            getName = function(match, shortNames, longNames) {
                var index = -1, names = $.map(lookAhead(match) ? longNames : shortNames, function(v, k) {
                    return [ [ k, v ] ];
                }).sort(function(a, b) {
                    return -(a[1].length - b[1].length);
                });
                if ($.each(names, function(i, pair) {
                    var name = pair[1];
                    return value.substr(iValue, name.length).toLowerCase() === name.toLowerCase() ? (index = pair[0], 
                    iValue += name.length, !1) : void 0;
                }), -1 !== index) return index + 1;
                throw "Unknown name at position " + iValue;
            }, // Confirm that a literal character matches the string value
            checkLiteral = function() {
                if (value.charAt(iValue) !== format.charAt(iFormat)) throw "Unexpected literal at position " + iValue;
                iValue++;
            };
            for (iFormat = 0; iFormat < format.length; iFormat++) if (literal) "'" !== format.charAt(iFormat) || lookAhead("'") ? checkLiteral() : literal = !1; else switch (format.charAt(iFormat)) {
              case "d":
                day = getNumber("d");
                break;

              case "D":
                getName("D", dayNamesShort, dayNames);
                break;

              case "o":
                doy = getNumber("o");
                break;

              case "m":
                month = getNumber("m");
                break;

              case "M":
                month = getName("M", monthNamesShort, monthNames);
                break;

              case "y":
                year = getNumber("y");
                break;

              case "@":
                date = new Date(getNumber("@")), year = date.getFullYear(), month = date.getMonth() + 1, 
                day = date.getDate();
                break;

              case "!":
                date = new Date((getNumber("!") - this._ticksTo1970) / 1e4), year = date.getFullYear(), 
                month = date.getMonth() + 1, day = date.getDate();
                break;

              case "'":
                lookAhead("'") ? checkLiteral() : literal = !0;
                break;

              default:
                checkLiteral();
            }
            if (iValue < value.length && (extra = value.substr(iValue), !/^\s+/.test(extra))) throw "Extra/unparsed characters found in date: " + extra;
            if (-1 === year ? year = new Date().getFullYear() : 100 > year && (year += new Date().getFullYear() - new Date().getFullYear() % 100 + (shortYearCutoff >= year ? 0 : -100)), 
            doy > -1) for (month = 1, day = doy; ;) {
                if (dim = this._getDaysInMonth(year, month - 1), dim >= day) break;
                month++, day -= dim;
            }
            if (date = this._daylightSavingAdjust(new Date(year, month - 1, day)), date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) throw "Invalid date";
            return date;
        },
        /* Standard date formats. */
        ATOM: "yy-mm-dd",
        // RFC 3339 (ISO 8601)
        COOKIE: "D, dd M yy",
        ISO_8601: "yy-mm-dd",
        RFC_822: "D, d M y",
        RFC_850: "DD, dd-M-y",
        RFC_1036: "D, d M y",
        RFC_1123: "D, d M yy",
        RFC_2822: "D, d M yy",
        RSS: "D, d M y",
        // RFC 822
        TICKS: "!",
        TIMESTAMP: "@",
        W3C: "yy-mm-dd",
        // ISO 8601
        _ticksTo1970: 24 * (718685 + Math.floor(492.5) - Math.floor(19.7) + Math.floor(4.925)) * 60 * 60 * 1e7,
        /* Format a date object into a string value.
	 * The format can be combinations of the following:
	 * d  - day of month (no leading zero)
	 * dd - day of month (two digit)
	 * o  - day of year (no leading zeros)
	 * oo - day of year (three digit)
	 * D  - day name short
	 * DD - day name long
	 * m  - month of year (no leading zero)
	 * mm - month of year (two digit)
	 * M  - month name short
	 * MM - month name long
	 * y  - year (two digit)
	 * yy - year (four digit)
	 * @ - Unix timestamp (ms since 01/01/1970)
	 * ! - Windows ticks (100ns since 01/01/0001)
	 * "..." - literal text
	 * '' - single quote
	 *
	 * @param  format string - the desired format of the date
	 * @param  date Date - the date value to format
	 * @param  settings Object - attributes include:
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  string - the date in the above format
	 */
        formatDate: function(format, date, settings) {
            if (!date) return "";
            var iFormat, dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames, // Check whether a format character is doubled
            lookAhead = function(match) {
                var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                return matches && iFormat++, matches;
            }, // Format a number, with leading zero if necessary
            formatNumber = function(match, value, len) {
                var num = "" + value;
                if (lookAhead(match)) for (;num.length < len; ) num = "0" + num;
                return num;
            }, // Format a name, short or long as requested
            formatName = function(match, value, shortNames, longNames) {
                return lookAhead(match) ? longNames[value] : shortNames[value];
            }, output = "", literal = !1;
            if (date) for (iFormat = 0; iFormat < format.length; iFormat++) if (literal) "'" !== format.charAt(iFormat) || lookAhead("'") ? output += format.charAt(iFormat) : literal = !1; else switch (format.charAt(iFormat)) {
              case "d":
                output += formatNumber("d", date.getDate(), 2);
                break;

              case "D":
                output += formatName("D", date.getDay(), dayNamesShort, dayNames);
                break;

              case "o":
                output += formatNumber("o", Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 864e5), 3);
                break;

              case "m":
                output += formatNumber("m", date.getMonth() + 1, 2);
                break;

              case "M":
                output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
                break;

              case "y":
                output += lookAhead("y") ? date.getFullYear() : (date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100;
                break;

              case "@":
                output += date.getTime();
                break;

              case "!":
                output += 1e4 * date.getTime() + this._ticksTo1970;
                break;

              case "'":
                lookAhead("'") ? output += "'" : literal = !0;
                break;

              default:
                output += format.charAt(iFormat);
            }
            return output;
        },
        /* Extract all possible characters from the date format. */
        _possibleChars: function(format) {
            var iFormat, chars = "", literal = !1, // Check whether a format character is doubled
            lookAhead = function(match) {
                var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                return matches && iFormat++, matches;
            };
            for (iFormat = 0; iFormat < format.length; iFormat++) if (literal) "'" !== format.charAt(iFormat) || lookAhead("'") ? chars += format.charAt(iFormat) : literal = !1; else switch (format.charAt(iFormat)) {
              case "d":
              case "m":
              case "y":
              case "@":
                chars += "0123456789";
                break;

              case "D":
              case "M":
                return null;

              // Accept anything
                case "'":
                lookAhead("'") ? chars += "'" : literal = !0;
                break;

              default:
                chars += format.charAt(iFormat);
            }
            return chars;
        },
        /* Get a setting value, defaulting if necessary. */
        _get: function(inst, name) {
            return void 0 !== inst.settings[name] ? inst.settings[name] : this._defaults[name];
        },
        /* Parse existing date and initialise date picker. */
        _setDateFromField: function(inst, noDefault) {
            if (inst.input.val() !== inst.lastVal) {
                var dateFormat = this._get(inst, "dateFormat"), dates = inst.lastVal = inst.input ? inst.input.val() : null, defaultDate = this._getDefaultDate(inst), date = defaultDate, settings = this._getFormatConfig(inst);
                try {
                    date = this.parseDate(dateFormat, dates, settings) || defaultDate;
                } catch (event) {
                    dates = noDefault ? "" : dates;
                }
                inst.selectedDay = date.getDate(), inst.drawMonth = inst.selectedMonth = date.getMonth(), 
                inst.drawYear = inst.selectedYear = date.getFullYear(), inst.currentDay = dates ? date.getDate() : 0, 
                inst.currentMonth = dates ? date.getMonth() : 0, inst.currentYear = dates ? date.getFullYear() : 0, 
                this._adjustInstDate(inst);
            }
        },
        /* Retrieve the default date shown on opening. */
        _getDefaultDate: function(inst) {
            return this._restrictMinMax(inst, this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
        },
        /* A date may be specified as an exact value or a relative one. */
        _determineDate: function(inst, date, defaultDate) {
            var offsetNumeric = function(offset) {
                var date = new Date();
                return date.setDate(date.getDate() + offset), date;
            }, offsetString = function(offset) {
                try {
                    return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), offset, $.datepicker._getFormatConfig(inst));
                } catch (e) {}
                for (var date = (offset.toLowerCase().match(/^c/) ? $.datepicker._getDate(inst) : null) || new Date(), year = date.getFullYear(), month = date.getMonth(), day = date.getDate(), pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, matches = pattern.exec(offset); matches; ) {
                    switch (matches[2] || "d") {
                      case "d":
                      case "D":
                        day += parseInt(matches[1], 10);
                        break;

                      case "w":
                      case "W":
                        day += 7 * parseInt(matches[1], 10);
                        break;

                      case "m":
                      case "M":
                        month += parseInt(matches[1], 10), day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                        break;

                      case "y":
                      case "Y":
                        year += parseInt(matches[1], 10), day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                    }
                    matches = pattern.exec(offset);
                }
                return new Date(year, month, day);
            }, newDate = null == date || "" === date ? defaultDate : "string" == typeof date ? offsetString(date) : "number" == typeof date ? isNaN(date) ? defaultDate : offsetNumeric(date) : new Date(date.getTime());
            return newDate = newDate && "Invalid Date" === newDate.toString() ? defaultDate : newDate, 
            newDate && (newDate.setHours(0), newDate.setMinutes(0), newDate.setSeconds(0), newDate.setMilliseconds(0)), 
            this._daylightSavingAdjust(newDate);
        },
        /* Handle switch to/from daylight saving.
	 * Hours may be non-zero on daylight saving cut-over:
	 * > 12 when midnight changeover, but then cannot generate
	 * midnight datetime, so jump to 1AM, otherwise reset.
	 * @param  date  (Date) the date to check
	 * @return  (Date) the corrected date
	 */
        _daylightSavingAdjust: function(date) {
            return date ? (date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0), date) : null;
        },
        /* Set the date(s) directly. */
        _setDate: function(inst, date, noChange) {
            var clear = !date, origMonth = inst.selectedMonth, origYear = inst.selectedYear, newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
            inst.selectedDay = inst.currentDay = newDate.getDate(), inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth(), 
            inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear(), origMonth === inst.selectedMonth && origYear === inst.selectedYear || noChange || this._notifyChange(inst), 
            this._adjustInstDate(inst), inst.input && inst.input.val(clear ? "" : this._formatDate(inst));
        },
        /* Retrieve the date(s) directly. */
        _getDate: function(inst) {
            var startDate = !inst.currentYear || inst.input && "" === inst.input.val() ? null : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
            return startDate;
        },
        /* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 */
        _attachHandlers: function(inst) {
            var stepMonths = this._get(inst, "stepMonths"), id = "#" + inst.id.replace(/\\\\/g, "\\");
            inst.dpDiv.find("[data-handler]").map(function() {
                var handler = {
                    prev: function() {
                        $.datepicker._adjustDate(id, -stepMonths, "M");
                    },
                    next: function() {
                        $.datepicker._adjustDate(id, +stepMonths, "M");
                    },
                    hide: function() {
                        $.datepicker._hideDatepicker();
                    },
                    today: function() {
                        $.datepicker._gotoToday(id);
                    },
                    selectDay: function() {
                        return $.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this), 
                        !1;
                    },
                    selectMonth: function() {
                        return $.datepicker._selectMonthYear(id, this, "M"), !1;
                    },
                    selectYear: function() {
                        return $.datepicker._selectMonthYear(id, this, "Y"), !1;
                    }
                };
                $(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
            });
        },
        /* Generate the HTML for the current state of the date picker. */
        _generateHTML: function(inst) {
            var maxDraw, prevText, prev, nextText, next, currentText, gotoDate, controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin, monthNames, monthNamesShort, beforeShowDay, showOtherMonths, selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate, cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows, printDate, dRow, tbody, daySettings, otherMonth, unselectable, tempDate = new Date(), today = this._daylightSavingAdjust(new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
            isRTL = this._get(inst, "isRTL"), showButtonPanel = this._get(inst, "showButtonPanel"), hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"), navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"), numMonths = this._getNumberOfMonths(inst), showCurrentAtPos = this._get(inst, "showCurrentAtPos"), stepMonths = this._get(inst, "stepMonths"), isMultiMonth = 1 !== numMonths[0] || 1 !== numMonths[1], currentDate = this._daylightSavingAdjust(inst.currentDay ? new Date(inst.currentYear, inst.currentMonth, inst.currentDay) : new Date(9999, 9, 9)), minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), drawMonth = inst.drawMonth - showCurrentAtPos, drawYear = inst.drawYear;
            if (0 > drawMonth && (drawMonth += 12, drawYear--), maxDate) for (maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(), maxDate.getMonth() - numMonths[0] * numMonths[1] + 1, maxDate.getDate())), 
            maxDraw = minDate && minDate > maxDraw ? minDate : maxDraw; this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw; ) drawMonth--, 
            0 > drawMonth && (drawMonth = 11, drawYear--);
            for (inst.drawMonth = drawMonth, inst.drawYear = drawYear, prevText = this._get(inst, "prevText"), 
            prevText = navigationAsDateFormat ? this.formatDate(prevText, this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)), this._getFormatConfig(inst)) : prevText, 
            prev = this._canAdjustMonth(inst, -1, drawYear, drawMonth) ? "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" : hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>", 
            nextText = this._get(inst, "nextText"), nextText = navigationAsDateFormat ? this.formatDate(nextText, this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)), this._getFormatConfig(inst)) : nextText, 
            next = this._canAdjustMonth(inst, 1, drawYear, drawMonth) ? "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" : hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>", 
            currentText = this._get(inst, "currentText"), gotoDate = this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today, 
            currentText = navigationAsDateFormat ? this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)) : currentText, 
            controls = inst.inline ? "" : "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" + this._get(inst, "closeText") + "</button>", 
            buttonPanel = showButtonPanel ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") + (this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'>" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "", 
            firstDay = parseInt(this._get(inst, "firstDay"), 10), firstDay = isNaN(firstDay) ? 0 : firstDay, 
            showWeek = this._get(inst, "showWeek"), dayNames = this._get(inst, "dayNames"), 
            dayNamesMin = this._get(inst, "dayNamesMin"), monthNames = this._get(inst, "monthNames"), 
            monthNamesShort = this._get(inst, "monthNamesShort"), beforeShowDay = this._get(inst, "beforeShowDay"), 
            showOtherMonths = this._get(inst, "showOtherMonths"), selectOtherMonths = this._get(inst, "selectOtherMonths"), 
            defaultDate = this._getDefaultDate(inst), html = "", row = 0; row < numMonths[0]; row++) {
                for (group = "", this.maxRows = 4, col = 0; col < numMonths[1]; col++) {
                    if (selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay)), 
                    cornerClass = " ui-corner-all", calender = "", isMultiMonth) {
                        if (calender += "<div class='ui-datepicker-group", numMonths[1] > 1) switch (col) {
                          case 0:
                            calender += " ui-datepicker-group-first", cornerClass = " ui-corner-" + (isRTL ? "right" : "left");
                            break;

                          case numMonths[1] - 1:
                            calender += " ui-datepicker-group-last", cornerClass = " ui-corner-" + (isRTL ? "left" : "right");
                            break;

                          default:
                            calender += " ui-datepicker-group-middle", cornerClass = "";
                        }
                        calender += "'>";
                    }
                    for (calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" + (/all|left/.test(cornerClass) && 0 === row ? isRTL ? next : prev : "") + (/all|right/.test(cornerClass) && 0 === row ? isRTL ? prev : next : "") + this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
                    "</div><table class='ui-datepicker-calendar'><thead><tr>", thead = showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "", 
                    dow = 0; 7 > dow; dow++) day = (dow + firstDay) % 7, thead += "<th scope='col'" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + "><span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
                    for (calender += thead + "</tr></thead><tbody>", daysInMonth = this._getDaysInMonth(drawYear, drawMonth), 
                    drawYear === inst.selectedYear && drawMonth === inst.selectedMonth && (inst.selectedDay = Math.min(inst.selectedDay, daysInMonth)), 
                    leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7, curRows = Math.ceil((leadDays + daysInMonth) / 7), 
                    numRows = isMultiMonth && this.maxRows > curRows ? this.maxRows : curRows, this.maxRows = numRows, 
                    printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays)), 
                    dRow = 0; numRows > dRow; dRow++) {
                        for (calender += "<tr>", tbody = showWeek ? "<td class='ui-datepicker-week-col'>" + this._get(inst, "calculateWeek")(printDate) + "</td>" : "", 
                        dow = 0; 7 > dow; dow++) daySettings = beforeShowDay ? beforeShowDay.apply(inst.input ? inst.input[0] : null, [ printDate ]) : [ !0, "" ], 
                        otherMonth = printDate.getMonth() !== drawMonth, unselectable = otherMonth && !selectOtherMonths || !daySettings[0] || minDate && minDate > printDate || maxDate && printDate > maxDate, 
                        tbody += "<td class='" + ((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + (otherMonth ? " ui-datepicker-other-month" : "") + (printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent || defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ? " " + this._dayOverClass : "") + (unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "") + (otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + (printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + (printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + (otherMonth && !showOtherMonths || !daySettings[2] ? "" : " title='" + daySettings[2].replace(/'/g, "&#39;") + "'") + (unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + (otherMonth && !showOtherMonths ? "&#xa0;" : unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" + (printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") + (printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + (otherMonth ? " ui-priority-secondary" : "") + "' href='#'>" + printDate.getDate() + "</a>") + "</td>", 
                        printDate.setDate(printDate.getDate() + 1), printDate = this._daylightSavingAdjust(printDate);
                        calender += tbody + "</tr>";
                    }
                    drawMonth++, drawMonth > 11 && (drawMonth = 0, drawYear++), calender += "</tbody></table>" + (isMultiMonth ? "</div>" + (numMonths[0] > 0 && col === numMonths[1] - 1 ? "<div class='ui-datepicker-row-break'></div>" : "") : ""), 
                    group += calender;
                }
                html += group;
            }
            return html += buttonPanel, inst._keyEvent = !1, html;
        },
        /* Generate the month and year header. */
        _generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate, secondary, monthNames, monthNamesShort) {
            var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear, changeMonth = this._get(inst, "changeMonth"), changeYear = this._get(inst, "changeYear"), showMonthAfterYear = this._get(inst, "showMonthAfterYear"), html = "<div class='ui-datepicker-title'>", monthHtml = "";
            // month selection
            if (secondary || !changeMonth) monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>"; else {
                for (inMinYear = minDate && minDate.getFullYear() === drawYear, inMaxYear = maxDate && maxDate.getFullYear() === drawYear, 
                monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>", 
                month = 0; 12 > month; month++) (!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth()) && (monthHtml += "<option value='" + month + "'" + (month === drawMonth ? " selected='selected'" : "") + ">" + monthNamesShort[month] + "</option>");
                monthHtml += "</select>";
            }
            // year selection
            if (showMonthAfterYear || (html += monthHtml + (!secondary && changeMonth && changeYear ? "" : "&#xa0;")), 
            !inst.yearshtml) if (inst.yearshtml = "", secondary || !changeYear) html += "<span class='ui-datepicker-year'>" + drawYear + "</span>"; else {
                for (// determine range of years to display
                years = this._get(inst, "yearRange").split(":"), thisYear = new Date().getFullYear(), 
                determineYear = function(value) {
                    var year = value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) : value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) : parseInt(value, 10);
                    return isNaN(year) ? thisYear : year;
                }, year = determineYear(years[0]), endYear = Math.max(year, determineYear(years[1] || "")), 
                year = minDate ? Math.max(year, minDate.getFullYear()) : year, endYear = maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear, 
                inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>"; endYear >= year; year++) inst.yearshtml += "<option value='" + year + "'" + (year === drawYear ? " selected='selected'" : "") + ">" + year + "</option>";
                inst.yearshtml += "</select>", html += inst.yearshtml, inst.yearshtml = null;
            }
            // Close datepicker_header
            return html += this._get(inst, "yearSuffix"), showMonthAfterYear && (html += (!secondary && changeMonth && changeYear ? "" : "&#xa0;") + monthHtml), 
            html += "</div>";
        },
        /* Adjust one of the date sub-fields. */
        _adjustInstDate: function(inst, offset, period) {
            var year = inst.drawYear + ("Y" === period ? offset : 0), month = inst.drawMonth + ("M" === period ? offset : 0), day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + ("D" === period ? offset : 0), date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));
            inst.selectedDay = date.getDate(), inst.drawMonth = inst.selectedMonth = date.getMonth(), 
            inst.drawYear = inst.selectedYear = date.getFullYear(), ("M" === period || "Y" === period) && this._notifyChange(inst);
        },
        /* Ensure a date is within any min/max bounds. */
        _restrictMinMax: function(inst, date) {
            var minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), newDate = minDate && minDate > date ? minDate : date;
            return maxDate && newDate > maxDate ? maxDate : newDate;
        },
        /* Notify change of month/year. */
        _notifyChange: function(inst) {
            var onChange = this._get(inst, "onChangeMonthYear");
            onChange && onChange.apply(inst.input ? inst.input[0] : null, [ inst.selectedYear, inst.selectedMonth + 1, inst ]);
        },
        /* Determine the number of months to show. */
        _getNumberOfMonths: function(inst) {
            var numMonths = this._get(inst, "numberOfMonths");
            return null == numMonths ? [ 1, 1 ] : "number" == typeof numMonths ? [ 1, numMonths ] : numMonths;
        },
        /* Determine the current maximum date - ensure no time components are set. */
        _getMinMaxDate: function(inst, minMax) {
            return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
        },
        /* Find the number of days in a given month. */
        _getDaysInMonth: function(year, month) {
            return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
        },
        /* Find the day of the week of the first of a month. */
        _getFirstDayOfMonth: function(year, month) {
            return new Date(year, month, 1).getDay();
        },
        /* Determines if we should allow a "next/prev" month display change. */
        _canAdjustMonth: function(inst, offset, curYear, curMonth) {
            var numMonths = this._getNumberOfMonths(inst), date = this._daylightSavingAdjust(new Date(curYear, curMonth + (0 > offset ? offset : numMonths[0] * numMonths[1]), 1));
            return 0 > offset && date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth())), 
            this._isInRange(inst, date);
        },
        /* Is the given date in the accepted range? */
        _isInRange: function(inst, date) {
            var yearSplit, currentYear, minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), minYear = null, maxYear = null, years = this._get(inst, "yearRange");
            return years && (yearSplit = years.split(":"), currentYear = new Date().getFullYear(), 
            minYear = parseInt(yearSplit[0], 10), maxYear = parseInt(yearSplit[1], 10), yearSplit[0].match(/[+\-].*/) && (minYear += currentYear), 
            yearSplit[1].match(/[+\-].*/) && (maxYear += currentYear)), (!minDate || date.getTime() >= minDate.getTime()) && (!maxDate || date.getTime() <= maxDate.getTime()) && (!minYear || date.getFullYear() >= minYear) && (!maxYear || date.getFullYear() <= maxYear);
        },
        /* Provide the configuration settings for formatting/parsing. */
        _getFormatConfig: function(inst) {
            var shortYearCutoff = this._get(inst, "shortYearCutoff");
            return shortYearCutoff = "string" != typeof shortYearCutoff ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10), 
            {
                shortYearCutoff: shortYearCutoff,
                dayNamesShort: this._get(inst, "dayNamesShort"),
                dayNames: this._get(inst, "dayNames"),
                monthNamesShort: this._get(inst, "monthNamesShort"),
                monthNames: this._get(inst, "monthNames")
            };
        },
        /* Format the given date for display. */
        _formatDate: function(inst, day, month, year) {
            day || (inst.currentDay = inst.selectedDay, inst.currentMonth = inst.selectedMonth, 
            inst.currentYear = inst.selectedYear);
            var date = day ? "object" == typeof day ? day : this._daylightSavingAdjust(new Date(year, month, day)) : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
            return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
        }
    }), /* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
					Object - settings for attaching new datepicker functionality
   @return  jQuery object */
    $.fn.datepicker = function(options) {
        /* Verify an empty collection wasn't passed - Fixes #6976 */
        if (!this.length) return this;
        /* Initialise the date picker. */
        $.datepicker.initialized || ($(document).mousedown($.datepicker._checkExternalClick), 
        $.datepicker.initialized = !0), /* Append datepicker main container to body if not exist. */
        0 === $("#" + $.datepicker._mainDivId).length && $("body").append($.datepicker.dpDiv);
        var otherArgs = Array.prototype.slice.call(arguments, 1);
        return "string" != typeof options || "isDisabled" !== options && "getDate" !== options && "widget" !== options ? "option" === options && 2 === arguments.length && "string" == typeof arguments[1] ? $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [ this[0] ].concat(otherArgs)) : this.each(function() {
            "string" == typeof options ? $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [ this ].concat(otherArgs)) : $.datepicker._attachDatepicker(this, options);
        }) : $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [ this[0] ].concat(otherArgs));
    }, $.datepicker = new Datepicker(), // singleton instance
    $.datepicker.initialized = !1, $.datepicker.uuid = new Date().getTime(), $.datepicker.version = "1.11.4";
    $.datepicker;
    /*!
 * jQuery UI Draggable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/draggable/
 */
    $.widget("ui.draggable", $.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "drag",
        options: {
            addClasses: !0,
            appendTo: "parent",
            axis: !1,
            connectToSortable: !1,
            containment: !1,
            cursor: "auto",
            cursorAt: !1,
            grid: !1,
            handle: !1,
            helper: "original",
            iframeFix: !1,
            opacity: !1,
            refreshPositions: !1,
            revert: !1,
            revertDuration: 500,
            scope: "default",
            scroll: !0,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            snap: !1,
            snapMode: "both",
            snapTolerance: 20,
            stack: !1,
            zIndex: !1,
            // callbacks
            drag: null,
            start: null,
            stop: null
        },
        _create: function() {
            "original" === this.options.helper && this._setPositionRelative(), this.options.addClasses && this.element.addClass("ui-draggable"), 
            this.options.disabled && this.element.addClass("ui-draggable-disabled"), this._setHandleClassName(), 
            this._mouseInit();
        },
        _setOption: function(key, value) {
            this._super(key, value), "handle" === key && (this._removeHandleClassName(), this._setHandleClassName());
        },
        _destroy: function() {
            return (this.helper || this.element).is(".ui-draggable-dragging") ? void (this.destroyOnClear = !0) : (this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"), 
            this._removeHandleClassName(), void this._mouseDestroy());
        },
        _mouseCapture: function(event) {
            var o = this.options;
            // among others, prevent a drag on a resizable-handle
            // among others, prevent a drag on a resizable-handle
            //Quit if we're not on a valid handle
            return this._blurActiveElement(event), this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0 ? !1 : (this.handle = this._getHandle(event), 
            this.handle ? (this._blockFrames(o.iframeFix === !0 ? "iframe" : o.iframeFix), !0) : !1);
        },
        _blockFrames: function(selector) {
            this.iframeBlocks = this.document.find(selector).map(function() {
                var iframe = $(this);
                return $("<div>").css("position", "absolute").appendTo(iframe.parent()).outerWidth(iframe.outerWidth()).outerHeight(iframe.outerHeight()).offset(iframe.offset())[0];
            });
        },
        _unblockFrames: function() {
            this.iframeBlocks && (this.iframeBlocks.remove(), delete this.iframeBlocks);
        },
        _blurActiveElement: function(event) {
            var document = this.document[0];
            // Only need to blur if the event occurred on the draggable itself, see #10527
            if (this.handleElement.is(event.target)) // support: IE9
            // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
            try {
                // Support: IE9, IE10
                // If the <body> is blurred, IE will switch windows, see #9520
                document.activeElement && "body" !== document.activeElement.nodeName.toLowerCase() && // Blur any element that currently has focus, see #4261
                $(document.activeElement).blur();
            } catch (error) {}
        },
        _mouseStart: function(event) {
            var o = this.options;
            //Trigger event + callbacks
            //Create and append the visible helper
            //Cache the helper size
            //If ddmanager is used for droppables, set the global draggable
            /*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */
            //Cache the margins of the original element
            //Store the helper's css position
            //The element's absolute position on the page minus margins
            //Generate the original position
            //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
            //Set a containment if given in the options
            //Trigger event + callbacks
            //Recache the helper size
            //Prepare the droppable offsets
            // Reset helper's right/bottom css if they're set and set explicit width/height instead
            // as this prevents resizing of elements with right/bottom set (see #7772)
            //Execute the drag once - this causes the helper not to be visible before getting its correct position
            //If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
            return this.helper = this._createHelper(event), this.helper.addClass("ui-draggable-dragging"), 
            this._cacheHelperProportions(), $.ui.ddmanager && ($.ui.ddmanager.current = this), 
            this._cacheMargins(), this.cssPosition = this.helper.css("position"), this.scrollParent = this.helper.scrollParent(!0), 
            this.offsetParent = this.helper.offsetParent(), this.hasFixedAncestor = this.helper.parents().filter(function() {
                return "fixed" === $(this).css("position");
            }).length > 0, this.positionAbs = this.element.offset(), this._refreshOffsets(event), 
            this.originalPosition = this.position = this._generatePosition(event, !1), this.originalPageX = event.pageX, 
            this.originalPageY = event.pageY, o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt), 
            this._setContainment(), this._trigger("start", event) === !1 ? (this._clear(), !1) : (this._cacheHelperProportions(), 
            $.ui.ddmanager && !o.dropBehaviour && $.ui.ddmanager.prepareOffsets(this, event), 
            this._normalizeRightBottom(), this._mouseDrag(event, !0), $.ui.ddmanager && $.ui.ddmanager.dragStart(this, event), 
            !0);
        },
        _refreshOffsets: function(event) {
            this.offset = {
                top: this.positionAbs.top - this.margins.top,
                left: this.positionAbs.left - this.margins.left,
                scroll: !1,
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            }, this.offset.click = {
                left: event.pageX - this.offset.left,
                top: event.pageY - this.offset.top
            };
        },
        _mouseDrag: function(event, noPropagation) {
            //Call plugins and callbacks and use the resulting position if something is returned
            if (// reset any necessary cached properties (see #5009)
            this.hasFixedAncestor && (this.offset.parent = this._getParentOffset()), //Compute the helpers position
            this.position = this._generatePosition(event, !0), this.positionAbs = this._convertPositionTo("absolute"), 
            !noPropagation) {
                var ui = this._uiHash();
                if (this._trigger("drag", event, ui) === !1) return this._mouseUp({}), !1;
                this.position = ui.position;
            }
            return this.helper[0].style.left = this.position.left + "px", this.helper[0].style.top = this.position.top + "px", 
            $.ui.ddmanager && $.ui.ddmanager.drag(this, event), !1;
        },
        _mouseStop: function(event) {
            //If we are using droppables, inform the manager about the drop
            var that = this, dropped = !1;
            //if a drop comes from outside (a sortable)
            return $.ui.ddmanager && !this.options.dropBehaviour && (dropped = $.ui.ddmanager.drop(this, event)), 
            this.dropped && (dropped = this.dropped, this.dropped = !1), "invalid" === this.options.revert && !dropped || "valid" === this.options.revert && dropped || this.options.revert === !0 || $.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped) ? $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
                that._trigger("stop", event) !== !1 && that._clear();
            }) : this._trigger("stop", event) !== !1 && this._clear(), !1;
        },
        _mouseUp: function(event) {
            //If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
            // Only need to focus if the event occurred on the draggable itself, see #10527
            // The interaction is over; whether or not the click resulted in a drag, focus the element
            return this._unblockFrames(), $.ui.ddmanager && $.ui.ddmanager.dragStop(this, event), 
            this.handleElement.is(event.target) && this.element.focus(), $.ui.mouse.prototype._mouseUp.call(this, event);
        },
        cancel: function() {
            return this.helper.is(".ui-draggable-dragging") ? this._mouseUp({}) : this._clear(), 
            this;
        },
        _getHandle: function(event) {
            return this.options.handle ? !!$(event.target).closest(this.element.find(this.options.handle)).length : !0;
        },
        _setHandleClassName: function() {
            this.handleElement = this.options.handle ? this.element.find(this.options.handle) : this.element, 
            this.handleElement.addClass("ui-draggable-handle");
        },
        _removeHandleClassName: function() {
            this.handleElement.removeClass("ui-draggable-handle");
        },
        _createHelper: function(event) {
            var o = this.options, helperIsFunction = $.isFunction(o.helper), helper = helperIsFunction ? $(o.helper.apply(this.element[0], [ event ])) : "clone" === o.helper ? this.element.clone().removeAttr("id") : this.element;
            // http://bugs.jqueryui.com/ticket/9446
            // a helper function can return the original element
            // which wouldn't have been set to relative in _create
            return helper.parents("body").length || helper.appendTo("parent" === o.appendTo ? this.element[0].parentNode : o.appendTo), 
            helperIsFunction && helper[0] === this.element[0] && this._setPositionRelative(), 
            helper[0] === this.element[0] || /(fixed|absolute)/.test(helper.css("position")) || helper.css("position", "absolute"), 
            helper;
        },
        _setPositionRelative: function() {
            /^(?:r|a|f)/.test(this.element.css("position")) || (this.element[0].style.position = "relative");
        },
        _adjustOffsetFromHelper: function(obj) {
            "string" == typeof obj && (obj = obj.split(" ")), $.isArray(obj) && (obj = {
                left: +obj[0],
                top: +obj[1] || 0
            }), "left" in obj && (this.offset.click.left = obj.left + this.margins.left), "right" in obj && (this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left), 
            "top" in obj && (this.offset.click.top = obj.top + this.margins.top), "bottom" in obj && (this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top);
        },
        _isRootNode: function(element) {
            return /(html|body)/i.test(element.tagName) || element === this.document[0];
        },
        _getParentOffset: function() {
            //Get the offsetParent and cache its position
            var po = this.offsetParent.offset(), document = this.document[0];
            // This is a special case where we need to modify a offset calculated on start, since the following happened:
            // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
            // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
            //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
            return "absolute" === this.cssPosition && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]) && (po.left += this.scrollParent.scrollLeft(), 
            po.top += this.scrollParent.scrollTop()), this._isRootNode(this.offsetParent[0]) && (po = {
                top: 0,
                left: 0
            }), {
                top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            };
        },
        _getRelativeOffset: function() {
            if ("relative" !== this.cssPosition) return {
                top: 0,
                left: 0
            };
            var p = this.element.position(), scrollIsRootNode = this._isRootNode(this.scrollParent[0]);
            return {
                top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + (scrollIsRootNode ? 0 : this.scrollParent.scrollTop()),
                left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + (scrollIsRootNode ? 0 : this.scrollParent.scrollLeft())
            };
        },
        _cacheMargins: function() {
            this.margins = {
                left: parseInt(this.element.css("marginLeft"), 10) || 0,
                top: parseInt(this.element.css("marginTop"), 10) || 0,
                right: parseInt(this.element.css("marginRight"), 10) || 0,
                bottom: parseInt(this.element.css("marginBottom"), 10) || 0
            };
        },
        _cacheHelperProportions: function() {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
        },
        _setContainment: function() {
            var isUserScrollable, c, ce, o = this.options, document = this.document[0];
            return this.relativeContainer = null, o.containment ? "window" === o.containment ? void (this.containment = [ $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, $(window).scrollLeft() + $(window).width() - this.helperProportions.width - this.margins.left, $(window).scrollTop() + ($(window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ]) : "document" === o.containment ? void (this.containment = [ 0, 0, $(document).width() - this.helperProportions.width - this.margins.left, ($(document).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ]) : o.containment.constructor === Array ? void (this.containment = o.containment) : ("parent" === o.containment && (o.containment = this.helper[0].parentNode), 
            c = $(o.containment), ce = c[0], void (ce && (isUserScrollable = /(scroll|auto)/.test(c.css("overflow")), 
            this.containment = [ (parseInt(c.css("borderLeftWidth"), 10) || 0) + (parseInt(c.css("paddingLeft"), 10) || 0), (parseInt(c.css("borderTopWidth"), 10) || 0) + (parseInt(c.css("paddingTop"), 10) || 0), (isUserScrollable ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt(c.css("borderRightWidth"), 10) || 0) - (parseInt(c.css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (isUserScrollable ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt(c.css("borderBottomWidth"), 10) || 0) - (parseInt(c.css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom ], 
            this.relativeContainer = c))) : void (this.containment = null);
        },
        _convertPositionTo: function(d, pos) {
            pos || (pos = this.position);
            var mod = "absolute" === d ? 1 : -1, scrollIsRootNode = this._isRootNode(this.scrollParent[0]);
            return {
                top: pos.top + // The absolute mouse position
                this.offset.relative.top * mod + // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.parent.top * mod - // The offsetParent's offset without borders (offset + border)
                ("fixed" === this.cssPosition ? -this.offset.scroll.top : scrollIsRootNode ? 0 : this.offset.scroll.top) * mod,
                left: pos.left + // The absolute mouse position
                this.offset.relative.left * mod + // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.parent.left * mod - // The offsetParent's offset without borders (offset + border)
                ("fixed" === this.cssPosition ? -this.offset.scroll.left : scrollIsRootNode ? 0 : this.offset.scroll.left) * mod
            };
        },
        _generatePosition: function(event, constrainPosition) {
            var containment, co, top, left, o = this.options, scrollIsRootNode = this._isRootNode(this.scrollParent[0]), pageX = event.pageX, pageY = event.pageY;
            // Cache the scroll
            /*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */
            // If we are not dragging yet, we won't check for options
            //Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
            return scrollIsRootNode && this.offset.scroll || (this.offset.scroll = {
                top: this.scrollParent.scrollTop(),
                left: this.scrollParent.scrollLeft()
            }), constrainPosition && (this.containment && (this.relativeContainer ? (co = this.relativeContainer.offset(), 
            containment = [ this.containment[0] + co.left, this.containment[1] + co.top, this.containment[2] + co.left, this.containment[3] + co.top ]) : containment = this.containment, 
            event.pageX - this.offset.click.left < containment[0] && (pageX = containment[0] + this.offset.click.left), 
            event.pageY - this.offset.click.top < containment[1] && (pageY = containment[1] + this.offset.click.top), 
            event.pageX - this.offset.click.left > containment[2] && (pageX = containment[2] + this.offset.click.left), 
            event.pageY - this.offset.click.top > containment[3] && (pageY = containment[3] + this.offset.click.top)), 
            o.grid && (top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY, 
            pageY = containment ? top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3] ? top : top - this.offset.click.top >= containment[1] ? top - o.grid[1] : top + o.grid[1] : top, 
            left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX, 
            pageX = containment ? left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2] ? left : left - this.offset.click.left >= containment[0] ? left - o.grid[0] : left + o.grid[0] : left), 
            "y" === o.axis && (pageX = this.originalPageX), "x" === o.axis && (pageY = this.originalPageY)), 
            {
                top: pageY - // The absolute mouse position
                this.offset.click.top - // Click offset (relative to the element)
                this.offset.relative.top - // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.parent.top + (// The offsetParent's offset without borders (offset + border)
                "fixed" === this.cssPosition ? -this.offset.scroll.top : scrollIsRootNode ? 0 : this.offset.scroll.top),
                left: pageX - // The absolute mouse position
                this.offset.click.left - // Click offset (relative to the element)
                this.offset.relative.left - // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.parent.left + (// The offsetParent's offset without borders (offset + border)
                "fixed" === this.cssPosition ? -this.offset.scroll.left : scrollIsRootNode ? 0 : this.offset.scroll.left)
            };
        },
        _clear: function() {
            this.helper.removeClass("ui-draggable-dragging"), this.helper[0] === this.element[0] || this.cancelHelperRemoval || this.helper.remove(), 
            this.helper = null, this.cancelHelperRemoval = !1, this.destroyOnClear && this.destroy();
        },
        _normalizeRightBottom: function() {
            "y" !== this.options.axis && "auto" !== this.helper.css("right") && (this.helper.width(this.helper.width()), 
            this.helper.css("right", "auto")), "x" !== this.options.axis && "auto" !== this.helper.css("bottom") && (this.helper.height(this.helper.height()), 
            this.helper.css("bottom", "auto"));
        },
        // From now on bulk stuff - mainly helpers
        _trigger: function(type, event, ui) {
            // Absolute position and offset (see #6884 ) have to be recalculated after plugins
            return ui = ui || this._uiHash(), $.ui.plugin.call(this, type, [ event, ui, this ], !0), 
            /^(drag|start|stop)/.test(type) && (this.positionAbs = this._convertPositionTo("absolute"), 
            ui.offset = this.positionAbs), $.Widget.prototype._trigger.call(this, type, event, ui);
        },
        plugins: {},
        _uiHash: function() {
            return {
                helper: this.helper,
                position: this.position,
                originalPosition: this.originalPosition,
                offset: this.positionAbs
            };
        }
    }), $.ui.plugin.add("draggable", "connectToSortable", {
        start: function(event, ui, draggable) {
            var uiSortable = $.extend({}, ui, {
                item: draggable.element
            });
            draggable.sortables = [], $(draggable.options.connectToSortable).each(function() {
                var sortable = $(this).sortable("instance");
                sortable && !sortable.options.disabled && (draggable.sortables.push(sortable), // refreshPositions is called at drag start to refresh the containerCache
                // which is used in drag. This ensures it's initialized and synchronized
                // with any changes that might have happened on the page since initialization.
                sortable.refreshPositions(), sortable._trigger("activate", event, uiSortable));
            });
        },
        stop: function(event, ui, draggable) {
            var uiSortable = $.extend({}, ui, {
                item: draggable.element
            });
            draggable.cancelHelperRemoval = !1, $.each(draggable.sortables, function() {
                var sortable = this;
                sortable.isOver ? (sortable.isOver = 0, // Allow this sortable to handle removing the helper
                draggable.cancelHelperRemoval = !0, sortable.cancelHelperRemoval = !1, // Use _storedCSS To restore properties in the sortable,
                // as this also handles revert (#9675) since the draggable
                // may have modified them in unexpected ways (#8809)
                sortable._storedCSS = {
                    position: sortable.placeholder.css("position"),
                    top: sortable.placeholder.css("top"),
                    left: sortable.placeholder.css("left")
                }, sortable._mouseStop(event), // Once drag has ended, the sortable should return to using
                // its original helper, not the shared helper from draggable
                sortable.options.helper = sortable.options._helper) : (// Prevent this Sortable from removing the helper.
                // However, don't set the draggable to remove the helper
                // either as another connected Sortable may yet handle the removal.
                sortable.cancelHelperRemoval = !0, sortable._trigger("deactivate", event, uiSortable));
            });
        },
        drag: function(event, ui, draggable) {
            $.each(draggable.sortables, function() {
                var innermostIntersecting = !1, sortable = this;
                // Copy over variables that sortable's _intersectsWith uses
                sortable.positionAbs = draggable.positionAbs, sortable.helperProportions = draggable.helperProportions, 
                sortable.offset.click = draggable.offset.click, sortable._intersectsWith(sortable.containerCache) && (innermostIntersecting = !0, 
                $.each(draggable.sortables, function() {
                    return this.positionAbs = draggable.positionAbs, this.helperProportions = draggable.helperProportions, 
                    this.offset.click = draggable.offset.click, this !== sortable && this._intersectsWith(this.containerCache) && $.contains(sortable.element[0], this.element[0]) && (innermostIntersecting = !1), 
                    innermostIntersecting;
                })), innermostIntersecting ? (// If it intersects, we use a little isOver variable and set it once,
                // so that the move-in stuff gets fired only once.
                sortable.isOver || (sortable.isOver = 1, // Store draggable's parent in case we need to reappend to it later.
                draggable._parent = ui.helper.parent(), sortable.currentItem = ui.helper.appendTo(sortable.element).data("ui-sortable-item", !0), 
                // Store helper option to later restore it
                sortable.options._helper = sortable.options.helper, sortable.options.helper = function() {
                    return ui.helper[0];
                }, // Fire the start events of the sortable with our passed browser event,
                // and our own helper (so it doesn't create a new one)
                event.target = sortable.currentItem[0], sortable._mouseCapture(event, !0), sortable._mouseStart(event, !0, !0), 
                // Because the browser event is way off the new appended portlet,
                // modify necessary variables to reflect the changes
                sortable.offset.click.top = draggable.offset.click.top, sortable.offset.click.left = draggable.offset.click.left, 
                sortable.offset.parent.left -= draggable.offset.parent.left - sortable.offset.parent.left, 
                sortable.offset.parent.top -= draggable.offset.parent.top - sortable.offset.parent.top, 
                draggable._trigger("toSortable", event), // Inform draggable that the helper is in a valid drop zone,
                // used solely in the revert option to handle "valid/invalid".
                draggable.dropped = sortable.element, // Need to refreshPositions of all sortables in the case that
                // adding to one sortable changes the location of the other sortables (#9675)
                $.each(draggable.sortables, function() {
                    this.refreshPositions();
                }), // hack so receive/update callbacks work (mostly)
                draggable.currentItem = draggable.element, sortable.fromOutside = draggable), sortable.currentItem && (sortable._mouseDrag(event), 
                // Copy the sortable's position because the draggable's can potentially reflect
                // a relative position, while sortable is always absolute, which the dragged
                // element has now become. (#8809)
                ui.position = sortable.position)) : // If it doesn't intersect with the sortable, and it intersected before,
                // we fake the drag stop of the sortable, but make sure it doesn't remove
                // the helper by using cancelHelperRemoval.
                sortable.isOver && (sortable.isOver = 0, sortable.cancelHelperRemoval = !0, // Calling sortable's mouseStop would trigger a revert,
                // so revert must be temporarily false until after mouseStop is called.
                sortable.options._revert = sortable.options.revert, sortable.options.revert = !1, 
                sortable._trigger("out", event, sortable._uiHash(sortable)), sortable._mouseStop(event, !0), 
                // restore sortable behaviors that were modfied
                // when the draggable entered the sortable area (#9481)
                sortable.options.revert = sortable.options._revert, sortable.options.helper = sortable.options._helper, 
                sortable.placeholder && sortable.placeholder.remove(), // Restore and recalculate the draggable's offset considering the sortable
                // may have modified them in unexpected ways. (#8809, #10669)
                ui.helper.appendTo(draggable._parent), draggable._refreshOffsets(event), ui.position = draggable._generatePosition(event, !0), 
                draggable._trigger("fromSortable", event), // Inform draggable that the helper is no longer in a valid drop zone
                draggable.dropped = !1, // Need to refreshPositions of all sortables just in case removing
                // from one sortable changes the location of other sortables (#9675)
                $.each(draggable.sortables, function() {
                    this.refreshPositions();
                }));
            });
        }
    }), $.ui.plugin.add("draggable", "cursor", {
        start: function(event, ui, instance) {
            var t = $("body"), o = instance.options;
            t.css("cursor") && (o._cursor = t.css("cursor")), t.css("cursor", o.cursor);
        },
        stop: function(event, ui, instance) {
            var o = instance.options;
            o._cursor && $("body").css("cursor", o._cursor);
        }
    }), $.ui.plugin.add("draggable", "opacity", {
        start: function(event, ui, instance) {
            var t = $(ui.helper), o = instance.options;
            t.css("opacity") && (o._opacity = t.css("opacity")), t.css("opacity", o.opacity);
        },
        stop: function(event, ui, instance) {
            var o = instance.options;
            o._opacity && $(ui.helper).css("opacity", o._opacity);
        }
    }), $.ui.plugin.add("draggable", "scroll", {
        start: function(event, ui, i) {
            i.scrollParentNotHidden || (i.scrollParentNotHidden = i.helper.scrollParent(!1)), 
            i.scrollParentNotHidden[0] !== i.document[0] && "HTML" !== i.scrollParentNotHidden[0].tagName && (i.overflowOffset = i.scrollParentNotHidden.offset());
        },
        drag: function(event, ui, i) {
            var o = i.options, scrolled = !1, scrollParent = i.scrollParentNotHidden[0], document = i.document[0];
            scrollParent !== document && "HTML" !== scrollParent.tagName ? (o.axis && "x" === o.axis || (i.overflowOffset.top + scrollParent.offsetHeight - event.pageY < o.scrollSensitivity ? scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed : event.pageY - i.overflowOffset.top < o.scrollSensitivity && (scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed)), 
            o.axis && "y" === o.axis || (i.overflowOffset.left + scrollParent.offsetWidth - event.pageX < o.scrollSensitivity ? scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed : event.pageX - i.overflowOffset.left < o.scrollSensitivity && (scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed))) : (o.axis && "x" === o.axis || (event.pageY - $(document).scrollTop() < o.scrollSensitivity ? scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed) : $(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity && (scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed))), 
            o.axis && "y" === o.axis || (event.pageX - $(document).scrollLeft() < o.scrollSensitivity ? scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed) : $(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity && (scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed)))), 
            scrolled !== !1 && $.ui.ddmanager && !o.dropBehaviour && $.ui.ddmanager.prepareOffsets(i, event);
        }
    }), $.ui.plugin.add("draggable", "snap", {
        start: function(event, ui, i) {
            var o = i.options;
            i.snapElements = [], $(o.snap.constructor !== String ? o.snap.items || ":data(ui-draggable)" : o.snap).each(function() {
                var $t = $(this), $o = $t.offset();
                this !== i.element[0] && i.snapElements.push({
                    item: this,
                    width: $t.outerWidth(),
                    height: $t.outerHeight(),
                    top: $o.top,
                    left: $o.left
                });
            });
        },
        drag: function(event, ui, inst) {
            var ts, bs, ls, rs, l, r, t, b, i, first, o = inst.options, d = o.snapTolerance, x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width, y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;
            for (i = inst.snapElements.length - 1; i >= 0; i--) l = inst.snapElements[i].left - inst.margins.left, 
            r = l + inst.snapElements[i].width, t = inst.snapElements[i].top - inst.margins.top, 
            b = t + inst.snapElements[i].height, l - d > x2 || x1 > r + d || t - d > y2 || y1 > b + d || !$.contains(inst.snapElements[i].item.ownerDocument, inst.snapElements[i].item) ? (inst.snapElements[i].snapping && inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), {
                snapItem: inst.snapElements[i].item
            })), inst.snapElements[i].snapping = !1) : ("inner" !== o.snapMode && (ts = Math.abs(t - y2) <= d, 
            bs = Math.abs(b - y1) <= d, ls = Math.abs(l - x2) <= d, rs = Math.abs(r - x1) <= d, 
            ts && (ui.position.top = inst._convertPositionTo("relative", {
                top: t - inst.helperProportions.height,
                left: 0
            }).top), bs && (ui.position.top = inst._convertPositionTo("relative", {
                top: b,
                left: 0
            }).top), ls && (ui.position.left = inst._convertPositionTo("relative", {
                top: 0,
                left: l - inst.helperProportions.width
            }).left), rs && (ui.position.left = inst._convertPositionTo("relative", {
                top: 0,
                left: r
            }).left)), first = ts || bs || ls || rs, "outer" !== o.snapMode && (ts = Math.abs(t - y1) <= d, 
            bs = Math.abs(b - y2) <= d, ls = Math.abs(l - x1) <= d, rs = Math.abs(r - x2) <= d, 
            ts && (ui.position.top = inst._convertPositionTo("relative", {
                top: t,
                left: 0
            }).top), bs && (ui.position.top = inst._convertPositionTo("relative", {
                top: b - inst.helperProportions.height,
                left: 0
            }).top), ls && (ui.position.left = inst._convertPositionTo("relative", {
                top: 0,
                left: l
            }).left), rs && (ui.position.left = inst._convertPositionTo("relative", {
                top: 0,
                left: r - inst.helperProportions.width
            }).left)), !inst.snapElements[i].snapping && (ts || bs || ls || rs || first) && inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), {
                snapItem: inst.snapElements[i].item
            })), inst.snapElements[i].snapping = ts || bs || ls || rs || first);
        }
    }), $.ui.plugin.add("draggable", "stack", {
        start: function(event, ui, instance) {
            var min, o = instance.options, group = $.makeArray($(o.stack)).sort(function(a, b) {
                return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);
            });
            group.length && (min = parseInt($(group[0]).css("zIndex"), 10) || 0, $(group).each(function(i) {
                $(this).css("zIndex", min + i);
            }), this.css("zIndex", min + group.length));
        }
    }), $.ui.plugin.add("draggable", "zIndex", {
        start: function(event, ui, instance) {
            var t = $(ui.helper), o = instance.options;
            t.css("zIndex") && (o._zIndex = t.css("zIndex")), t.css("zIndex", o.zIndex);
        },
        stop: function(event, ui, instance) {
            var o = instance.options;
            o._zIndex && $(ui.helper).css("zIndex", o._zIndex);
        }
    });
    $.ui.draggable;
    /*!
 * jQuery UI Resizable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/resizable/
 */
    $.widget("ui.resizable", $.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "resize",
        options: {
            alsoResize: !1,
            animate: !1,
            animateDuration: "slow",
            animateEasing: "swing",
            aspectRatio: !1,
            autoHide: !1,
            containment: !1,
            ghost: !1,
            grid: !1,
            handles: "e,s,se",
            helper: !1,
            maxHeight: null,
            maxWidth: null,
            minHeight: 10,
            minWidth: 10,
            // See #7960
            zIndex: 90,
            // callbacks
            resize: null,
            start: null,
            stop: null
        },
        _num: function(value) {
            return parseInt(value, 10) || 0;
        },
        _isNumber: function(value) {
            return !isNaN(parseInt(value, 10));
        },
        _hasScroll: function(el, a) {
            if ("hidden" === $(el).css("overflow")) return !1;
            var scroll = a && "left" === a ? "scrollLeft" : "scrollTop", has = !1;
            // TODO: determine which cases actually cause this to happen
            // if the element doesn't have the scroll set, see if it's possible to
            // set the scroll
            return el[scroll] > 0 ? !0 : (el[scroll] = 1, has = el[scroll] > 0, el[scroll] = 0, 
            has);
        },
        _create: function() {
            var n, i, handle, axis, hname, that = this, o = this.options;
            if (this.element.addClass("ui-resizable"), $.extend(this, {
                _aspectRatio: !!o.aspectRatio,
                aspectRatio: o.aspectRatio,
                originalElement: this.element,
                _proportionallyResizeElements: [],
                _helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
            }), // Wrap the element if it cannot hold child nodes
            this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i) && (this.element.wrap($("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
                position: this.element.css("position"),
                width: this.element.outerWidth(),
                height: this.element.outerHeight(),
                top: this.element.css("top"),
                left: this.element.css("left")
            })), this.element = this.element.parent().data("ui-resizable", this.element.resizable("instance")), 
            this.elementIsWrapper = !0, this.element.css({
                marginLeft: this.originalElement.css("marginLeft"),
                marginTop: this.originalElement.css("marginTop"),
                marginRight: this.originalElement.css("marginRight"),
                marginBottom: this.originalElement.css("marginBottom")
            }), this.originalElement.css({
                marginLeft: 0,
                marginTop: 0,
                marginRight: 0,
                marginBottom: 0
            }), // support: Safari
            // Prevent Safari textarea resize
            this.originalResizeStyle = this.originalElement.css("resize"), this.originalElement.css("resize", "none"), 
            this._proportionallyResizeElements.push(this.originalElement.css({
                position: "static",
                zoom: 1,
                display: "block"
            })), // support: IE9
            // avoid IE jump (hard set the margin)
            this.originalElement.css({
                margin: this.originalElement.css("margin")
            }), this._proportionallyResize()), this.handles = o.handles || ($(".ui-resizable-handle", this.element).length ? {
                n: ".ui-resizable-n",
                e: ".ui-resizable-e",
                s: ".ui-resizable-s",
                w: ".ui-resizable-w",
                se: ".ui-resizable-se",
                sw: ".ui-resizable-sw",
                ne: ".ui-resizable-ne",
                nw: ".ui-resizable-nw"
            } : "e,s,se"), this._handles = $(), this.handles.constructor === String) for ("all" === this.handles && (this.handles = "n,e,s,w,se,sw,ne,nw"), 
            n = this.handles.split(","), this.handles = {}, i = 0; i < n.length; i++) handle = $.trim(n[i]), 
            hname = "ui-resizable-" + handle, axis = $("<div class='ui-resizable-handle " + hname + "'></div>"), 
            axis.css({
                zIndex: o.zIndex
            }), "se" === handle && axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se"), this.handles[handle] = ".ui-resizable-" + handle, 
            this.element.append(axis);
            this._renderAxis = function(target) {
                var i, axis, padPos, padWrapper;
                target = target || this.element;
                for (i in this.handles) this.handles[i].constructor === String ? this.handles[i] = this.element.children(this.handles[i]).first().show() : (this.handles[i].jquery || this.handles[i].nodeType) && (this.handles[i] = $(this.handles[i]), 
                this._on(this.handles[i], {
                    mousedown: that._mouseDown
                })), this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i) && (axis = $(this.handles[i], this.element), 
                padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth(), 
                padPos = [ "padding", /ne|nw|n/.test(i) ? "Top" : /se|sw|s/.test(i) ? "Bottom" : /^e$/.test(i) ? "Right" : "Left" ].join(""), 
                target.css(padPos, padWrapper), this._proportionallyResize()), this._handles = this._handles.add(this.handles[i]);
            }, // TODO: make renderAxis a prototype function
            this._renderAxis(this.element), this._handles = this._handles.add(this.element.find(".ui-resizable-handle")), 
            this._handles.disableSelection(), this._handles.mouseover(function() {
                that.resizing || (this.className && (axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)), 
                that.axis = axis && axis[1] ? axis[1] : "se");
            }), o.autoHide && (this._handles.hide(), $(this.element).addClass("ui-resizable-autohide").mouseenter(function() {
                o.disabled || ($(this).removeClass("ui-resizable-autohide"), that._handles.show());
            }).mouseleave(function() {
                o.disabled || that.resizing || ($(this).addClass("ui-resizable-autohide"), that._handles.hide());
            })), this._mouseInit();
        },
        _destroy: function() {
            this._mouseDestroy();
            var wrapper, _destroy = function(exp) {
                $(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove();
            };
            // TODO: Unwrap at same DOM position
            return this.elementIsWrapper && (_destroy(this.element), wrapper = this.element, 
            this.originalElement.css({
                position: wrapper.css("position"),
                width: wrapper.outerWidth(),
                height: wrapper.outerHeight(),
                top: wrapper.css("top"),
                left: wrapper.css("left")
            }).insertAfter(wrapper), wrapper.remove()), this.originalElement.css("resize", this.originalResizeStyle), 
            _destroy(this.originalElement), this;
        },
        _mouseCapture: function(event) {
            var i, handle, capture = !1;
            for (i in this.handles) handle = $(this.handles[i])[0], (handle === event.target || $.contains(handle, event.target)) && (capture = !0);
            return !this.options.disabled && capture;
        },
        _mouseStart: function(event) {
            var curleft, curtop, cursor, o = this.options, el = this.element;
            return this.resizing = !0, this._renderProxy(), curleft = this._num(this.helper.css("left")), 
            curtop = this._num(this.helper.css("top")), o.containment && (curleft += $(o.containment).scrollLeft() || 0, 
            curtop += $(o.containment).scrollTop() || 0), this.offset = this.helper.offset(), 
            this.position = {
                left: curleft,
                top: curtop
            }, this.size = this._helper ? {
                width: this.helper.width(),
                height: this.helper.height()
            } : {
                width: el.width(),
                height: el.height()
            }, this.originalSize = this._helper ? {
                width: el.outerWidth(),
                height: el.outerHeight()
            } : {
                width: el.width(),
                height: el.height()
            }, this.sizeDiff = {
                width: el.outerWidth() - el.width(),
                height: el.outerHeight() - el.height()
            }, this.originalPosition = {
                left: curleft,
                top: curtop
            }, this.originalMousePosition = {
                left: event.pageX,
                top: event.pageY
            }, this.aspectRatio = "number" == typeof o.aspectRatio ? o.aspectRatio : this.originalSize.width / this.originalSize.height || 1, 
            cursor = $(".ui-resizable-" + this.axis).css("cursor"), $("body").css("cursor", "auto" === cursor ? this.axis + "-resize" : cursor), 
            el.addClass("ui-resizable-resizing"), this._propagate("start", event), !0;
        },
        _mouseDrag: function(event) {
            var data, props, smp = this.originalMousePosition, a = this.axis, dx = event.pageX - smp.left || 0, dy = event.pageY - smp.top || 0, trigger = this._change[a];
            return this._updatePrevProperties(), trigger ? (data = trigger.apply(this, [ event, dx, dy ]), 
            this._updateVirtualBoundaries(event.shiftKey), (this._aspectRatio || event.shiftKey) && (data = this._updateRatio(data, event)), 
            data = this._respectSize(data, event), this._updateCache(data), this._propagate("resize", event), 
            props = this._applyChanges(), !this._helper && this._proportionallyResizeElements.length && this._proportionallyResize(), 
            $.isEmptyObject(props) || (this._updatePrevProperties(), this._trigger("resize", event, this.ui()), 
            this._applyChanges()), !1) : !1;
        },
        _mouseStop: function(event) {
            this.resizing = !1;
            var pr, ista, soffseth, soffsetw, s, left, top, o = this.options, that = this;
            return this._helper && (pr = this._proportionallyResizeElements, ista = pr.length && /textarea/i.test(pr[0].nodeName), 
            soffseth = ista && this._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height, soffsetw = ista ? 0 : that.sizeDiff.width, 
            s = {
                width: that.helper.width() - soffsetw,
                height: that.helper.height() - soffseth
            }, left = parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left) || null, 
            top = parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top) || null, 
            o.animate || this.element.css($.extend(s, {
                top: top,
                left: left
            })), that.helper.height(that.size.height), that.helper.width(that.size.width), this._helper && !o.animate && this._proportionallyResize()), 
            $("body").css("cursor", "auto"), this.element.removeClass("ui-resizable-resizing"), 
            this._propagate("stop", event), this._helper && this.helper.remove(), !1;
        },
        _updatePrevProperties: function() {
            this.prevPosition = {
                top: this.position.top,
                left: this.position.left
            }, this.prevSize = {
                width: this.size.width,
                height: this.size.height
            };
        },
        _applyChanges: function() {
            var props = {};
            return this.position.top !== this.prevPosition.top && (props.top = this.position.top + "px"), 
            this.position.left !== this.prevPosition.left && (props.left = this.position.left + "px"), 
            this.size.width !== this.prevSize.width && (props.width = this.size.width + "px"), 
            this.size.height !== this.prevSize.height && (props.height = this.size.height + "px"), 
            this.helper.css(props), props;
        },
        _updateVirtualBoundaries: function(forceAspectRatio) {
            var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b, o = this.options;
            b = {
                minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
                maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : 1 / 0,
                minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
                maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : 1 / 0
            }, (this._aspectRatio || forceAspectRatio) && (pMinWidth = b.minHeight * this.aspectRatio, 
            pMinHeight = b.minWidth / this.aspectRatio, pMaxWidth = b.maxHeight * this.aspectRatio, 
            pMaxHeight = b.maxWidth / this.aspectRatio, pMinWidth > b.minWidth && (b.minWidth = pMinWidth), 
            pMinHeight > b.minHeight && (b.minHeight = pMinHeight), pMaxWidth < b.maxWidth && (b.maxWidth = pMaxWidth), 
            pMaxHeight < b.maxHeight && (b.maxHeight = pMaxHeight)), this._vBoundaries = b;
        },
        _updateCache: function(data) {
            this.offset = this.helper.offset(), this._isNumber(data.left) && (this.position.left = data.left), 
            this._isNumber(data.top) && (this.position.top = data.top), this._isNumber(data.height) && (this.size.height = data.height), 
            this._isNumber(data.width) && (this.size.width = data.width);
        },
        _updateRatio: function(data) {
            var cpos = this.position, csize = this.size, a = this.axis;
            return this._isNumber(data.height) ? data.width = data.height * this.aspectRatio : this._isNumber(data.width) && (data.height = data.width / this.aspectRatio), 
            "sw" === a && (data.left = cpos.left + (csize.width - data.width), data.top = null), 
            "nw" === a && (data.top = cpos.top + (csize.height - data.height), data.left = cpos.left + (csize.width - data.width)), 
            data;
        },
        _respectSize: function(data) {
            var o = this._vBoundaries, a = this.axis, ismaxw = this._isNumber(data.width) && o.maxWidth && o.maxWidth < data.width, ismaxh = this._isNumber(data.height) && o.maxHeight && o.maxHeight < data.height, isminw = this._isNumber(data.width) && o.minWidth && o.minWidth > data.width, isminh = this._isNumber(data.height) && o.minHeight && o.minHeight > data.height, dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height, cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
            // Fixing jump error on top/left - bug #2330
            return isminw && (data.width = o.minWidth), isminh && (data.height = o.minHeight), 
            ismaxw && (data.width = o.maxWidth), ismaxh && (data.height = o.maxHeight), isminw && cw && (data.left = dw - o.minWidth), 
            ismaxw && cw && (data.left = dw - o.maxWidth), isminh && ch && (data.top = dh - o.minHeight), 
            ismaxh && ch && (data.top = dh - o.maxHeight), data.width || data.height || data.left || !data.top ? data.width || data.height || data.top || !data.left || (data.left = null) : data.top = null, 
            data;
        },
        _getPaddingPlusBorderDimensions: function(element) {
            for (var i = 0, widths = [], borders = [ element.css("borderTopWidth"), element.css("borderRightWidth"), element.css("borderBottomWidth"), element.css("borderLeftWidth") ], paddings = [ element.css("paddingTop"), element.css("paddingRight"), element.css("paddingBottom"), element.css("paddingLeft") ]; 4 > i; i++) widths[i] = parseInt(borders[i], 10) || 0, 
            widths[i] += parseInt(paddings[i], 10) || 0;
            return {
                height: widths[0] + widths[2],
                width: widths[1] + widths[3]
            };
        },
        _proportionallyResize: function() {
            if (this._proportionallyResizeElements.length) for (var prel, i = 0, element = this.helper || this.element; i < this._proportionallyResizeElements.length; i++) prel = this._proportionallyResizeElements[i], 
            this.outerDimensions || (this.outerDimensions = this._getPaddingPlusBorderDimensions(prel)), 
            prel.css({
                height: element.height() - this.outerDimensions.height || 0,
                width: element.width() - this.outerDimensions.width || 0
            });
        },
        _renderProxy: function() {
            var el = this.element, o = this.options;
            this.elementOffset = el.offset(), this._helper ? (this.helper = this.helper || $("<div style='overflow:hidden;'></div>"), 
            this.helper.addClass(this._helper).css({
                width: this.element.outerWidth() - 1,
                height: this.element.outerHeight() - 1,
                position: "absolute",
                left: this.elementOffset.left + "px",
                top: this.elementOffset.top + "px",
                zIndex: ++o.zIndex
            }), this.helper.appendTo("body").disableSelection()) : this.helper = this.element;
        },
        _change: {
            e: function(event, dx) {
                return {
                    width: this.originalSize.width + dx
                };
            },
            w: function(event, dx) {
                var cs = this.originalSize, sp = this.originalPosition;
                return {
                    left: sp.left + dx,
                    width: cs.width - dx
                };
            },
            n: function(event, dx, dy) {
                var cs = this.originalSize, sp = this.originalPosition;
                return {
                    top: sp.top + dy,
                    height: cs.height - dy
                };
            },
            s: function(event, dx, dy) {
                return {
                    height: this.originalSize.height + dy
                };
            },
            se: function(event, dx, dy) {
                return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [ event, dx, dy ]));
            },
            sw: function(event, dx, dy) {
                return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [ event, dx, dy ]));
            },
            ne: function(event, dx, dy) {
                return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [ event, dx, dy ]));
            },
            nw: function(event, dx, dy) {
                return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [ event, dx, dy ]));
            }
        },
        _propagate: function(n, event) {
            $.ui.plugin.call(this, n, [ event, this.ui() ]), "resize" !== n && this._trigger(n, event, this.ui());
        },
        plugins: {},
        ui: function() {
            return {
                originalElement: this.originalElement,
                element: this.element,
                helper: this.helper,
                position: this.position,
                size: this.size,
                originalSize: this.originalSize,
                originalPosition: this.originalPosition
            };
        }
    }), /*
 * Resizable Extensions
 */
    $.ui.plugin.add("resizable", "animate", {
        stop: function(event) {
            var that = $(this).resizable("instance"), o = that.options, pr = that._proportionallyResizeElements, ista = pr.length && /textarea/i.test(pr[0].nodeName), soffseth = ista && that._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height, soffsetw = ista ? 0 : that.sizeDiff.width, style = {
                width: that.size.width - soffsetw,
                height: that.size.height - soffseth
            }, left = parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left) || null, top = parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top) || null;
            that.element.animate($.extend(style, top && left ? {
                top: top,
                left: left
            } : {}), {
                duration: o.animateDuration,
                easing: o.animateEasing,
                step: function() {
                    var data = {
                        width: parseInt(that.element.css("width"), 10),
                        height: parseInt(that.element.css("height"), 10),
                        top: parseInt(that.element.css("top"), 10),
                        left: parseInt(that.element.css("left"), 10)
                    };
                    pr && pr.length && $(pr[0]).css({
                        width: data.width,
                        height: data.height
                    }), // propagating resize, and updating values for each animation step
                    that._updateCache(data), that._propagate("resize", event);
                }
            });
        }
    }), $.ui.plugin.add("resizable", "containment", {
        start: function() {
            var element, p, co, ch, cw, width, height, that = $(this).resizable("instance"), o = that.options, el = that.element, oc = o.containment, ce = oc instanceof $ ? oc.get(0) : /parent/.test(oc) ? el.parent().get(0) : oc;
            ce && (that.containerElement = $(ce), /document/.test(oc) || oc === document ? (that.containerOffset = {
                left: 0,
                top: 0
            }, that.containerPosition = {
                left: 0,
                top: 0
            }, that.parentData = {
                element: $(document),
                left: 0,
                top: 0,
                width: $(document).width(),
                height: $(document).height() || document.body.parentNode.scrollHeight
            }) : (element = $(ce), p = [], $([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) {
                p[i] = that._num(element.css("padding" + name));
            }), that.containerOffset = element.offset(), that.containerPosition = element.position(), 
            that.containerSize = {
                height: element.innerHeight() - p[3],
                width: element.innerWidth() - p[1]
            }, co = that.containerOffset, ch = that.containerSize.height, cw = that.containerSize.width, 
            width = that._hasScroll(ce, "left") ? ce.scrollWidth : cw, height = that._hasScroll(ce) ? ce.scrollHeight : ch, 
            that.parentData = {
                element: ce,
                left: co.left,
                top: co.top,
                width: width,
                height: height
            }));
        },
        resize: function(event) {
            var woset, hoset, isParent, isOffsetRelative, that = $(this).resizable("instance"), o = that.options, co = that.containerOffset, cp = that.position, pRatio = that._aspectRatio || event.shiftKey, cop = {
                top: 0,
                left: 0
            }, ce = that.containerElement, continueResize = !0;
            ce[0] !== document && /static/.test(ce.css("position")) && (cop = co), cp.left < (that._helper ? co.left : 0) && (that.size.width = that.size.width + (that._helper ? that.position.left - co.left : that.position.left - cop.left), 
            pRatio && (that.size.height = that.size.width / that.aspectRatio, continueResize = !1), 
            that.position.left = o.helper ? co.left : 0), cp.top < (that._helper ? co.top : 0) && (that.size.height = that.size.height + (that._helper ? that.position.top - co.top : that.position.top), 
            pRatio && (that.size.width = that.size.height * that.aspectRatio, continueResize = !1), 
            that.position.top = that._helper ? co.top : 0), isParent = that.containerElement.get(0) === that.element.parent().get(0), 
            isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position")), 
            isParent && isOffsetRelative ? (that.offset.left = that.parentData.left + that.position.left, 
            that.offset.top = that.parentData.top + that.position.top) : (that.offset.left = that.element.offset().left, 
            that.offset.top = that.element.offset().top), woset = Math.abs(that.sizeDiff.width + (that._helper ? that.offset.left - cop.left : that.offset.left - co.left)), 
            hoset = Math.abs(that.sizeDiff.height + (that._helper ? that.offset.top - cop.top : that.offset.top - co.top)), 
            woset + that.size.width >= that.parentData.width && (that.size.width = that.parentData.width - woset, 
            pRatio && (that.size.height = that.size.width / that.aspectRatio, continueResize = !1)), 
            hoset + that.size.height >= that.parentData.height && (that.size.height = that.parentData.height - hoset, 
            pRatio && (that.size.width = that.size.height * that.aspectRatio, continueResize = !1)), 
            continueResize || (that.position.left = that.prevPosition.left, that.position.top = that.prevPosition.top, 
            that.size.width = that.prevSize.width, that.size.height = that.prevSize.height);
        },
        stop: function() {
            var that = $(this).resizable("instance"), o = that.options, co = that.containerOffset, cop = that.containerPosition, ce = that.containerElement, helper = $(that.helper), ho = helper.offset(), w = helper.outerWidth() - that.sizeDiff.width, h = helper.outerHeight() - that.sizeDiff.height;
            that._helper && !o.animate && /relative/.test(ce.css("position")) && $(this).css({
                left: ho.left - cop.left - co.left,
                width: w,
                height: h
            }), that._helper && !o.animate && /static/.test(ce.css("position")) && $(this).css({
                left: ho.left - cop.left - co.left,
                width: w,
                height: h
            });
        }
    }), $.ui.plugin.add("resizable", "alsoResize", {
        start: function() {
            var that = $(this).resizable("instance"), o = that.options;
            $(o.alsoResize).each(function() {
                var el = $(this);
                el.data("ui-resizable-alsoresize", {
                    width: parseInt(el.width(), 10),
                    height: parseInt(el.height(), 10),
                    left: parseInt(el.css("left"), 10),
                    top: parseInt(el.css("top"), 10)
                });
            });
        },
        resize: function(event, ui) {
            var that = $(this).resizable("instance"), o = that.options, os = that.originalSize, op = that.originalPosition, delta = {
                height: that.size.height - os.height || 0,
                width: that.size.width - os.width || 0,
                top: that.position.top - op.top || 0,
                left: that.position.left - op.left || 0
            };
            $(o.alsoResize).each(function() {
                var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {}, css = el.parents(ui.originalElement[0]).length ? [ "width", "height" ] : [ "width", "height", "top", "left" ];
                $.each(css, function(i, prop) {
                    var sum = (start[prop] || 0) + (delta[prop] || 0);
                    sum && sum >= 0 && (style[prop] = sum || null);
                }), el.css(style);
            });
        },
        stop: function() {
            $(this).removeData("resizable-alsoresize");
        }
    }), $.ui.plugin.add("resizable", "ghost", {
        start: function() {
            var that = $(this).resizable("instance"), o = that.options, cs = that.size;
            that.ghost = that.originalElement.clone(), that.ghost.css({
                opacity: .25,
                display: "block",
                position: "relative",
                height: cs.height,
                width: cs.width,
                margin: 0,
                left: 0,
                top: 0
            }).addClass("ui-resizable-ghost").addClass("string" == typeof o.ghost ? o.ghost : ""), 
            that.ghost.appendTo(that.helper);
        },
        resize: function() {
            var that = $(this).resizable("instance");
            that.ghost && that.ghost.css({
                position: "relative",
                height: that.size.height,
                width: that.size.width
            });
        },
        stop: function() {
            var that = $(this).resizable("instance");
            that.ghost && that.helper && that.helper.get(0).removeChild(that.ghost.get(0));
        }
    }), $.ui.plugin.add("resizable", "grid", {
        resize: function() {
            var outerDimensions, that = $(this).resizable("instance"), o = that.options, cs = that.size, os = that.originalSize, op = that.originalPosition, a = that.axis, grid = "number" == typeof o.grid ? [ o.grid, o.grid ] : o.grid, gridX = grid[0] || 1, gridY = grid[1] || 1, ox = Math.round((cs.width - os.width) / gridX) * gridX, oy = Math.round((cs.height - os.height) / gridY) * gridY, newWidth = os.width + ox, newHeight = os.height + oy, isMaxWidth = o.maxWidth && o.maxWidth < newWidth, isMaxHeight = o.maxHeight && o.maxHeight < newHeight, isMinWidth = o.minWidth && o.minWidth > newWidth, isMinHeight = o.minHeight && o.minHeight > newHeight;
            o.grid = grid, isMinWidth && (newWidth += gridX), isMinHeight && (newHeight += gridY), 
            isMaxWidth && (newWidth -= gridX), isMaxHeight && (newHeight -= gridY), /^(se|s|e)$/.test(a) ? (that.size.width = newWidth, 
            that.size.height = newHeight) : /^(ne)$/.test(a) ? (that.size.width = newWidth, 
            that.size.height = newHeight, that.position.top = op.top - oy) : /^(sw)$/.test(a) ? (that.size.width = newWidth, 
            that.size.height = newHeight, that.position.left = op.left - ox) : ((0 >= newHeight - gridY || 0 >= newWidth - gridX) && (outerDimensions = that._getPaddingPlusBorderDimensions(this)), 
            newHeight - gridY > 0 ? (that.size.height = newHeight, that.position.top = op.top - oy) : (newHeight = gridY - outerDimensions.height, 
            that.size.height = newHeight, that.position.top = op.top + os.height - newHeight), 
            newWidth - gridX > 0 ? (that.size.width = newWidth, that.position.left = op.left - ox) : (newWidth = gridX - outerDimensions.width, 
            that.size.width = newWidth, that.position.left = op.left + os.width - newWidth));
        }
    });
    $.ui.resizable, $.widget("ui.dialog", {
        version: "1.11.4",
        options: {
            appendTo: "body",
            autoOpen: !0,
            buttons: [],
            closeOnEscape: !0,
            closeText: "Close",
            dialogClass: "",
            draggable: !0,
            hide: null,
            height: "auto",
            maxHeight: null,
            maxWidth: null,
            minHeight: 150,
            minWidth: 150,
            modal: !1,
            position: {
                my: "center",
                at: "center",
                of: window,
                collision: "fit",
                // Ensure the titlebar is always visible
                using: function(pos) {
                    var topOffset = $(this).css(pos).offset().top;
                    0 > topOffset && $(this).css("top", pos.top - topOffset);
                }
            },
            resizable: !0,
            show: null,
            title: null,
            width: 300,
            // callbacks
            beforeClose: null,
            close: null,
            drag: null,
            dragStart: null,
            dragStop: null,
            focus: null,
            open: null,
            resize: null,
            resizeStart: null,
            resizeStop: null
        },
        sizeRelatedOptions: {
            buttons: !0,
            height: !0,
            maxHeight: !0,
            maxWidth: !0,
            minHeight: !0,
            minWidth: !0,
            width: !0
        },
        resizableRelatedOptions: {
            maxHeight: !0,
            maxWidth: !0,
            minHeight: !0,
            minWidth: !0
        },
        _create: function() {
            this.originalCss = {
                display: this.element[0].style.display,
                width: this.element[0].style.width,
                minHeight: this.element[0].style.minHeight,
                maxHeight: this.element[0].style.maxHeight,
                height: this.element[0].style.height
            }, this.originalPosition = {
                parent: this.element.parent(),
                index: this.element.parent().children().index(this.element)
            }, this.originalTitle = this.element.attr("title"), this.options.title = this.options.title || this.originalTitle, 
            this._createWrapper(), this.element.show().removeAttr("title").addClass("ui-dialog-content ui-widget-content").appendTo(this.uiDialog), 
            this._createTitlebar(), this._createButtonPane(), this.options.draggable && $.fn.draggable && this._makeDraggable(), 
            this.options.resizable && $.fn.resizable && this._makeResizable(), this._isOpen = !1, 
            this._trackFocus();
        },
        _init: function() {
            this.options.autoOpen && this.open();
        },
        _appendTo: function() {
            var element = this.options.appendTo;
            return element && (element.jquery || element.nodeType) ? $(element) : this.document.find(element || "body").eq(0);
        },
        _destroy: function() {
            var next, originalPosition = this.originalPosition;
            this._untrackInstance(), this._destroyOverlay(), this.element.removeUniqueId().removeClass("ui-dialog-content ui-widget-content").css(this.originalCss).detach(), 
            this.uiDialog.stop(!0, !0).remove(), this.originalTitle && this.element.attr("title", this.originalTitle), 
            next = originalPosition.parent.children().eq(originalPosition.index), next.length && next[0] !== this.element[0] ? next.before(this.element) : originalPosition.parent.append(this.element);
        },
        widget: function() {
            return this.uiDialog;
        },
        disable: $.noop,
        enable: $.noop,
        close: function(event) {
            var activeElement, that = this;
            if (this._isOpen && this._trigger("beforeClose", event) !== !1) {
                if (this._isOpen = !1, this._focusedElement = null, this._destroyOverlay(), this._untrackInstance(), 
                !this.opener.filter(":focusable").focus().length) // support: IE9
                // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
                try {
                    activeElement = this.document[0].activeElement, // Support: IE9, IE10
                    // If the <body> is blurred, IE will switch windows, see #4520
                    activeElement && "body" !== activeElement.nodeName.toLowerCase() && // Hiding a focused element doesn't trigger blur in WebKit
                    // so in case we have nothing to focus on, explicitly blur the active element
                    // https://bugs.webkit.org/show_bug.cgi?id=47182
                    $(activeElement).blur();
                } catch (error) {}
                this._hide(this.uiDialog, this.options.hide, function() {
                    that._trigger("close", event);
                });
            }
        },
        isOpen: function() {
            return this._isOpen;
        },
        moveToTop: function() {
            this._moveToTop();
        },
        _moveToTop: function(event, silent) {
            var moved = !1, zIndices = this.uiDialog.siblings(".ui-front:visible").map(function() {
                return +$(this).css("z-index");
            }).get(), zIndexMax = Math.max.apply(null, zIndices);
            return zIndexMax >= +this.uiDialog.css("z-index") && (this.uiDialog.css("z-index", zIndexMax + 1), 
            moved = !0), moved && !silent && this._trigger("focus", event), moved;
        },
        open: function() {
            var that = this;
            // Ensure the overlay is moved to the top with the dialog, but only when
            // opening. The overlay shouldn't move after the dialog is open so that
            // modeless dialogs opened after the modal dialog stack properly.
            // Track the dialog immediately upon openening in case a focus event
            // somehow occurs outside of the dialog before an element inside the
            // dialog is focused (#10152)
            return this._isOpen ? void (this._moveToTop() && this._focusTabbable()) : (this._isOpen = !0, 
            this.opener = $(this.document[0].activeElement), this._size(), this._position(), 
            this._createOverlay(), this._moveToTop(null, !0), this.overlay && this.overlay.css("z-index", this.uiDialog.css("z-index") - 1), 
            this._show(this.uiDialog, this.options.show, function() {
                that._focusTabbable(), that._trigger("focus");
            }), this._makeFocusTarget(), void this._trigger("open"));
        },
        _focusTabbable: function() {
            // Set focus to the first match:
            // 1. An element that was focused previously
            // 2. First element inside the dialog matching [autofocus]
            // 3. Tabbable element inside the content element
            // 4. Tabbable element inside the buttonpane
            // 5. The close button
            // 6. The dialog itself
            var hasFocus = this._focusedElement;
            hasFocus || (hasFocus = this.element.find("[autofocus]")), hasFocus.length || (hasFocus = this.element.find(":tabbable")), 
            hasFocus.length || (hasFocus = this.uiDialogButtonPane.find(":tabbable")), hasFocus.length || (hasFocus = this.uiDialogTitlebarClose.filter(":tabbable")), 
            hasFocus.length || (hasFocus = this.uiDialog), hasFocus.eq(0).focus();
        },
        _keepFocus: function(event) {
            function checkFocus() {
                var activeElement = this.document[0].activeElement, isActive = this.uiDialog[0] === activeElement || $.contains(this.uiDialog[0], activeElement);
                isActive || this._focusTabbable();
            }
            event.preventDefault(), checkFocus.call(this), // support: IE
            // IE <= 8 doesn't prevent moving focus even with event.preventDefault()
            // so we check again later
            this._delay(checkFocus);
        },
        _createWrapper: function() {
            this.uiDialog = $("<div>").addClass("ui-dialog ui-widget ui-widget-content ui-corner-all ui-front " + this.options.dialogClass).hide().attr({
                // Setting tabIndex makes the div focusable
                tabIndex: -1,
                role: "dialog"
            }).appendTo(this._appendTo()), this._on(this.uiDialog, {
                keydown: function(event) {
                    if (this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode && event.keyCode === $.ui.keyCode.ESCAPE) return event.preventDefault(), 
                    void this.close(event);
                    // prevent tabbing out of dialogs
                    if (event.keyCode === $.ui.keyCode.TAB && !event.isDefaultPrevented()) {
                        var tabbables = this.uiDialog.find(":tabbable"), first = tabbables.filter(":first"), last = tabbables.filter(":last");
                        event.target !== last[0] && event.target !== this.uiDialog[0] || event.shiftKey ? event.target !== first[0] && event.target !== this.uiDialog[0] || !event.shiftKey || (this._delay(function() {
                            last.focus();
                        }), event.preventDefault()) : (this._delay(function() {
                            first.focus();
                        }), event.preventDefault());
                    }
                },
                mousedown: function(event) {
                    this._moveToTop(event) && this._focusTabbable();
                }
            }), // We assume that any existing aria-describedby attribute means
            // that the dialog content is marked up properly
            // otherwise we brute force the content as the description
            this.element.find("[aria-describedby]").length || this.uiDialog.attr({
                "aria-describedby": this.element.uniqueId().attr("id")
            });
        },
        _createTitlebar: function() {
            var uiDialogTitle;
            this.uiDialogTitlebar = $("<div>").addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix").prependTo(this.uiDialog), 
            this._on(this.uiDialogTitlebar, {
                mousedown: function(event) {
                    // Don't prevent click on close button (#8838)
                    // Focusing a dialog that is partially scrolled out of view
                    // causes the browser to scroll it into view, preventing the click event
                    $(event.target).closest(".ui-dialog-titlebar-close") || // Dialog isn't getting focus when dragging (#8063)
                    this.uiDialog.focus();
                }
            }), // support: IE
            // Use type="button" to prevent enter keypresses in textboxes from closing the
            // dialog in IE (#9312)
            this.uiDialogTitlebarClose = $("<button type='button'></button>").button({
                label: this.options.closeText,
                icons: {
                    primary: "ui-icon-closethick"
                },
                text: !1
            }).addClass("ui-dialog-titlebar-close").appendTo(this.uiDialogTitlebar), this._on(this.uiDialogTitlebarClose, {
                click: function(event) {
                    event.preventDefault(), this.close(event);
                }
            }), uiDialogTitle = $("<span>").uniqueId().addClass("ui-dialog-title").prependTo(this.uiDialogTitlebar), 
            this._title(uiDialogTitle), this.uiDialog.attr({
                "aria-labelledby": uiDialogTitle.attr("id")
            });
        },
        _title: function(title) {
            this.options.title || title.html("&#160;"), title.text(this.options.title);
        },
        _createButtonPane: function() {
            this.uiDialogButtonPane = $("<div>").addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix"), 
            this.uiButtonSet = $("<div>").addClass("ui-dialog-buttonset").appendTo(this.uiDialogButtonPane), 
            this._createButtons();
        },
        _createButtons: function() {
            var that = this, buttons = this.options.buttons;
            // if we already have a button pane, remove it
            return this.uiDialogButtonPane.remove(), this.uiButtonSet.empty(), $.isEmptyObject(buttons) || $.isArray(buttons) && !buttons.length ? void this.uiDialog.removeClass("ui-dialog-buttons") : ($.each(buttons, function(name, props) {
                var click, buttonOptions;
                props = $.isFunction(props) ? {
                    click: props,
                    text: name
                } : props, props = $.extend({
                    type: "button"
                }, props), click = props.click, props.click = function() {
                    click.apply(that.element[0], arguments);
                }, buttonOptions = {
                    icons: props.icons,
                    text: props.showText
                }, delete props.icons, delete props.showText, $("<button></button>", props).button(buttonOptions).appendTo(that.uiButtonSet);
            }), this.uiDialog.addClass("ui-dialog-buttons"), void this.uiDialogButtonPane.appendTo(this.uiDialog));
        },
        _makeDraggable: function() {
            function filteredUi(ui) {
                return {
                    position: ui.position,
                    offset: ui.offset
                };
            }
            var that = this, options = this.options;
            this.uiDialog.draggable({
                cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
                handle: ".ui-dialog-titlebar",
                containment: "document",
                start: function(event, ui) {
                    $(this).addClass("ui-dialog-dragging"), that._blockFrames(), that._trigger("dragStart", event, filteredUi(ui));
                },
                drag: function(event, ui) {
                    that._trigger("drag", event, filteredUi(ui));
                },
                stop: function(event, ui) {
                    var left = ui.offset.left - that.document.scrollLeft(), top = ui.offset.top - that.document.scrollTop();
                    options.position = {
                        my: "left top",
                        at: "left" + (left >= 0 ? "+" : "") + left + " top" + (top >= 0 ? "+" : "") + top,
                        of: that.window
                    }, $(this).removeClass("ui-dialog-dragging"), that._unblockFrames(), that._trigger("dragStop", event, filteredUi(ui));
                }
            });
        },
        _makeResizable: function() {
            function filteredUi(ui) {
                return {
                    originalPosition: ui.originalPosition,
                    originalSize: ui.originalSize,
                    position: ui.position,
                    size: ui.size
                };
            }
            var that = this, options = this.options, handles = options.resizable, // .ui-resizable has position: relative defined in the stylesheet
            // but dialogs have to use absolute or fixed positioning
            position = this.uiDialog.css("position"), resizeHandles = "string" == typeof handles ? handles : "n,e,s,w,se,sw,ne,nw";
            this.uiDialog.resizable({
                cancel: ".ui-dialog-content",
                containment: "document",
                alsoResize: this.element,
                maxWidth: options.maxWidth,
                maxHeight: options.maxHeight,
                minWidth: options.minWidth,
                minHeight: this._minHeight(),
                handles: resizeHandles,
                start: function(event, ui) {
                    $(this).addClass("ui-dialog-resizing"), that._blockFrames(), that._trigger("resizeStart", event, filteredUi(ui));
                },
                resize: function(event, ui) {
                    that._trigger("resize", event, filteredUi(ui));
                },
                stop: function(event, ui) {
                    var offset = that.uiDialog.offset(), left = offset.left - that.document.scrollLeft(), top = offset.top - that.document.scrollTop();
                    options.height = that.uiDialog.height(), options.width = that.uiDialog.width(), 
                    options.position = {
                        my: "left top",
                        at: "left" + (left >= 0 ? "+" : "") + left + " top" + (top >= 0 ? "+" : "") + top,
                        of: that.window
                    }, $(this).removeClass("ui-dialog-resizing"), that._unblockFrames(), that._trigger("resizeStop", event, filteredUi(ui));
                }
            }).css("position", position);
        },
        _trackFocus: function() {
            this._on(this.widget(), {
                focusin: function(event) {
                    this._makeFocusTarget(), this._focusedElement = $(event.target);
                }
            });
        },
        _makeFocusTarget: function() {
            this._untrackInstance(), this._trackingInstances().unshift(this);
        },
        _untrackInstance: function() {
            var instances = this._trackingInstances(), exists = $.inArray(this, instances);
            -1 !== exists && instances.splice(exists, 1);
        },
        _trackingInstances: function() {
            var instances = this.document.data("ui-dialog-instances");
            return instances || (instances = [], this.document.data("ui-dialog-instances", instances)), 
            instances;
        },
        _minHeight: function() {
            var options = this.options;
            return "auto" === options.height ? options.minHeight : Math.min(options.minHeight, options.height);
        },
        _position: function() {
            // Need to show the dialog to get the actual offset in the position plugin
            var isVisible = this.uiDialog.is(":visible");
            isVisible || this.uiDialog.show(), this.uiDialog.position(this.options.position), 
            isVisible || this.uiDialog.hide();
        },
        _setOptions: function(options) {
            var that = this, resize = !1, resizableOptions = {};
            $.each(options, function(key, value) {
                that._setOption(key, value), key in that.sizeRelatedOptions && (resize = !0), key in that.resizableRelatedOptions && (resizableOptions[key] = value);
            }), resize && (this._size(), this._position()), this.uiDialog.is(":data(ui-resizable)") && this.uiDialog.resizable("option", resizableOptions);
        },
        _setOption: function(key, value) {
            var isDraggable, isResizable, uiDialog = this.uiDialog;
            "dialogClass" === key && uiDialog.removeClass(this.options.dialogClass).addClass(value), 
            "disabled" !== key && (this._super(key, value), "appendTo" === key && this.uiDialog.appendTo(this._appendTo()), 
            "buttons" === key && this._createButtons(), "closeText" === key && this.uiDialogTitlebarClose.button({
                // Ensure that we always pass a string
                label: "" + value
            }), "draggable" === key && (isDraggable = uiDialog.is(":data(ui-draggable)"), isDraggable && !value && uiDialog.draggable("destroy"), 
            !isDraggable && value && this._makeDraggable()), "position" === key && this._position(), 
            "resizable" === key && (isResizable = uiDialog.is(":data(ui-resizable)"), isResizable && !value && uiDialog.resizable("destroy"), 
            isResizable && "string" == typeof value && uiDialog.resizable("option", "handles", value), 
            isResizable || value === !1 || this._makeResizable()), "title" === key && this._title(this.uiDialogTitlebar.find(".ui-dialog-title")));
        },
        _size: function() {
            // If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
            // divs will both have width and height set, so we need to reset them
            var nonContentHeight, minContentHeight, maxContentHeight, options = this.options;
            // Reset content sizing
            this.element.show().css({
                width: "auto",
                minHeight: 0,
                maxHeight: "none",
                height: 0
            }), options.minWidth > options.width && (options.width = options.minWidth), nonContentHeight = this.uiDialog.css({
                height: "auto",
                width: options.width
            }).outerHeight(), minContentHeight = Math.max(0, options.minHeight - nonContentHeight), 
            maxContentHeight = "number" == typeof options.maxHeight ? Math.max(0, options.maxHeight - nonContentHeight) : "none", 
            "auto" === options.height ? this.element.css({
                minHeight: minContentHeight,
                maxHeight: maxContentHeight,
                height: "auto"
            }) : this.element.height(Math.max(0, options.height - nonContentHeight)), this.uiDialog.is(":data(ui-resizable)") && this.uiDialog.resizable("option", "minHeight", this._minHeight());
        },
        _blockFrames: function() {
            this.iframeBlocks = this.document.find("iframe").map(function() {
                var iframe = $(this);
                return $("<div>").css({
                    position: "absolute",
                    width: iframe.outerWidth(),
                    height: iframe.outerHeight()
                }).appendTo(iframe.parent()).offset(iframe.offset())[0];
            });
        },
        _unblockFrames: function() {
            this.iframeBlocks && (this.iframeBlocks.remove(), delete this.iframeBlocks);
        },
        _allowInteraction: function(event) {
            return $(event.target).closest(".ui-dialog").length ? !0 : !!$(event.target).closest(".ui-datepicker").length;
        },
        _createOverlay: function() {
            if (this.options.modal) {
                // We use a delay in case the overlay is created from an
                // event that we're going to be cancelling (#2804)
                var isOpening = !0;
                this._delay(function() {
                    isOpening = !1;
                }), this.document.data("ui-dialog-overlays") || // Prevent use of anchors and inputs
                // Using _on() for an event handler shared across many instances is
                // safe because the dialogs stack and must be closed in reverse order
                this._on(this.document, {
                    focusin: function(event) {
                        isOpening || this._allowInteraction(event) || (event.preventDefault(), this._trackingInstances()[0]._focusTabbable());
                    }
                }), this.overlay = $("<div>").addClass("ui-widget-overlay ui-front").appendTo(this._appendTo()), 
                this._on(this.overlay, {
                    mousedown: "_keepFocus"
                }), this.document.data("ui-dialog-overlays", (this.document.data("ui-dialog-overlays") || 0) + 1);
            }
        },
        _destroyOverlay: function() {
            if (this.options.modal && this.overlay) {
                var overlays = this.document.data("ui-dialog-overlays") - 1;
                overlays ? this.document.data("ui-dialog-overlays", overlays) : this.document.unbind("focusin").removeData("ui-dialog-overlays"), 
                this.overlay.remove(), this.overlay = null;
            }
        }
    });
    /*!
 * jQuery UI Droppable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/droppable/
 */
    $.widget("ui.droppable", {
        version: "1.11.4",
        widgetEventPrefix: "drop",
        options: {
            accept: "*",
            activeClass: !1,
            addClasses: !0,
            greedy: !1,
            hoverClass: !1,
            scope: "default",
            tolerance: "intersect",
            // callbacks
            activate: null,
            deactivate: null,
            drop: null,
            out: null,
            over: null
        },
        _create: function() {
            var proportions, o = this.options, accept = o.accept;
            this.isover = !1, this.isout = !0, this.accept = $.isFunction(accept) ? accept : function(d) {
                return d.is(accept);
            }, this.proportions = function() {
                // Store the droppable's proportions
                return arguments.length ? void (proportions = arguments[0]) : proportions ? proportions : proportions = {
                    width: this.element[0].offsetWidth,
                    height: this.element[0].offsetHeight
                };
            }, this._addToManager(o.scope), o.addClasses && this.element.addClass("ui-droppable");
        },
        _addToManager: function(scope) {
            // Add the reference and positions to the manager
            $.ui.ddmanager.droppables[scope] = $.ui.ddmanager.droppables[scope] || [], $.ui.ddmanager.droppables[scope].push(this);
        },
        _splice: function(drop) {
            for (var i = 0; i < drop.length; i++) drop[i] === this && drop.splice(i, 1);
        },
        _destroy: function() {
            var drop = $.ui.ddmanager.droppables[this.options.scope];
            this._splice(drop), this.element.removeClass("ui-droppable ui-droppable-disabled");
        },
        _setOption: function(key, value) {
            if ("accept" === key) this.accept = $.isFunction(value) ? value : function(d) {
                return d.is(value);
            }; else if ("scope" === key) {
                var drop = $.ui.ddmanager.droppables[this.options.scope];
                this._splice(drop), this._addToManager(value);
            }
            this._super(key, value);
        },
        _activate: function(event) {
            var draggable = $.ui.ddmanager.current;
            this.options.activeClass && this.element.addClass(this.options.activeClass), draggable && this._trigger("activate", event, this.ui(draggable));
        },
        _deactivate: function(event) {
            var draggable = $.ui.ddmanager.current;
            this.options.activeClass && this.element.removeClass(this.options.activeClass), 
            draggable && this._trigger("deactivate", event, this.ui(draggable));
        },
        _over: function(event) {
            var draggable = $.ui.ddmanager.current;
            // Bail if draggable and droppable are same element
            draggable && (draggable.currentItem || draggable.element)[0] !== this.element[0] && this.accept.call(this.element[0], draggable.currentItem || draggable.element) && (this.options.hoverClass && this.element.addClass(this.options.hoverClass), 
            this._trigger("over", event, this.ui(draggable)));
        },
        _out: function(event) {
            var draggable = $.ui.ddmanager.current;
            // Bail if draggable and droppable are same element
            draggable && (draggable.currentItem || draggable.element)[0] !== this.element[0] && this.accept.call(this.element[0], draggable.currentItem || draggable.element) && (this.options.hoverClass && this.element.removeClass(this.options.hoverClass), 
            this._trigger("out", event, this.ui(draggable)));
        },
        _drop: function(event, custom) {
            var draggable = custom || $.ui.ddmanager.current, childrenIntersection = !1;
            // Bail if draggable and droppable are same element
            // Bail if draggable and droppable are same element
            return draggable && (draggable.currentItem || draggable.element)[0] !== this.element[0] ? (this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function() {
                var inst = $(this).droppable("instance");
                return inst.options.greedy && !inst.options.disabled && inst.options.scope === draggable.options.scope && inst.accept.call(inst.element[0], draggable.currentItem || draggable.element) && $.ui.intersect(draggable, $.extend(inst, {
                    offset: inst.element.offset()
                }), inst.options.tolerance, event) ? (childrenIntersection = !0, !1) : void 0;
            }), childrenIntersection ? !1 : this.accept.call(this.element[0], draggable.currentItem || draggable.element) ? (this.options.activeClass && this.element.removeClass(this.options.activeClass), 
            this.options.hoverClass && this.element.removeClass(this.options.hoverClass), this._trigger("drop", event, this.ui(draggable)), 
            this.element) : !1) : !1;
        },
        ui: function(c) {
            return {
                draggable: c.currentItem || c.element,
                helper: c.helper,
                position: c.position,
                offset: c.positionAbs
            };
        }
    }), $.ui.intersect = function() {
        function isOverAxis(x, reference, size) {
            return x >= reference && reference + size > x;
        }
        return function(draggable, droppable, toleranceMode, event) {
            if (!droppable.offset) return !1;
            var x1 = (draggable.positionAbs || draggable.position.absolute).left + draggable.margins.left, y1 = (draggable.positionAbs || draggable.position.absolute).top + draggable.margins.top, x2 = x1 + draggable.helperProportions.width, y2 = y1 + draggable.helperProportions.height, l = droppable.offset.left, t = droppable.offset.top, r = l + droppable.proportions().width, b = t + droppable.proportions().height;
            switch (toleranceMode) {
              case "fit":
                return x1 >= l && r >= x2 && y1 >= t && b >= y2;

              case "intersect":
                // Right Half
                // Left Half
                // Bottom Half
                return l < x1 + draggable.helperProportions.width / 2 && x2 - draggable.helperProportions.width / 2 < r && t < y1 + draggable.helperProportions.height / 2 && y2 - draggable.helperProportions.height / 2 < b;

              // Top Half
                case "pointer":
                return isOverAxis(event.pageY, t, droppable.proportions().height) && isOverAxis(event.pageX, l, droppable.proportions().width);

              case "touch":
                // Top edge touching
                // Bottom edge touching
                // Left edge touching
                // Right edge touching
                return (y1 >= t && b >= y1 || y2 >= t && b >= y2 || t > y1 && y2 > b) && (x1 >= l && r >= x1 || x2 >= l && r >= x2 || l > x1 && x2 > r);

              default:
                return !1;
            }
        };
    }(), /*
	This manager tracks offsets of draggables and droppables
*/
    $.ui.ddmanager = {
        current: null,
        droppables: {
            "default": []
        },
        prepareOffsets: function(t, event) {
            var i, j, m = $.ui.ddmanager.droppables[t.options.scope] || [], type = event ? event.type : null, // workaround for #2317
            list = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();
            droppablesLoop: for (i = 0; i < m.length; i++) // No disabled and non-accepted
            if (!(m[i].options.disabled || t && !m[i].accept.call(m[i].element[0], t.currentItem || t.element))) {
                // Filter out elements in the current dragged item
                for (j = 0; j < list.length; j++) if (list[j] === m[i].element[0]) {
                    m[i].proportions().height = 0;
                    continue droppablesLoop;
                }
                m[i].visible = "none" !== m[i].element.css("display"), m[i].visible && (// Activate the droppable if used directly from draggables
                "mousedown" === type && m[i]._activate.call(m[i], event), m[i].offset = m[i].element.offset(), 
                m[i].proportions({
                    width: m[i].element[0].offsetWidth,
                    height: m[i].element[0].offsetHeight
                }));
            }
        },
        drop: function(draggable, event) {
            var dropped = !1;
            // Create a copy of the droppables in case the list changes during the drop (#9116)
            return $.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function() {
                this.options && (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance, event) && (dropped = this._drop.call(this, event) || dropped), 
                !this.options.disabled && this.visible && this.accept.call(this.element[0], draggable.currentItem || draggable.element) && (this.isout = !0, 
                this.isover = !1, this._deactivate.call(this, event)));
            }), dropped;
        },
        dragStart: function(draggable, event) {
            // Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
            draggable.element.parentsUntil("body").bind("scroll.droppable", function() {
                draggable.options.refreshPositions || $.ui.ddmanager.prepareOffsets(draggable, event);
            });
        },
        drag: function(draggable, event) {
            // If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
            draggable.options.refreshPositions && $.ui.ddmanager.prepareOffsets(draggable, event), 
            // Run through all droppables and check their positions based on specific tolerance options
            $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {
                if (!this.options.disabled && !this.greedyChild && this.visible) {
                    var parentInstance, scope, parent, intersects = $.ui.intersect(draggable, this, this.options.tolerance, event), c = !intersects && this.isover ? "isout" : intersects && !this.isover ? "isover" : null;
                    c && (this.options.greedy && (scope = this.options.scope, parent = this.element.parents(":data(ui-droppable)").filter(function() {
                        return $(this).droppable("instance").options.scope === scope;
                    }), parent.length && (parentInstance = $(parent[0]).droppable("instance"), parentInstance.greedyChild = "isover" === c)), 
                    // we just moved into a greedy child
                    parentInstance && "isover" === c && (parentInstance.isover = !1, parentInstance.isout = !0, 
                    parentInstance._out.call(parentInstance, event)), this[c] = !0, this["isout" === c ? "isover" : "isout"] = !1, 
                    this["isover" === c ? "_over" : "_out"].call(this, event), // we just moved out of a greedy child
                    parentInstance && "isout" === c && (parentInstance.isout = !1, parentInstance.isover = !0, 
                    parentInstance._over.call(parentInstance, event)));
                }
            });
        },
        dragStop: function(draggable, event) {
            draggable.element.parentsUntil("body").unbind("scroll.droppable"), // Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
            draggable.options.refreshPositions || $.ui.ddmanager.prepareOffsets(draggable, event);
        }
    };
    var dataSpace = ($.ui.droppable, "ui-effects-"), // Create a local jQuery because jQuery Color relies on it and the
    // global may not exist with AMD and a custom build (#10199)
    jQuery = $;
    $.effects = {
        effect: {}
    }, /*!
 * jQuery Color Animations v2.1.2
 * https://github.com/jquery/jquery-color
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Wed Jan 16 08:47:09 2013 -0600
 */
    function(jQuery, undefined) {
        function clamp(value, prop, allowEmpty) {
            var type = propTypes[prop.type] || {};
            // ~~ is an short way of doing floor for positive numbers
            // IE will pass in empty strings as value for alpha,
            // which will hit this case
            return null == value ? allowEmpty || !prop.def ? null : prop.def : (value = type.floor ? ~~value : parseFloat(value), 
            isNaN(value) ? prop.def : type.mod ? (value + type.mod) % type.mod : 0 > value ? 0 : type.max < value ? type.max : value);
        }
        function stringParse(string) {
            var inst = color(), rgba = inst._rgba = [];
            return string = string.toLowerCase(), each(stringParsers, function(i, parser) {
                var parsed, match = parser.re.exec(string), values = match && parser.parse(match), spaceName = parser.space || "rgba";
                return values ? (parsed = inst[spaceName](values), inst[spaces[spaceName].cache] = parsed[spaces[spaceName].cache], 
                rgba = inst._rgba = parsed._rgba, !1) : void 0;
            }), rgba.length ? ("0,0,0,0" === rgba.join() && jQuery.extend(rgba, colors.transparent), 
            inst) : colors[string];
        }
        // hsla conversions adapted from:
        // https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021
        function hue2rgb(p, q, h) {
            return h = (h + 1) % 1, 1 > 6 * h ? p + (q - p) * h * 6 : 1 > 2 * h ? q : 2 > 3 * h ? p + (q - p) * (2 / 3 - h) * 6 : p;
        }
        var // colors = jQuery.Color.names
        colors, stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor", // plusequals test for += 100 -= 100
        rplusequals = /^([\-+])=\s*(\d+\.?\d*)/, // a set of RE's that can match strings and generate color tuples.
        stringParsers = [ {
            re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            parse: function(execResult) {
                return [ execResult[1], execResult[2], execResult[3], execResult[4] ];
            }
        }, {
            re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            parse: function(execResult) {
                return [ 2.55 * execResult[1], 2.55 * execResult[2], 2.55 * execResult[3], execResult[4] ];
            }
        }, {
            // this regex ignores A-F because it's compared against an already lowercased string
            re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
            parse: function(execResult) {
                return [ parseInt(execResult[1], 16), parseInt(execResult[2], 16), parseInt(execResult[3], 16) ];
            }
        }, {
            // this regex ignores A-F because it's compared against an already lowercased string
            re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
            parse: function(execResult) {
                return [ parseInt(execResult[1] + execResult[1], 16), parseInt(execResult[2] + execResult[2], 16), parseInt(execResult[3] + execResult[3], 16) ];
            }
        }, {
            re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            space: "hsla",
            parse: function(execResult) {
                return [ execResult[1], execResult[2] / 100, execResult[3] / 100, execResult[4] ];
            }
        } ], // jQuery.Color( )
        color = jQuery.Color = function(color, green, blue, alpha) {
            return new jQuery.Color.fn.parse(color, green, blue, alpha);
        }, spaces = {
            rgba: {
                props: {
                    red: {
                        idx: 0,
                        type: "byte"
                    },
                    green: {
                        idx: 1,
                        type: "byte"
                    },
                    blue: {
                        idx: 2,
                        type: "byte"
                    }
                }
            },
            hsla: {
                props: {
                    hue: {
                        idx: 0,
                        type: "degrees"
                    },
                    saturation: {
                        idx: 1,
                        type: "percent"
                    },
                    lightness: {
                        idx: 2,
                        type: "percent"
                    }
                }
            }
        }, propTypes = {
            "byte": {
                floor: !0,
                max: 255
            },
            percent: {
                max: 1
            },
            degrees: {
                mod: 360,
                floor: !0
            }
        }, support = color.support = {}, // element for support tests
        supportElem = jQuery("<p>")[0], // local aliases of functions called often
        each = jQuery.each;
        // determine rgba support immediately
        supportElem.style.cssText = "background-color:rgba(1,1,1,.5)", support.rgba = supportElem.style.backgroundColor.indexOf("rgba") > -1, 
        // define cache name and alpha properties
        // for rgba and hsla spaces
        each(spaces, function(spaceName, space) {
            space.cache = "_" + spaceName, space.props.alpha = {
                idx: 3,
                type: "percent",
                def: 1
            };
        }), color.fn = jQuery.extend(color.prototype, {
            parse: function(red, green, blue, alpha) {
                if (red === undefined) return this._rgba = [ null, null, null, null ], this;
                (red.jquery || red.nodeType) && (red = jQuery(red).css(green), green = undefined);
                var inst = this, type = jQuery.type(red), rgba = this._rgba = [];
                // more than 1 argument specified - assume ( red, green, blue, alpha )
                return green !== undefined && (red = [ red, green, blue, alpha ], type = "array"), 
                "string" === type ? this.parse(stringParse(red) || colors._default) : "array" === type ? (each(spaces.rgba.props, function(key, prop) {
                    rgba[prop.idx] = clamp(red[prop.idx], prop);
                }), this) : "object" === type ? (red instanceof color ? each(spaces, function(spaceName, space) {
                    red[space.cache] && (inst[space.cache] = red[space.cache].slice());
                }) : each(spaces, function(spaceName, space) {
                    var cache = space.cache;
                    each(space.props, function(key, prop) {
                        // if the cache doesn't exist, and we know how to convert
                        if (!inst[cache] && space.to) {
                            // if the value was null, we don't need to copy it
                            // if the key was alpha, we don't need to copy it either
                            if ("alpha" === key || null == red[key]) return;
                            inst[cache] = space.to(inst._rgba);
                        }
                        // this is the only case where we allow nulls for ALL properties.
                        // call clamp with alwaysAllowEmpty
                        inst[cache][prop.idx] = clamp(red[key], prop, !0);
                    }), // everything defined but alpha?
                    inst[cache] && jQuery.inArray(null, inst[cache].slice(0, 3)) < 0 && (// use the default of 1
                    inst[cache][3] = 1, space.from && (inst._rgba = space.from(inst[cache])));
                }), this) : void 0;
            },
            is: function(compare) {
                var is = color(compare), same = !0, inst = this;
                return each(spaces, function(_, space) {
                    var localCache, isCache = is[space.cache];
                    return isCache && (localCache = inst[space.cache] || space.to && space.to(inst._rgba) || [], 
                    each(space.props, function(_, prop) {
                        return null != isCache[prop.idx] ? same = isCache[prop.idx] === localCache[prop.idx] : void 0;
                    })), same;
                }), same;
            },
            _space: function() {
                var used = [], inst = this;
                return each(spaces, function(spaceName, space) {
                    inst[space.cache] && used.push(spaceName);
                }), used.pop();
            },
            transition: function(other, distance) {
                var end = color(other), spaceName = end._space(), space = spaces[spaceName], startColor = 0 === this.alpha() ? color("transparent") : this, start = startColor[space.cache] || space.to(startColor._rgba), result = start.slice();
                return end = end[space.cache], each(space.props, function(key, prop) {
                    var index = prop.idx, startValue = start[index], endValue = end[index], type = propTypes[prop.type] || {};
                    null !== endValue && (null === startValue ? result[index] = endValue : (type.mod && (endValue - startValue > type.mod / 2 ? startValue += type.mod : startValue - endValue > type.mod / 2 && (startValue -= type.mod)), 
                    result[index] = clamp((endValue - startValue) * distance + startValue, prop)));
                }), this[spaceName](result);
            },
            blend: function(opaque) {
                // if we are already opaque - return ourself
                if (1 === this._rgba[3]) return this;
                var rgb = this._rgba.slice(), a = rgb.pop(), blend = color(opaque)._rgba;
                return color(jQuery.map(rgb, function(v, i) {
                    return (1 - a) * blend[i] + a * v;
                }));
            },
            toRgbaString: function() {
                var prefix = "rgba(", rgba = jQuery.map(this._rgba, function(v, i) {
                    return null == v ? i > 2 ? 1 : 0 : v;
                });
                return 1 === rgba[3] && (rgba.pop(), prefix = "rgb("), prefix + rgba.join() + ")";
            },
            toHslaString: function() {
                var prefix = "hsla(", hsla = jQuery.map(this.hsla(), function(v, i) {
                    // catch 1 and 2
                    return null == v && (v = i > 2 ? 1 : 0), i && 3 > i && (v = Math.round(100 * v) + "%"), 
                    v;
                });
                return 1 === hsla[3] && (hsla.pop(), prefix = "hsl("), prefix + hsla.join() + ")";
            },
            toHexString: function(includeAlpha) {
                var rgba = this._rgba.slice(), alpha = rgba.pop();
                return includeAlpha && rgba.push(~~(255 * alpha)), "#" + jQuery.map(rgba, function(v) {
                    // default to 0 when nulls exist
                    return v = (v || 0).toString(16), 1 === v.length ? "0" + v : v;
                }).join("");
            },
            toString: function() {
                return 0 === this._rgba[3] ? "transparent" : this.toRgbaString();
            }
        }), color.fn.parse.prototype = color.fn, spaces.hsla.to = function(rgba) {
            if (null == rgba[0] || null == rgba[1] || null == rgba[2]) return [ null, null, null, rgba[3] ];
            var h, s, r = rgba[0] / 255, g = rgba[1] / 255, b = rgba[2] / 255, a = rgba[3], max = Math.max(r, g, b), min = Math.min(r, g, b), diff = max - min, add = max + min, l = .5 * add;
            // chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
            // otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
            return h = min === max ? 0 : r === max ? 60 * (g - b) / diff + 360 : g === max ? 60 * (b - r) / diff + 120 : 60 * (r - g) / diff + 240, 
            s = 0 === diff ? 0 : .5 >= l ? diff / add : diff / (2 - add), [ Math.round(h) % 360, s, l, null == a ? 1 : a ];
        }, spaces.hsla.from = function(hsla) {
            if (null == hsla[0] || null == hsla[1] || null == hsla[2]) return [ null, null, null, hsla[3] ];
            var h = hsla[0] / 360, s = hsla[1], l = hsla[2], a = hsla[3], q = .5 >= l ? l * (1 + s) : l + s - l * s, p = 2 * l - q;
            return [ Math.round(255 * hue2rgb(p, q, h + 1 / 3)), Math.round(255 * hue2rgb(p, q, h)), Math.round(255 * hue2rgb(p, q, h - 1 / 3)), a ];
        }, each(spaces, function(spaceName, space) {
            var props = space.props, cache = space.cache, to = space.to, from = space.from;
            // makes rgba() and hsla()
            color.fn[spaceName] = function(value) {
                if (// generate a cache for this space if it doesn't exist
                to && !this[cache] && (this[cache] = to(this._rgba)), value === undefined) return this[cache].slice();
                var ret, type = jQuery.type(value), arr = "array" === type || "object" === type ? value : arguments, local = this[cache].slice();
                return each(props, function(key, prop) {
                    var val = arr["object" === type ? key : prop.idx];
                    null == val && (val = local[prop.idx]), local[prop.idx] = clamp(val, prop);
                }), from ? (ret = color(from(local)), ret[cache] = local, ret) : color(local);
            }, // makes red() green() blue() alpha() hue() saturation() lightness()
            each(props, function(key, prop) {
                // alpha is included in more than one space
                color.fn[key] || (color.fn[key] = function(value) {
                    var match, vtype = jQuery.type(value), fn = "alpha" === key ? this._hsla ? "hsla" : "rgba" : spaceName, local = this[fn](), cur = local[prop.idx];
                    return "undefined" === vtype ? cur : ("function" === vtype && (value = value.call(this, cur), 
                    vtype = jQuery.type(value)), null == value && prop.empty ? this : ("string" === vtype && (match = rplusequals.exec(value), 
                    match && (value = cur + parseFloat(match[2]) * ("+" === match[1] ? 1 : -1))), local[prop.idx] = value, 
                    this[fn](local)));
                });
            });
        }), // add cssHook and .fx.step function for each named hook.
        // accept a space separated string of properties
        color.hook = function(hook) {
            var hooks = hook.split(" ");
            each(hooks, function(i, hook) {
                jQuery.cssHooks[hook] = {
                    set: function(elem, value) {
                        var parsed, curElem, backgroundColor = "";
                        if ("transparent" !== value && ("string" !== jQuery.type(value) || (parsed = stringParse(value)))) {
                            if (value = color(parsed || value), !support.rgba && 1 !== value._rgba[3]) {
                                for (curElem = "backgroundColor" === hook ? elem.parentNode : elem; ("" === backgroundColor || "transparent" === backgroundColor) && curElem && curElem.style; ) try {
                                    backgroundColor = jQuery.css(curElem, "backgroundColor"), curElem = curElem.parentNode;
                                } catch (e) {}
                                value = value.blend(backgroundColor && "transparent" !== backgroundColor ? backgroundColor : "_default");
                            }
                            value = value.toRgbaString();
                        }
                        try {
                            elem.style[hook] = value;
                        } catch (e) {}
                    }
                }, jQuery.fx.step[hook] = function(fx) {
                    fx.colorInit || (fx.start = color(fx.elem, hook), fx.end = color(fx.end), fx.colorInit = !0), 
                    jQuery.cssHooks[hook].set(fx.elem, fx.start.transition(fx.end, fx.pos));
                };
            });
        }, color.hook(stepHooks), jQuery.cssHooks.borderColor = {
            expand: function(value) {
                var expanded = {};
                return each([ "Top", "Right", "Bottom", "Left" ], function(i, part) {
                    expanded["border" + part + "Color"] = value;
                }), expanded;
            }
        }, // Basic color names only.
        // Usage of any of the other color names requires adding yourself or including
        // jquery.color.svg-names.js.
        colors = jQuery.Color.names = {
            // 4.1. Basic color keywords
            aqua: "#00ffff",
            black: "#000000",
            blue: "#0000ff",
            fuchsia: "#ff00ff",
            gray: "#808080",
            green: "#008000",
            lime: "#00ff00",
            maroon: "#800000",
            navy: "#000080",
            olive: "#808000",
            purple: "#800080",
            red: "#ff0000",
            silver: "#c0c0c0",
            teal: "#008080",
            white: "#ffffff",
            yellow: "#ffff00",
            // 4.2.3. "transparent" color keyword
            transparent: [ null, null, null, 0 ],
            _default: "#ffffff"
        };
    }(jQuery), /******************************************************************************/
    /****************************** CLASS ANIMATIONS ******************************/
    /******************************************************************************/
    function() {
        function getElementStyles(elem) {
            var key, len, style = elem.ownerDocument.defaultView ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : elem.currentStyle, styles = {};
            if (style && style.length && style[0] && style[style[0]]) for (len = style.length; len--; ) key = style[len], 
            "string" == typeof style[key] && (styles[$.camelCase(key)] = style[key]); else for (key in style) "string" == typeof style[key] && (styles[key] = style[key]);
            return styles;
        }
        function styleDifference(oldStyle, newStyle) {
            var name, value, diff = {};
            for (name in newStyle) value = newStyle[name], oldStyle[name] !== value && (shorthandStyles[name] || ($.fx.step[name] || !isNaN(parseFloat(value))) && (diff[name] = value));
            return diff;
        }
        var classAnimationActions = [ "add", "remove", "toggle" ], shorthandStyles = {
            border: 1,
            borderBottom: 1,
            borderColor: 1,
            borderLeft: 1,
            borderRight: 1,
            borderTop: 1,
            borderWidth: 1,
            margin: 1,
            padding: 1
        };
        $.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function(_, prop) {
            $.fx.step[prop] = function(fx) {
                ("none" !== fx.end && !fx.setAttr || 1 === fx.pos && !fx.setAttr) && (jQuery.style(fx.elem, prop, fx.end), 
                fx.setAttr = !0);
            };
        }), // support: jQuery <1.8
        $.fn.addBack || ($.fn.addBack = function(selector) {
            return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector));
        }), $.effects.animateClass = function(value, duration, easing, callback) {
            var o = $.speed(duration, easing, callback);
            return this.queue(function() {
                var applyClassChange, animated = $(this), baseClass = animated.attr("class") || "", allAnimations = o.children ? animated.find("*").addBack() : animated;
                allAnimations = allAnimations.map(function() {
                    var el = $(this);
                    return {
                        el: el,
                        start: getElementStyles(this)
                    };
                }), applyClassChange = function() {
                    $.each(classAnimationActions, function(i, action) {
                        value[action] && animated[action + "Class"](value[action]);
                    });
                }, applyClassChange(), allAnimations = allAnimations.map(function() {
                    return this.end = getElementStyles(this.el[0]), this.diff = styleDifference(this.start, this.end), 
                    this;
                }), animated.attr("class", baseClass), allAnimations = allAnimations.map(function() {
                    var styleInfo = this, dfd = $.Deferred(), opts = $.extend({}, o, {
                        queue: !1,
                        complete: function() {
                            dfd.resolve(styleInfo);
                        }
                    });
                    return this.el.animate(this.diff, opts), dfd.promise();
                }), $.when.apply($, allAnimations.get()).done(function() {
                    applyClassChange(), $.each(arguments, function() {
                        var el = this.el;
                        $.each(this.diff, function(key) {
                            el.css(key, "");
                        });
                    }), o.complete.call(animated[0]);
                });
            });
        }, $.fn.extend({
            addClass: function(orig) {
                return function(classNames, speed, easing, callback) {
                    return speed ? $.effects.animateClass.call(this, {
                        add: classNames
                    }, speed, easing, callback) : orig.apply(this, arguments);
                };
            }($.fn.addClass),
            removeClass: function(orig) {
                return function(classNames, speed, easing, callback) {
                    return arguments.length > 1 ? $.effects.animateClass.call(this, {
                        remove: classNames
                    }, speed, easing, callback) : orig.apply(this, arguments);
                };
            }($.fn.removeClass),
            toggleClass: function(orig) {
                return function(classNames, force, speed, easing, callback) {
                    return "boolean" == typeof force || void 0 === force ? speed ? $.effects.animateClass.call(this, force ? {
                        add: classNames
                    } : {
                        remove: classNames
                    }, speed, easing, callback) : orig.apply(this, arguments) : $.effects.animateClass.call(this, {
                        toggle: classNames
                    }, force, speed, easing);
                };
            }($.fn.toggleClass),
            switchClass: function(remove, add, speed, easing, callback) {
                return $.effects.animateClass.call(this, {
                    add: add,
                    remove: remove
                }, speed, easing, callback);
            }
        });
    }(), /******************************************************************************/
    /*********************************** EFFECTS **********************************/
    /******************************************************************************/
    function() {
        // return an effect options object for the given parameters:
        function _normalizeArguments(effect, options, speed, callback) {
            // allow passing all options as the first parameter
            // convert to an object
            // catch (effect, null, ...)
            // catch (effect, callback)
            // catch (effect, speed, ?)
            // catch (effect, options, callback)
            // add options to effect
            return $.isPlainObject(effect) && (options = effect, effect = effect.effect), effect = {
                effect: effect
            }, null == options && (options = {}), $.isFunction(options) && (callback = options, 
            speed = null, options = {}), ("number" == typeof options || $.fx.speeds[options]) && (callback = speed, 
            speed = options, options = {}), $.isFunction(speed) && (callback = speed, speed = null), 
            options && $.extend(effect, options), speed = speed || options.duration, effect.duration = $.fx.off ? 0 : "number" == typeof speed ? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default, 
            effect.complete = callback || options.complete, effect;
        }
        function standardAnimationOption(option) {
            // Valid standard speeds (nothing, number, named speed)
            // Valid standard speeds (nothing, number, named speed)
            // Invalid strings - treat as "normal" speed
            // Complete callback
            // Options hash (but not naming an effect)
            return !option || "number" == typeof option || $.fx.speeds[option] ? !0 : "string" != typeof option || $.effects.effect[option] ? $.isFunction(option) ? !0 : "object" != typeof option || option.effect ? !1 : !0 : !0;
        }
        $.extend($.effects, {
            version: "1.11.4",
            // Saves a set of properties in a data storage
            save: function(element, set) {
                for (var i = 0; i < set.length; i++) null !== set[i] && element.data(dataSpace + set[i], element[0].style[set[i]]);
            },
            // Restores a set of previously saved properties from a data storage
            restore: function(element, set) {
                var val, i;
                for (i = 0; i < set.length; i++) null !== set[i] && (val = element.data(dataSpace + set[i]), 
                void 0 === val && (val = ""), element.css(set[i], val));
            },
            setMode: function(el, mode) {
                return "toggle" === mode && (mode = el.is(":hidden") ? "show" : "hide"), mode;
            },
            // Translates a [top,left] array into a baseline value
            // this should be a little more flexible in the future to handle a string & hash
            getBaseline: function(origin, original) {
                var y, x;
                switch (origin[0]) {
                  case "top":
                    y = 0;
                    break;

                  case "middle":
                    y = .5;
                    break;

                  case "bottom":
                    y = 1;
                    break;

                  default:
                    y = origin[0] / original.height;
                }
                switch (origin[1]) {
                  case "left":
                    x = 0;
                    break;

                  case "center":
                    x = .5;
                    break;

                  case "right":
                    x = 1;
                    break;

                  default:
                    x = origin[1] / original.width;
                }
                return {
                    x: x,
                    y: y
                };
            },
            // Wraps the element around a wrapper that copies position properties
            createWrapper: function(element) {
                // if the element is already wrapped, return it
                if (element.parent().is(".ui-effects-wrapper")) return element.parent();
                // wrap the element
                var props = {
                    width: element.outerWidth(!0),
                    height: element.outerHeight(!0),
                    "float": element.css("float")
                }, wrapper = $("<div></div>").addClass("ui-effects-wrapper").css({
                    fontSize: "100%",
                    background: "transparent",
                    border: "none",
                    margin: 0,
                    padding: 0
                }), // Store the size in case width/height are defined in % - Fixes #5245
                size = {
                    width: element.width(),
                    height: element.height()
                }, active = document.activeElement;
                // support: Firefox
                // Firefox incorrectly exposes anonymous content
                // https://bugzilla.mozilla.org/show_bug.cgi?id=561664
                try {
                    active.id;
                } catch (e) {
                    active = document.body;
                }
                // Fixes #7595 - Elements lose focus when wrapped.
                //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element
                // transfer positioning properties to the wrapper
                return element.wrap(wrapper), (element[0] === active || $.contains(element[0], active)) && $(active).focus(), 
                wrapper = element.parent(), "static" === element.css("position") ? (wrapper.css({
                    position: "relative"
                }), element.css({
                    position: "relative"
                })) : ($.extend(props, {
                    position: element.css("position"),
                    zIndex: element.css("z-index")
                }), $.each([ "top", "left", "bottom", "right" ], function(i, pos) {
                    props[pos] = element.css(pos), isNaN(parseInt(props[pos], 10)) && (props[pos] = "auto");
                }), element.css({
                    position: "relative",
                    top: 0,
                    left: 0,
                    right: "auto",
                    bottom: "auto"
                })), element.css(size), wrapper.css(props).show();
            },
            removeWrapper: function(element) {
                var active = document.activeElement;
                // Fixes #7595 - Elements lose focus when wrapped.
                return element.parent().is(".ui-effects-wrapper") && (element.parent().replaceWith(element), 
                (element[0] === active || $.contains(element[0], active)) && $(active).focus()), 
                element;
            },
            setTransition: function(element, list, factor, value) {
                return value = value || {}, $.each(list, function(i, x) {
                    var unit = element.cssUnit(x);
                    unit[0] > 0 && (value[x] = unit[0] * factor + unit[1]);
                }), value;
            }
        }), $.fn.extend({
            effect: function() {
                function run(next) {
                    function done() {
                        $.isFunction(complete) && complete.call(elem[0]), $.isFunction(next) && next();
                    }
                    var elem = $(this), complete = args.complete, mode = args.mode;
                    // If the element already has the correct final state, delegate to
                    // the core methods so the internal tracking of "olddisplay" works.
                    (elem.is(":hidden") ? "hide" === mode : "show" === mode) ? (elem[mode](), done()) : effectMethod.call(elem[0], args, done);
                }
                var args = _normalizeArguments.apply(this, arguments), mode = args.mode, queue = args.queue, effectMethod = $.effects.effect[args.effect];
                // delegate to the original method (e.g., .show()) if possible
                return $.fx.off || !effectMethod ? mode ? this[mode](args.duration, args.complete) : this.each(function() {
                    args.complete && args.complete.call(this);
                }) : queue === !1 ? this.each(run) : this.queue(queue || "fx", run);
            },
            show: function(orig) {
                return function(option) {
                    if (standardAnimationOption(option)) return orig.apply(this, arguments);
                    var args = _normalizeArguments.apply(this, arguments);
                    return args.mode = "show", this.effect.call(this, args);
                };
            }($.fn.show),
            hide: function(orig) {
                return function(option) {
                    if (standardAnimationOption(option)) return orig.apply(this, arguments);
                    var args = _normalizeArguments.apply(this, arguments);
                    return args.mode = "hide", this.effect.call(this, args);
                };
            }($.fn.hide),
            toggle: function(orig) {
                return function(option) {
                    if (standardAnimationOption(option) || "boolean" == typeof option) return orig.apply(this, arguments);
                    var args = _normalizeArguments.apply(this, arguments);
                    return args.mode = "toggle", this.effect.call(this, args);
                };
            }($.fn.toggle),
            // helper functions
            cssUnit: function(key) {
                var style = this.css(key), val = [];
                return $.each([ "em", "px", "%", "pt" ], function(i, unit) {
                    style.indexOf(unit) > 0 && (val = [ parseFloat(style), unit ]);
                }), val;
            }
        });
    }(), /******************************************************************************/
    /*********************************** EASING ***********************************/
    /******************************************************************************/
    function() {
        // based on easing equations from Robert Penner (http://www.robertpenner.com/easing)
        var baseEasings = {};
        $.each([ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function(i, name) {
            baseEasings[name] = function(p) {
                return Math.pow(p, i + 2);
            };
        }), $.extend(baseEasings, {
            Sine: function(p) {
                return 1 - Math.cos(p * Math.PI / 2);
            },
            Circ: function(p) {
                return 1 - Math.sqrt(1 - p * p);
            },
            Elastic: function(p) {
                return 0 === p || 1 === p ? p : -Math.pow(2, 8 * (p - 1)) * Math.sin((80 * (p - 1) - 7.5) * Math.PI / 15);
            },
            Back: function(p) {
                return p * p * (3 * p - 2);
            },
            Bounce: function(p) {
                for (var pow2, bounce = 4; p < ((pow2 = Math.pow(2, --bounce)) - 1) / 11; ) ;
                return 1 / Math.pow(4, 3 - bounce) - 7.5625 * Math.pow((3 * pow2 - 2) / 22 - p, 2);
            }
        }), $.each(baseEasings, function(name, easeIn) {
            $.easing["easeIn" + name] = easeIn, $.easing["easeOut" + name] = function(p) {
                return 1 - easeIn(1 - p);
            }, $.easing["easeInOut" + name] = function(p) {
                return .5 > p ? easeIn(2 * p) / 2 : 1 - easeIn(-2 * p + 2) / 2;
            };
        });
    }();
    $.effects, $.effects.effect.blind = function(o, done) {
        // Create element
        var wrapper, distance, margin, el = $(this), rvertical = /up|down|vertical/, rpositivemotion = /up|left|vertical|horizontal/, props = [ "position", "top", "bottom", "left", "right", "height", "width" ], mode = $.effects.setMode(el, o.mode || "hide"), direction = o.direction || "up", vertical = rvertical.test(direction), ref = vertical ? "height" : "width", ref2 = vertical ? "top" : "left", motion = rpositivemotion.test(direction), animation = {}, show = "show" === mode;
        // if already wrapped, the wrapper's properties are my property. #6245
        el.parent().is(".ui-effects-wrapper") ? $.effects.save(el.parent(), props) : $.effects.save(el, props), 
        el.show(), wrapper = $.effects.createWrapper(el).css({
            overflow: "hidden"
        }), distance = wrapper[ref](), margin = parseFloat(wrapper.css(ref2)) || 0, animation[ref] = show ? distance : 0, 
        motion || (el.css(vertical ? "bottom" : "right", 0).css(vertical ? "top" : "left", "auto").css({
            position: "absolute"
        }), animation[ref2] = show ? margin : distance + margin), show && (wrapper.css(ref, 0), 
        motion || wrapper.css(ref2, margin + distance)), wrapper.animate(animation, {
            duration: o.duration,
            easing: o.easing,
            queue: !1,
            complete: function() {
                "hide" === mode && el.hide(), $.effects.restore(el, props), $.effects.removeWrapper(el), 
                done();
            }
        });
    }, $.effects.effect.bounce = function(o, done) {
        var i, upAnim, downAnim, el = $(this), props = [ "position", "top", "bottom", "left", "right", "height", "width" ], // defaults:
        mode = $.effects.setMode(el, o.mode || "effect"), hide = "hide" === mode, show = "show" === mode, direction = o.direction || "up", distance = o.distance, times = o.times || 5, // number of internal animations
        anims = 2 * times + (show || hide ? 1 : 0), speed = o.duration / anims, easing = o.easing, // utility:
        ref = "up" === direction || "down" === direction ? "top" : "left", motion = "up" === direction || "left" === direction, // we will need to re-assemble the queue to stack our animations in place
        queue = el.queue(), queuelen = queue.length;
        // Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
        for (// Avoid touching opacity to prevent clearType and PNG issues in IE
        (show || hide) && props.push("opacity"), $.effects.save(el, props), el.show(), $.effects.createWrapper(el), 
        // Create Wrapper
        // default distance for the BIGGEST bounce is the outer Distance / 3
        distance || (distance = el["top" === ref ? "outerHeight" : "outerWidth"]() / 3), 
        show && (downAnim = {
            opacity: 1
        }, downAnim[ref] = 0, el.css("opacity", 0).css(ref, motion ? 2 * -distance : 2 * distance).animate(downAnim, speed, easing)), 
        // start at the smallest distance if we are hiding
        hide && (distance /= Math.pow(2, times - 1)), downAnim = {}, downAnim[ref] = 0, 
        i = 0; times > i; i++) upAnim = {}, upAnim[ref] = (motion ? "-=" : "+=") + distance, 
        el.animate(upAnim, speed, easing).animate(downAnim, speed, easing), distance = hide ? 2 * distance : distance / 2;
        // Last Bounce when Hiding
        hide && (upAnim = {
            opacity: 0
        }, upAnim[ref] = (motion ? "-=" : "+=") + distance, el.animate(upAnim, speed, easing)), 
        el.queue(function() {
            hide && el.hide(), $.effects.restore(el, props), $.effects.removeWrapper(el), done();
        }), // inject all the animations we just queued to be first in line (after "inprogress")
        queuelen > 1 && queue.splice.apply(queue, [ 1, 0 ].concat(queue.splice(queuelen, anims + 1))), 
        el.dequeue();
    }, $.effects.effect.clip = function(o, done) {
        // Create element
        var wrapper, animate, distance, el = $(this), props = [ "position", "top", "bottom", "left", "right", "height", "width" ], mode = $.effects.setMode(el, o.mode || "hide"), show = "show" === mode, direction = o.direction || "vertical", vert = "vertical" === direction, size = vert ? "height" : "width", position = vert ? "top" : "left", animation = {};
        // Save & Show
        $.effects.save(el, props), el.show(), wrapper = $.effects.createWrapper(el).css({
            overflow: "hidden"
        }), animate = "IMG" === el[0].tagName ? wrapper : el, distance = animate[size](), 
        show && (animate.css(size, 0), animate.css(position, distance / 2)), animation[size] = show ? distance : 0, 
        animation[position] = show ? 0 : distance / 2, animate.animate(animation, {
            queue: !1,
            duration: o.duration,
            easing: o.easing,
            complete: function() {
                show || el.hide(), $.effects.restore(el, props), $.effects.removeWrapper(el), done();
            }
        });
    }, $.effects.effect.drop = function(o, done) {
        var distance, el = $(this), props = [ "position", "top", "bottom", "left", "right", "opacity", "height", "width" ], mode = $.effects.setMode(el, o.mode || "hide"), show = "show" === mode, direction = o.direction || "left", ref = "up" === direction || "down" === direction ? "top" : "left", motion = "up" === direction || "left" === direction ? "pos" : "neg", animation = {
            opacity: show ? 1 : 0
        };
        // Adjust
        $.effects.save(el, props), el.show(), $.effects.createWrapper(el), distance = o.distance || el["top" === ref ? "outerHeight" : "outerWidth"](!0) / 2, 
        show && el.css("opacity", 0).css(ref, "pos" === motion ? -distance : distance), 
        animation[ref] = (show ? "pos" === motion ? "+=" : "-=" : "pos" === motion ? "-=" : "+=") + distance, 
        el.animate(animation, {
            queue: !1,
            duration: o.duration,
            easing: o.easing,
            complete: function() {
                "hide" === mode && el.hide(), $.effects.restore(el, props), $.effects.removeWrapper(el), 
                done();
            }
        });
    }, $.effects.effect.explode = function(o, done) {
        // children animate complete:
        function childComplete() {
            pieces.push(this), pieces.length === rows * cells && animComplete();
        }
        function animComplete() {
            el.css({
                visibility: "visible"
            }), $(pieces).remove(), show || el.hide(), done();
        }
        var // loop
        i, j, left, top, mx, my, rows = o.pieces ? Math.round(Math.sqrt(o.pieces)) : 3, cells = rows, el = $(this), mode = $.effects.setMode(el, o.mode || "hide"), show = "show" === mode, // show and then visibility:hidden the element before calculating offset
        offset = el.show().css("visibility", "hidden").offset(), // width and height of a piece
        width = Math.ceil(el.outerWidth() / cells), height = Math.ceil(el.outerHeight() / rows), pieces = [];
        // clone the element for each row and cell.
        for (i = 0; rows > i; i++) for (top = offset.top + i * height, my = i - (rows - 1) / 2, 
        j = 0; cells > j; j++) left = offset.left + j * width, mx = j - (cells - 1) / 2, 
        el.clone().appendTo("body").wrap("<div></div>").css({
            position: "absolute",
            visibility: "visible",
            left: -j * width,
            top: -i * height
        }).parent().addClass("ui-effects-explode").css({
            position: "absolute",
            overflow: "hidden",
            width: width,
            height: height,
            left: left + (show ? mx * width : 0),
            top: top + (show ? my * height : 0),
            opacity: show ? 0 : 1
        }).animate({
            left: left + (show ? 0 : mx * width),
            top: top + (show ? 0 : my * height),
            opacity: show ? 1 : 0
        }, o.duration || 500, o.easing, childComplete);
    }, $.effects.effect.fade = function(o, done) {
        var el = $(this), mode = $.effects.setMode(el, o.mode || "toggle");
        el.animate({
            opacity: mode
        }, {
            queue: !1,
            duration: o.duration,
            easing: o.easing,
            complete: done
        });
    }, $.effects.effect.fold = function(o, done) {
        // Create element
        var wrapper, distance, el = $(this), props = [ "position", "top", "bottom", "left", "right", "height", "width" ], mode = $.effects.setMode(el, o.mode || "hide"), show = "show" === mode, hide = "hide" === mode, size = o.size || 15, percent = /([0-9]+)%/.exec(size), horizFirst = !!o.horizFirst, widthFirst = show !== horizFirst, ref = widthFirst ? [ "width", "height" ] : [ "height", "width" ], duration = o.duration / 2, animation1 = {}, animation2 = {};
        $.effects.save(el, props), el.show(), wrapper = $.effects.createWrapper(el).css({
            overflow: "hidden"
        }), distance = widthFirst ? [ wrapper.width(), wrapper.height() ] : [ wrapper.height(), wrapper.width() ], 
        percent && (size = parseInt(percent[1], 10) / 100 * distance[hide ? 0 : 1]), show && wrapper.css(horizFirst ? {
            height: 0,
            width: size
        } : {
            height: size,
            width: 0
        }), animation1[ref[0]] = show ? distance[0] : size, animation2[ref[1]] = show ? distance[1] : 0, 
        wrapper.animate(animation1, duration, o.easing).animate(animation2, duration, o.easing, function() {
            hide && el.hide(), $.effects.restore(el, props), $.effects.removeWrapper(el), done();
        });
    }, $.effects.effect.highlight = function(o, done) {
        var elem = $(this), props = [ "backgroundImage", "backgroundColor", "opacity" ], mode = $.effects.setMode(elem, o.mode || "show"), animation = {
            backgroundColor: elem.css("backgroundColor")
        };
        "hide" === mode && (animation.opacity = 0), $.effects.save(elem, props), elem.show().css({
            backgroundImage: "none",
            backgroundColor: o.color || "#ffff99"
        }).animate(animation, {
            queue: !1,
            duration: o.duration,
            easing: o.easing,
            complete: function() {
                "hide" === mode && elem.hide(), $.effects.restore(elem, props), done();
            }
        });
    }, $.effects.effect.size = function(o, done) {
        // Create element
        var original, baseline, factor, el = $(this), props0 = [ "position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity" ], // Always restore
        props1 = [ "position", "top", "bottom", "left", "right", "overflow", "opacity" ], // Copy for children
        props2 = [ "width", "height", "overflow" ], cProps = [ "fontSize" ], vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ], hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ], // Set options
        mode = $.effects.setMode(el, o.mode || "effect"), restore = o.restore || "effect" !== mode, scale = o.scale || "both", origin = o.origin || [ "middle", "center" ], position = el.css("position"), props = restore ? props0 : props1, zero = {
            height: 0,
            width: 0,
            outerHeight: 0,
            outerWidth: 0
        };
        "show" === mode && el.show(), original = {
            height: el.height(),
            width: el.width(),
            outerHeight: el.outerHeight(),
            outerWidth: el.outerWidth()
        }, "toggle" === o.mode && "show" === mode ? (el.from = o.to || zero, el.to = o.from || original) : (el.from = o.from || ("show" === mode ? zero : original), 
        el.to = o.to || ("hide" === mode ? zero : original)), factor = {
            from: {
                y: el.from.height / original.height,
                x: el.from.width / original.width
            },
            to: {
                y: el.to.height / original.height,
                x: el.to.width / original.width
            }
        }, ("box" === scale || "both" === scale) && (factor.from.y !== factor.to.y && (props = props.concat(vProps), 
        el.from = $.effects.setTransition(el, vProps, factor.from.y, el.from), el.to = $.effects.setTransition(el, vProps, factor.to.y, el.to)), 
        factor.from.x !== factor.to.x && (props = props.concat(hProps), el.from = $.effects.setTransition(el, hProps, factor.from.x, el.from), 
        el.to = $.effects.setTransition(el, hProps, factor.to.x, el.to))), ("content" === scale || "both" === scale) && factor.from.y !== factor.to.y && (props = props.concat(cProps).concat(props2), 
        el.from = $.effects.setTransition(el, cProps, factor.from.y, el.from), el.to = $.effects.setTransition(el, cProps, factor.to.y, el.to)), 
        $.effects.save(el, props), el.show(), $.effects.createWrapper(el), el.css("overflow", "hidden").css(el.from), 
        origin && (baseline = $.effects.getBaseline(origin, original), el.from.top = (original.outerHeight - el.outerHeight()) * baseline.y, 
        el.from.left = (original.outerWidth - el.outerWidth()) * baseline.x, el.to.top = (original.outerHeight - el.to.outerHeight) * baseline.y, 
        el.to.left = (original.outerWidth - el.to.outerWidth) * baseline.x), el.css(el.from), 
        ("content" === scale || "both" === scale) && (vProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps), 
        hProps = hProps.concat([ "marginLeft", "marginRight" ]), props2 = props0.concat(vProps).concat(hProps), 
        el.find("*[width]").each(function() {
            var child = $(this), c_original = {
                height: child.height(),
                width: child.width(),
                outerHeight: child.outerHeight(),
                outerWidth: child.outerWidth()
            };
            restore && $.effects.save(child, props2), child.from = {
                height: c_original.height * factor.from.y,
                width: c_original.width * factor.from.x,
                outerHeight: c_original.outerHeight * factor.from.y,
                outerWidth: c_original.outerWidth * factor.from.x
            }, child.to = {
                height: c_original.height * factor.to.y,
                width: c_original.width * factor.to.x,
                outerHeight: c_original.height * factor.to.y,
                outerWidth: c_original.width * factor.to.x
            }, factor.from.y !== factor.to.y && (child.from = $.effects.setTransition(child, vProps, factor.from.y, child.from), 
            child.to = $.effects.setTransition(child, vProps, factor.to.y, child.to)), factor.from.x !== factor.to.x && (child.from = $.effects.setTransition(child, hProps, factor.from.x, child.from), 
            child.to = $.effects.setTransition(child, hProps, factor.to.x, child.to)), child.css(child.from), 
            child.animate(child.to, o.duration, o.easing, function() {
                restore && $.effects.restore(child, props2);
            });
        })), el.animate(el.to, {
            queue: !1,
            duration: o.duration,
            easing: o.easing,
            complete: function() {
                0 === el.to.opacity && el.css("opacity", el.from.opacity), "hide" === mode && el.hide(), 
                $.effects.restore(el, props), restore || ("static" === position ? el.css({
                    position: "relative",
                    top: el.to.top,
                    left: el.to.left
                }) : $.each([ "top", "left" ], function(idx, pos) {
                    el.css(pos, function(_, str) {
                        var val = parseInt(str, 10), toRef = idx ? el.to.left : el.to.top;
                        return "auto" === str ? toRef + "px" : val + toRef + "px";
                    });
                })), $.effects.removeWrapper(el), done();
            }
        });
    }, $.effects.effect.scale = function(o, done) {
        // Create element
        var el = $(this), options = $.extend(!0, {}, o), mode = $.effects.setMode(el, o.mode || "effect"), percent = parseInt(o.percent, 10) || (0 === parseInt(o.percent, 10) ? 0 : "hide" === mode ? 0 : 100), direction = o.direction || "both", origin = o.origin, original = {
            height: el.height(),
            width: el.width(),
            outerHeight: el.outerHeight(),
            outerWidth: el.outerWidth()
        }, factor = {
            y: "horizontal" !== direction ? percent / 100 : 1,
            x: "vertical" !== direction ? percent / 100 : 1
        };
        // We are going to pass this effect to the size effect:
        options.effect = "size", options.queue = !1, options.complete = done, "effect" !== mode && (options.origin = origin || [ "middle", "center" ], 
        options.restore = !0), options.from = o.from || ("show" === mode ? {
            height: 0,
            width: 0,
            outerHeight: 0,
            outerWidth: 0
        } : original), options.to = {
            height: original.height * factor.y,
            width: original.width * factor.x,
            outerHeight: original.outerHeight * factor.y,
            outerWidth: original.outerWidth * factor.x
        }, // Fade option to support puff
        options.fade && ("show" === mode && (options.from.opacity = 0, options.to.opacity = 1), 
        "hide" === mode && (options.from.opacity = 1, options.to.opacity = 0)), // Animate
        el.effect(options);
    }, $.effects.effect.puff = function(o, done) {
        var elem = $(this), mode = $.effects.setMode(elem, o.mode || "hide"), hide = "hide" === mode, percent = parseInt(o.percent, 10) || 150, factor = percent / 100, original = {
            height: elem.height(),
            width: elem.width(),
            outerHeight: elem.outerHeight(),
            outerWidth: elem.outerWidth()
        };
        $.extend(o, {
            effect: "scale",
            queue: !1,
            fade: !0,
            mode: mode,
            complete: done,
            percent: hide ? percent : 100,
            from: hide ? original : {
                height: original.height * factor,
                width: original.width * factor,
                outerHeight: original.outerHeight * factor,
                outerWidth: original.outerWidth * factor
            }
        }), elem.effect(o);
    }, $.effects.effect.pulsate = function(o, done) {
        var i, elem = $(this), mode = $.effects.setMode(elem, o.mode || "show"), show = "show" === mode, hide = "hide" === mode, showhide = show || "hide" === mode, // showing or hiding leaves of the "last" animation
        anims = 2 * (o.times || 5) + (showhide ? 1 : 0), duration = o.duration / anims, animateTo = 0, queue = elem.queue(), queuelen = queue.length;
        // anims - 1 opacity "toggles"
        for ((show || !elem.is(":visible")) && (elem.css("opacity", 0).show(), animateTo = 1), 
        i = 1; anims > i; i++) elem.animate({
            opacity: animateTo
        }, duration, o.easing), animateTo = 1 - animateTo;
        elem.animate({
            opacity: animateTo
        }, duration, o.easing), elem.queue(function() {
            hide && elem.hide(), done();
        }), // We just queued up "anims" animations, we need to put them next in the queue
        queuelen > 1 && queue.splice.apply(queue, [ 1, 0 ].concat(queue.splice(queuelen, anims + 1))), 
        elem.dequeue();
    }, $.effects.effect.shake = function(o, done) {
        var i, el = $(this), props = [ "position", "top", "bottom", "left", "right", "height", "width" ], mode = $.effects.setMode(el, o.mode || "effect"), direction = o.direction || "left", distance = o.distance || 20, times = o.times || 3, anims = 2 * times + 1, speed = Math.round(o.duration / anims), ref = "up" === direction || "down" === direction ? "top" : "left", positiveMotion = "up" === direction || "left" === direction, animation = {}, animation1 = {}, animation2 = {}, // we will need to re-assemble the queue to stack our animations in place
        queue = el.queue(), queuelen = queue.length;
        // Shakes
        for ($.effects.save(el, props), el.show(), $.effects.createWrapper(el), // Animation
        animation[ref] = (positiveMotion ? "-=" : "+=") + distance, animation1[ref] = (positiveMotion ? "+=" : "-=") + 2 * distance, 
        animation2[ref] = (positiveMotion ? "-=" : "+=") + 2 * distance, // Animate
        el.animate(animation, speed, o.easing), i = 1; times > i; i++) el.animate(animation1, speed, o.easing).animate(animation2, speed, o.easing);
        el.animate(animation1, speed, o.easing).animate(animation, speed / 2, o.easing).queue(function() {
            "hide" === mode && el.hide(), $.effects.restore(el, props), $.effects.removeWrapper(el), 
            done();
        }), // inject all the animations we just queued to be first in line (after "inprogress")
        queuelen > 1 && queue.splice.apply(queue, [ 1, 0 ].concat(queue.splice(queuelen, anims + 1))), 
        el.dequeue();
    }, $.effects.effect.slide = function(o, done) {
        // Create element
        var distance, el = $(this), props = [ "position", "top", "bottom", "left", "right", "width", "height" ], mode = $.effects.setMode(el, o.mode || "show"), show = "show" === mode, direction = o.direction || "left", ref = "up" === direction || "down" === direction ? "top" : "left", positiveMotion = "up" === direction || "left" === direction, animation = {};
        // Adjust
        $.effects.save(el, props), el.show(), distance = o.distance || el["top" === ref ? "outerHeight" : "outerWidth"](!0), 
        $.effects.createWrapper(el).css({
            overflow: "hidden"
        }), show && el.css(ref, positiveMotion ? isNaN(distance) ? "-" + distance : -distance : distance), 
        animation[ref] = (show ? positiveMotion ? "+=" : "-=" : positiveMotion ? "-=" : "+=") + distance, 
        el.animate(animation, {
            queue: !1,
            duration: o.duration,
            easing: o.easing,
            complete: function() {
                "hide" === mode && el.hide(), $.effects.restore(el, props), $.effects.removeWrapper(el), 
                done();
            }
        });
    }, $.effects.effect.transfer = function(o, done) {
        var elem = $(this), target = $(o.to), targetFixed = "fixed" === target.css("position"), body = $("body"), fixTop = targetFixed ? body.scrollTop() : 0, fixLeft = targetFixed ? body.scrollLeft() : 0, endPosition = target.offset(), animation = {
            top: endPosition.top - fixTop,
            left: endPosition.left - fixLeft,
            height: target.innerHeight(),
            width: target.innerWidth()
        }, startPosition = elem.offset(), transfer = $("<div class='ui-effects-transfer'></div>").appendTo(document.body).addClass(o.className).css({
            top: startPosition.top - fixTop,
            left: startPosition.left - fixLeft,
            height: elem.innerHeight(),
            width: elem.innerWidth(),
            position: targetFixed ? "fixed" : "absolute"
        }).animate(animation, o.duration, o.easing, function() {
            transfer.remove(), done();
        });
    }, $.widget("ui.progressbar", {
        version: "1.11.4",
        options: {
            max: 100,
            value: 0,
            change: null,
            complete: null
        },
        min: 0,
        _create: function() {
            // Constrain initial value
            this.oldValue = this.options.value = this._constrainedValue(), this.element.addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").attr({
                // Only set static values, aria-valuenow and aria-valuemax are
                // set inside _refreshValue()
                role: "progressbar",
                "aria-valuemin": this.min
            }), this.valueDiv = $("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>").appendTo(this.element), 
            this._refreshValue();
        },
        _destroy: function() {
            this.element.removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow"), 
            this.valueDiv.remove();
        },
        value: function(newValue) {
            return void 0 === newValue ? this.options.value : (this.options.value = this._constrainedValue(newValue), 
            void this._refreshValue());
        },
        _constrainedValue: function(newValue) {
            // sanitize value
            return void 0 === newValue && (newValue = this.options.value), this.indeterminate = newValue === !1, 
            "number" != typeof newValue && (newValue = 0), this.indeterminate ? !1 : Math.min(this.options.max, Math.max(this.min, newValue));
        },
        _setOptions: function(options) {
            // Ensure "value" option is set after other values (like max)
            var value = options.value;
            delete options.value, this._super(options), this.options.value = this._constrainedValue(value), 
            this._refreshValue();
        },
        _setOption: function(key, value) {
            "max" === key && (// Don't allow a max less than min
            value = Math.max(this.min, value)), "disabled" === key && this.element.toggleClass("ui-state-disabled", !!value).attr("aria-disabled", value), 
            this._super(key, value);
        },
        _percentage: function() {
            return this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (this.options.max - this.min);
        },
        _refreshValue: function() {
            var value = this.options.value, percentage = this._percentage();
            this.valueDiv.toggle(this.indeterminate || value > this.min).toggleClass("ui-corner-right", value === this.options.max).width(percentage.toFixed(0) + "%"), 
            this.element.toggleClass("ui-progressbar-indeterminate", this.indeterminate), this.indeterminate ? (this.element.removeAttr("aria-valuenow"), 
            this.overlayDiv || (this.overlayDiv = $("<div class='ui-progressbar-overlay'></div>").appendTo(this.valueDiv))) : (this.element.attr({
                "aria-valuemax": this.options.max,
                "aria-valuenow": value
            }), this.overlayDiv && (this.overlayDiv.remove(), this.overlayDiv = null)), this.oldValue !== value && (this.oldValue = value, 
            this._trigger("change")), value === this.options.max && this._trigger("complete");
        }
    }), $.widget("ui.selectable", $.ui.mouse, {
        version: "1.11.4",
        options: {
            appendTo: "body",
            autoRefresh: !0,
            distance: 0,
            filter: "*",
            tolerance: "touch",
            // callbacks
            selected: null,
            selecting: null,
            start: null,
            stop: null,
            unselected: null,
            unselecting: null
        },
        _create: function() {
            var selectees, that = this;
            this.element.addClass("ui-selectable"), this.dragged = !1, // cache selectee children based on filter
            this.refresh = function() {
                selectees = $(that.options.filter, that.element[0]), selectees.addClass("ui-selectee"), 
                selectees.each(function() {
                    var $this = $(this), pos = $this.offset();
                    $.data(this, "selectable-item", {
                        element: this,
                        $element: $this,
                        left: pos.left,
                        top: pos.top,
                        right: pos.left + $this.outerWidth(),
                        bottom: pos.top + $this.outerHeight(),
                        startselected: !1,
                        selected: $this.hasClass("ui-selected"),
                        selecting: $this.hasClass("ui-selecting"),
                        unselecting: $this.hasClass("ui-unselecting")
                    });
                });
            }, this.refresh(), this.selectees = selectees.addClass("ui-selectee"), this._mouseInit(), 
            this.helper = $("<div class='ui-selectable-helper'></div>");
        },
        _destroy: function() {
            this.selectees.removeClass("ui-selectee").removeData("selectable-item"), this.element.removeClass("ui-selectable ui-selectable-disabled"), 
            this._mouseDestroy();
        },
        _mouseStart: function(event) {
            var that = this, options = this.options;
            this.opos = [ event.pageX, event.pageY ], this.options.disabled || (this.selectees = $(options.filter, this.element[0]), 
            this._trigger("start", event), $(options.appendTo).append(this.helper), // position helper (lasso)
            this.helper.css({
                left: event.pageX,
                top: event.pageY,
                width: 0,
                height: 0
            }), options.autoRefresh && this.refresh(), this.selectees.filter(".ui-selected").each(function() {
                var selectee = $.data(this, "selectable-item");
                selectee.startselected = !0, event.metaKey || event.ctrlKey || (selectee.$element.removeClass("ui-selected"), 
                selectee.selected = !1, selectee.$element.addClass("ui-unselecting"), selectee.unselecting = !0, 
                // selectable UNSELECTING callback
                that._trigger("unselecting", event, {
                    unselecting: selectee.element
                }));
            }), $(event.target).parents().addBack().each(function() {
                var doSelect, selectee = $.data(this, "selectable-item");
                // selectable (UN)SELECTING callback
                return selectee ? (doSelect = !event.metaKey && !event.ctrlKey || !selectee.$element.hasClass("ui-selected"), 
                selectee.$element.removeClass(doSelect ? "ui-unselecting" : "ui-selected").addClass(doSelect ? "ui-selecting" : "ui-unselecting"), 
                selectee.unselecting = !doSelect, selectee.selecting = doSelect, selectee.selected = doSelect, 
                doSelect ? that._trigger("selecting", event, {
                    selecting: selectee.element
                }) : that._trigger("unselecting", event, {
                    unselecting: selectee.element
                }), !1) : void 0;
            }));
        },
        _mouseDrag: function(event) {
            if (this.dragged = !0, !this.options.disabled) {
                var tmp, that = this, options = this.options, x1 = this.opos[0], y1 = this.opos[1], x2 = event.pageX, y2 = event.pageY;
                return x1 > x2 && (tmp = x2, x2 = x1, x1 = tmp), y1 > y2 && (tmp = y2, y2 = y1, 
                y1 = tmp), this.helper.css({
                    left: x1,
                    top: y1,
                    width: x2 - x1,
                    height: y2 - y1
                }), this.selectees.each(function() {
                    var selectee = $.data(this, "selectable-item"), hit = !1;
                    //prevent helper from being selected if appendTo: selectable
                    selectee && selectee.element !== that.element[0] && ("touch" === options.tolerance ? hit = !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) : "fit" === options.tolerance && (hit = selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2), 
                    hit ? (// SELECT
                    selectee.selected && (selectee.$element.removeClass("ui-selected"), selectee.selected = !1), 
                    selectee.unselecting && (selectee.$element.removeClass("ui-unselecting"), selectee.unselecting = !1), 
                    selectee.selecting || (selectee.$element.addClass("ui-selecting"), selectee.selecting = !0, 
                    // selectable SELECTING callback
                    that._trigger("selecting", event, {
                        selecting: selectee.element
                    }))) : (// UNSELECT
                    selectee.selecting && ((event.metaKey || event.ctrlKey) && selectee.startselected ? (selectee.$element.removeClass("ui-selecting"), 
                    selectee.selecting = !1, selectee.$element.addClass("ui-selected"), selectee.selected = !0) : (selectee.$element.removeClass("ui-selecting"), 
                    selectee.selecting = !1, selectee.startselected && (selectee.$element.addClass("ui-unselecting"), 
                    selectee.unselecting = !0), // selectable UNSELECTING callback
                    that._trigger("unselecting", event, {
                        unselecting: selectee.element
                    }))), selectee.selected && (event.metaKey || event.ctrlKey || selectee.startselected || (selectee.$element.removeClass("ui-selected"), 
                    selectee.selected = !1, selectee.$element.addClass("ui-unselecting"), selectee.unselecting = !0, 
                    // selectable UNSELECTING callback
                    that._trigger("unselecting", event, {
                        unselecting: selectee.element
                    })))));
                }), !1;
            }
        },
        _mouseStop: function(event) {
            var that = this;
            return this.dragged = !1, $(".ui-unselecting", this.element[0]).each(function() {
                var selectee = $.data(this, "selectable-item");
                selectee.$element.removeClass("ui-unselecting"), selectee.unselecting = !1, selectee.startselected = !1, 
                that._trigger("unselected", event, {
                    unselected: selectee.element
                });
            }), $(".ui-selecting", this.element[0]).each(function() {
                var selectee = $.data(this, "selectable-item");
                selectee.$element.removeClass("ui-selecting").addClass("ui-selected"), selectee.selecting = !1, 
                selectee.selected = !0, selectee.startselected = !0, that._trigger("selected", event, {
                    selected: selectee.element
                });
            }), this._trigger("stop", event), this.helper.remove(), !1;
        }
    }), $.widget("ui.selectmenu", {
        version: "1.11.4",
        defaultElement: "<select>",
        options: {
            appendTo: null,
            disabled: null,
            icons: {
                button: "ui-icon-triangle-1-s"
            },
            position: {
                my: "left top",
                at: "left bottom",
                collision: "none"
            },
            width: null,
            // callbacks
            change: null,
            close: null,
            focus: null,
            open: null,
            select: null
        },
        _create: function() {
            var selectmenuId = this.element.uniqueId().attr("id");
            this.ids = {
                element: selectmenuId,
                button: selectmenuId + "-button",
                menu: selectmenuId + "-menu"
            }, this._drawButton(), this._drawMenu(), this.options.disabled && this.disable();
        },
        _drawButton: function() {
            var that = this;
            // Associate existing label with the new button
            this.label = $("label[for='" + this.ids.element + "']").attr("for", this.ids.button), 
            this._on(this.label, {
                click: function(event) {
                    this.button.focus(), event.preventDefault();
                }
            }), // Hide original select element
            this.element.hide(), // Create button
            this.button = $("<span>", {
                "class": "ui-selectmenu-button ui-widget ui-state-default ui-corner-all",
                tabindex: this.options.disabled ? -1 : 0,
                id: this.ids.button,
                role: "combobox",
                "aria-expanded": "false",
                "aria-autocomplete": "list",
                "aria-owns": this.ids.menu,
                "aria-haspopup": "true"
            }).insertAfter(this.element), $("<span>", {
                "class": "ui-icon " + this.options.icons.button
            }).prependTo(this.button), this.buttonText = $("<span>", {
                "class": "ui-selectmenu-text"
            }).appendTo(this.button), this._setText(this.buttonText, this.element.find("option:selected").text()), 
            this._resizeButton(), this._on(this.button, this._buttonEvents), this.button.one("focusin", function() {
                // Delay rendering the menu items until the button receives focus.
                // The menu may have already been rendered via a programmatic open.
                that.menuItems || that._refreshMenu();
            }), this._hoverable(this.button), this._focusable(this.button);
        },
        _drawMenu: function() {
            var that = this;
            // Create menu
            this.menu = $("<ul>", {
                "aria-hidden": "true",
                "aria-labelledby": this.ids.button,
                id: this.ids.menu
            }), // Wrap menu
            this.menuWrap = $("<div>", {
                "class": "ui-selectmenu-menu ui-front"
            }).append(this.menu).appendTo(this._appendTo()), // Initialize menu widget
            this.menuInstance = this.menu.menu({
                role: "listbox",
                select: function(event, ui) {
                    event.preventDefault(), // support: IE8
                    // If the item was selected via a click, the text selection
                    // will be destroyed in IE
                    that._setSelection(), that._select(ui.item.data("ui-selectmenu-item"), event);
                },
                focus: function(event, ui) {
                    var item = ui.item.data("ui-selectmenu-item");
                    // Prevent inital focus from firing and check if its a newly focused item
                    null != that.focusIndex && item.index !== that.focusIndex && (that._trigger("focus", event, {
                        item: item
                    }), that.isOpen || that._select(item, event)), that.focusIndex = item.index, that.button.attr("aria-activedescendant", that.menuItems.eq(item.index).attr("id"));
                }
            }).menu("instance"), // Adjust menu styles to dropdown
            this.menu.addClass("ui-corner-bottom").removeClass("ui-corner-all"), // Don't close the menu on mouseleave
            this.menuInstance._off(this.menu, "mouseleave"), // Cancel the menu's collapseAll on document click
            this.menuInstance._closeOnDocumentClick = function() {
                return !1;
            }, // Selects often contain empty items, but never contain dividers
            this.menuInstance._isDivider = function() {
                return !1;
            };
        },
        refresh: function() {
            this._refreshMenu(), this._setText(this.buttonText, this._getSelectedItem().text()), 
            this.options.width || this._resizeButton();
        },
        _refreshMenu: function() {
            this.menu.empty();
            var item, options = this.element.find("option");
            options.length && (this._parseOptions(options), this._renderMenu(this.menu, this.items), 
            this.menuInstance.refresh(), this.menuItems = this.menu.find("li").not(".ui-selectmenu-optgroup"), 
            item = this._getSelectedItem(), this.menuInstance.focus(null, item), this._setAria(item.data("ui-selectmenu-item")), 
            this._setOption("disabled", this.element.prop("disabled")));
        },
        open: function(event) {
            this.options.disabled || (// If this is the first time the menu is being opened, render the items
            this.menuItems ? (// Menu clears focus on close, reset focus to selected item
            this.menu.find(".ui-state-focus").removeClass("ui-state-focus"), this.menuInstance.focus(null, this._getSelectedItem())) : this._refreshMenu(), 
            this.isOpen = !0, this._toggleAttr(), this._resizeMenu(), this._position(), this._on(this.document, this._documentClick), 
            this._trigger("open", event));
        },
        _position: function() {
            this.menuWrap.position($.extend({
                of: this.button
            }, this.options.position));
        },
        close: function(event) {
            this.isOpen && (this.isOpen = !1, this._toggleAttr(), this.range = null, this._off(this.document), 
            this._trigger("close", event));
        },
        widget: function() {
            return this.button;
        },
        menuWidget: function() {
            return this.menu;
        },
        _renderMenu: function(ul, items) {
            var that = this, currentOptgroup = "";
            $.each(items, function(index, item) {
                item.optgroup !== currentOptgroup && ($("<li>", {
                    "class": "ui-selectmenu-optgroup ui-menu-divider" + (item.element.parent("optgroup").prop("disabled") ? " ui-state-disabled" : ""),
                    text: item.optgroup
                }).appendTo(ul), currentOptgroup = item.optgroup), that._renderItemData(ul, item);
            });
        },
        _renderItemData: function(ul, item) {
            return this._renderItem(ul, item).data("ui-selectmenu-item", item);
        },
        _renderItem: function(ul, item) {
            var li = $("<li>");
            return item.disabled && li.addClass("ui-state-disabled"), this._setText(li, item.label), 
            li.appendTo(ul);
        },
        _setText: function(element, value) {
            value ? element.text(value) : element.html("&#160;");
        },
        _move: function(direction, event) {
            var item, next, filter = ".ui-menu-item";
            this.isOpen ? item = this.menuItems.eq(this.focusIndex) : (item = this.menuItems.eq(this.element[0].selectedIndex), 
            filter += ":not(.ui-state-disabled)"), next = "first" === direction || "last" === direction ? item["first" === direction ? "prevAll" : "nextAll"](filter).eq(-1) : item[direction + "All"](filter).eq(0), 
            next.length && this.menuInstance.focus(event, next);
        },
        _getSelectedItem: function() {
            return this.menuItems.eq(this.element[0].selectedIndex);
        },
        _toggle: function(event) {
            this[this.isOpen ? "close" : "open"](event);
        },
        _setSelection: function() {
            var selection;
            this.range && (window.getSelection ? (selection = window.getSelection(), selection.removeAllRanges(), 
            selection.addRange(this.range)) : this.range.select(), // support: IE
            // Setting the text selection kills the button focus in IE, but
            // restoring the focus doesn't kill the selection.
            this.button.focus());
        },
        _documentClick: {
            mousedown: function(event) {
                this.isOpen && ($(event.target).closest(".ui-selectmenu-menu, #" + this.ids.button).length || this.close(event));
            }
        },
        _buttonEvents: {
            // Prevent text selection from being reset when interacting with the selectmenu (#10144)
            mousedown: function() {
                var selection;
                window.getSelection ? (selection = window.getSelection(), selection.rangeCount && (this.range = selection.getRangeAt(0))) : this.range = document.selection.createRange();
            },
            click: function(event) {
                this._setSelection(), this._toggle(event);
            },
            keydown: function(event) {
                var preventDefault = !0;
                switch (event.keyCode) {
                  case $.ui.keyCode.TAB:
                  case $.ui.keyCode.ESCAPE:
                    this.close(event), preventDefault = !1;
                    break;

                  case $.ui.keyCode.ENTER:
                    this.isOpen && this._selectFocusedItem(event);
                    break;

                  case $.ui.keyCode.UP:
                    event.altKey ? this._toggle(event) : this._move("prev", event);
                    break;

                  case $.ui.keyCode.DOWN:
                    event.altKey ? this._toggle(event) : this._move("next", event);
                    break;

                  case $.ui.keyCode.SPACE:
                    this.isOpen ? this._selectFocusedItem(event) : this._toggle(event);
                    break;

                  case $.ui.keyCode.LEFT:
                    this._move("prev", event);
                    break;

                  case $.ui.keyCode.RIGHT:
                    this._move("next", event);
                    break;

                  case $.ui.keyCode.HOME:
                  case $.ui.keyCode.PAGE_UP:
                    this._move("first", event);
                    break;

                  case $.ui.keyCode.END:
                  case $.ui.keyCode.PAGE_DOWN:
                    this._move("last", event);
                    break;

                  default:
                    this.menu.trigger(event), preventDefault = !1;
                }
                preventDefault && event.preventDefault();
            }
        },
        _selectFocusedItem: function(event) {
            var item = this.menuItems.eq(this.focusIndex);
            item.hasClass("ui-state-disabled") || this._select(item.data("ui-selectmenu-item"), event);
        },
        _select: function(item, event) {
            var oldIndex = this.element[0].selectedIndex;
            // Change native select element
            this.element[0].selectedIndex = item.index, this._setText(this.buttonText, item.label), 
            this._setAria(item), this._trigger("select", event, {
                item: item
            }), item.index !== oldIndex && this._trigger("change", event, {
                item: item
            }), this.close(event);
        },
        _setAria: function(item) {
            var id = this.menuItems.eq(item.index).attr("id");
            this.button.attr({
                "aria-labelledby": id,
                "aria-activedescendant": id
            }), this.menu.attr("aria-activedescendant", id);
        },
        _setOption: function(key, value) {
            "icons" === key && this.button.find("span.ui-icon").removeClass(this.options.icons.button).addClass(value.button), 
            this._super(key, value), "appendTo" === key && this.menuWrap.appendTo(this._appendTo()), 
            "disabled" === key && (this.menuInstance.option("disabled", value), this.button.toggleClass("ui-state-disabled", value).attr("aria-disabled", value), 
            this.element.prop("disabled", value), value ? (this.button.attr("tabindex", -1), 
            this.close()) : this.button.attr("tabindex", 0)), "width" === key && this._resizeButton();
        },
        _appendTo: function() {
            var element = this.options.appendTo;
            return element && (element = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0)), 
            element && element[0] || (element = this.element.closest(".ui-front")), element.length || (element = this.document[0].body), 
            element;
        },
        _toggleAttr: function() {
            this.button.toggleClass("ui-corner-top", this.isOpen).toggleClass("ui-corner-all", !this.isOpen).attr("aria-expanded", this.isOpen), 
            this.menuWrap.toggleClass("ui-selectmenu-open", this.isOpen), this.menu.attr("aria-hidden", !this.isOpen);
        },
        _resizeButton: function() {
            var width = this.options.width;
            width || (width = this.element.show().outerWidth(), this.element.hide()), this.button.outerWidth(width);
        },
        _resizeMenu: function() {
            this.menu.outerWidth(Math.max(this.button.outerWidth(), // support: IE10
            // IE10 wraps long text (possibly a rounding bug)
            // so we add 1px to avoid the wrapping
            this.menu.width("").outerWidth() + 1));
        },
        _getCreateOptions: function() {
            return {
                disabled: this.element.prop("disabled")
            };
        },
        _parseOptions: function(options) {
            var data = [];
            options.each(function(index, item) {
                var option = $(item), optgroup = option.parent("optgroup");
                data.push({
                    element: option,
                    index: index,
                    value: option.val(),
                    label: option.text(),
                    optgroup: optgroup.attr("label") || "",
                    disabled: optgroup.prop("disabled") || option.prop("disabled")
                });
            }), this.items = data;
        },
        _destroy: function() {
            this.menuWrap.remove(), this.button.remove(), this.element.show(), this.element.removeUniqueId(), 
            this.label.attr("for", this.ids.element);
        }
    }), $.widget("ui.slider", $.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "slide",
        options: {
            animate: !1,
            distance: 0,
            max: 100,
            min: 0,
            orientation: "horizontal",
            range: !1,
            step: 1,
            value: 0,
            values: null,
            // callbacks
            change: null,
            slide: null,
            start: null,
            stop: null
        },
        // number of pages in a slider
        // (how many times can you page up/down to go through the whole range)
        numPages: 5,
        _create: function() {
            this._keySliding = !1, this._mouseSliding = !1, this._animateOff = !0, this._handleIndex = null, 
            this._detectOrientation(), this._mouseInit(), this._calculateNewMax(), this.element.addClass("ui-slider ui-slider-" + this.orientation + " ui-widget ui-widget-content ui-corner-all"), 
            this._refresh(), this._setOption("disabled", this.options.disabled), this._animateOff = !1;
        },
        _refresh: function() {
            this._createRange(), this._createHandles(), this._setupEvents(), this._refreshValue();
        },
        _createHandles: function() {
            var i, handleCount, options = this.options, existingHandles = this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"), handle = "<span class='ui-slider-handle ui-state-default ui-corner-all' tabindex='0'></span>", handles = [];
            for (handleCount = options.values && options.values.length || 1, existingHandles.length > handleCount && (existingHandles.slice(handleCount).remove(), 
            existingHandles = existingHandles.slice(0, handleCount)), i = existingHandles.length; handleCount > i; i++) handles.push(handle);
            this.handles = existingHandles.add($(handles.join("")).appendTo(this.element)), 
            this.handle = this.handles.eq(0), this.handles.each(function(i) {
                $(this).data("ui-slider-handle-index", i);
            });
        },
        _createRange: function() {
            var options = this.options, classes = "";
            options.range ? (options.range === !0 && (options.values ? options.values.length && 2 !== options.values.length ? options.values = [ options.values[0], options.values[0] ] : $.isArray(options.values) && (options.values = options.values.slice(0)) : options.values = [ this._valueMin(), this._valueMin() ]), 
            this.range && this.range.length ? this.range.removeClass("ui-slider-range-min ui-slider-range-max").css({
                left: "",
                bottom: ""
            }) : (this.range = $("<div></div>").appendTo(this.element), classes = "ui-slider-range ui-widget-header ui-corner-all"), 
            this.range.addClass(classes + ("min" === options.range || "max" === options.range ? " ui-slider-range-" + options.range : ""))) : (this.range && this.range.remove(), 
            this.range = null);
        },
        _setupEvents: function() {
            this._off(this.handles), this._on(this.handles, this._handleEvents), this._hoverable(this.handles), 
            this._focusable(this.handles);
        },
        _destroy: function() {
            this.handles.remove(), this.range && this.range.remove(), this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical ui-widget ui-widget-content ui-corner-all"), 
            this._mouseDestroy();
        },
        _mouseCapture: function(event) {
            var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle, that = this, o = this.options;
            return o.disabled ? !1 : (this.elementSize = {
                width: this.element.outerWidth(),
                height: this.element.outerHeight()
            }, this.elementOffset = this.element.offset(), position = {
                x: event.pageX,
                y: event.pageY
            }, normValue = this._normValueFromMouse(position), distance = this._valueMax() - this._valueMin() + 1, 
            this.handles.each(function(i) {
                var thisDistance = Math.abs(normValue - that.values(i));
                (distance > thisDistance || distance === thisDistance && (i === that._lastChangedValue || that.values(i) === o.min)) && (distance = thisDistance, 
                closestHandle = $(this), index = i);
            }), allowed = this._start(event, index), allowed === !1 ? !1 : (this._mouseSliding = !0, 
            this._handleIndex = index, closestHandle.addClass("ui-state-active").focus(), offset = closestHandle.offset(), 
            mouseOverHandle = !$(event.target).parents().addBack().is(".ui-slider-handle"), 
            this._clickOffset = mouseOverHandle ? {
                left: 0,
                top: 0
            } : {
                left: event.pageX - offset.left - closestHandle.width() / 2,
                top: event.pageY - offset.top - closestHandle.height() / 2 - (parseInt(closestHandle.css("borderTopWidth"), 10) || 0) - (parseInt(closestHandle.css("borderBottomWidth"), 10) || 0) + (parseInt(closestHandle.css("marginTop"), 10) || 0)
            }, this.handles.hasClass("ui-state-hover") || this._slide(event, index, normValue), 
            this._animateOff = !0, !0));
        },
        _mouseStart: function() {
            return !0;
        },
        _mouseDrag: function(event) {
            var position = {
                x: event.pageX,
                y: event.pageY
            }, normValue = this._normValueFromMouse(position);
            return this._slide(event, this._handleIndex, normValue), !1;
        },
        _mouseStop: function(event) {
            return this.handles.removeClass("ui-state-active"), this._mouseSliding = !1, this._stop(event, this._handleIndex), 
            this._change(event, this._handleIndex), this._handleIndex = null, this._clickOffset = null, 
            this._animateOff = !1, !1;
        },
        _detectOrientation: function() {
            this.orientation = "vertical" === this.options.orientation ? "vertical" : "horizontal";
        },
        _normValueFromMouse: function(position) {
            var pixelTotal, pixelMouse, percentMouse, valueTotal, valueMouse;
            return "horizontal" === this.orientation ? (pixelTotal = this.elementSize.width, 
            pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0)) : (pixelTotal = this.elementSize.height, 
            pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0)), 
            percentMouse = pixelMouse / pixelTotal, percentMouse > 1 && (percentMouse = 1), 
            0 > percentMouse && (percentMouse = 0), "vertical" === this.orientation && (percentMouse = 1 - percentMouse), 
            valueTotal = this._valueMax() - this._valueMin(), valueMouse = this._valueMin() + percentMouse * valueTotal, 
            this._trimAlignValue(valueMouse);
        },
        _start: function(event, index) {
            var uiHash = {
                handle: this.handles[index],
                value: this.value()
            };
            return this.options.values && this.options.values.length && (uiHash.value = this.values(index), 
            uiHash.values = this.values()), this._trigger("start", event, uiHash);
        },
        _slide: function(event, index, newVal) {
            var otherVal, newValues, allowed;
            this.options.values && this.options.values.length ? (otherVal = this.values(index ? 0 : 1), 
            2 === this.options.values.length && this.options.range === !0 && (0 === index && newVal > otherVal || 1 === index && otherVal > newVal) && (newVal = otherVal), 
            newVal !== this.values(index) && (newValues = this.values(), newValues[index] = newVal, 
            allowed = this._trigger("slide", event, {
                handle: this.handles[index],
                value: newVal,
                values: newValues
            }), otherVal = this.values(index ? 0 : 1), allowed !== !1 && this.values(index, newVal))) : newVal !== this.value() && (allowed = this._trigger("slide", event, {
                handle: this.handles[index],
                value: newVal
            }), allowed !== !1 && this.value(newVal));
        },
        _stop: function(event, index) {
            var uiHash = {
                handle: this.handles[index],
                value: this.value()
            };
            this.options.values && this.options.values.length && (uiHash.value = this.values(index), 
            uiHash.values = this.values()), this._trigger("stop", event, uiHash);
        },
        _change: function(event, index) {
            if (!this._keySliding && !this._mouseSliding) {
                var uiHash = {
                    handle: this.handles[index],
                    value: this.value()
                };
                this.options.values && this.options.values.length && (uiHash.value = this.values(index), 
                uiHash.values = this.values()), //store the last changed value index for reference when handles overlap
                this._lastChangedValue = index, this._trigger("change", event, uiHash);
            }
        },
        value: function(newValue) {
            return arguments.length ? (this.options.value = this._trimAlignValue(newValue), 
            this._refreshValue(), void this._change(null, 0)) : this._value();
        },
        values: function(index, newValue) {
            var vals, newValues, i;
            if (arguments.length > 1) return this.options.values[index] = this._trimAlignValue(newValue), 
            this._refreshValue(), void this._change(null, index);
            if (!arguments.length) return this._values();
            if (!$.isArray(arguments[0])) return this.options.values && this.options.values.length ? this._values(index) : this.value();
            for (vals = this.options.values, newValues = arguments[0], i = 0; i < vals.length; i += 1) vals[i] = this._trimAlignValue(newValues[i]), 
            this._change(null, i);
            this._refreshValue();
        },
        _setOption: function(key, value) {
            var i, valsLength = 0;
            switch ("range" === key && this.options.range === !0 && ("min" === value ? (this.options.value = this._values(0), 
            this.options.values = null) : "max" === value && (this.options.value = this._values(this.options.values.length - 1), 
            this.options.values = null)), $.isArray(this.options.values) && (valsLength = this.options.values.length), 
            "disabled" === key && this.element.toggleClass("ui-state-disabled", !!value), this._super(key, value), 
            key) {
              case "orientation":
                this._detectOrientation(), this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-" + this.orientation), 
                this._refreshValue(), // Reset positioning from previous orientation
                this.handles.css("horizontal" === value ? "bottom" : "left", "");
                break;

              case "value":
                this._animateOff = !0, this._refreshValue(), this._change(null, 0), this._animateOff = !1;
                break;

              case "values":
                for (this._animateOff = !0, this._refreshValue(), i = 0; valsLength > i; i += 1) this._change(null, i);
                this._animateOff = !1;
                break;

              case "step":
              case "min":
              case "max":
                this._animateOff = !0, this._calculateNewMax(), this._refreshValue(), this._animateOff = !1;
                break;

              case "range":
                this._animateOff = !0, this._refresh(), this._animateOff = !1;
            }
        },
        //internal value getter
        // _value() returns value trimmed by min and max, aligned by step
        _value: function() {
            var val = this.options.value;
            return val = this._trimAlignValue(val);
        },
        //internal values getter
        // _values() returns array of values trimmed by min and max, aligned by step
        // _values( index ) returns single value trimmed by min and max, aligned by step
        _values: function(index) {
            var val, vals, i;
            if (arguments.length) return val = this.options.values[index], val = this._trimAlignValue(val);
            if (this.options.values && this.options.values.length) {
                for (vals = this.options.values.slice(), i = 0; i < vals.length; i += 1) vals[i] = this._trimAlignValue(vals[i]);
                return vals;
            }
            return [];
        },
        // returns the step-aligned value that val is closest to, between (inclusive) min and max
        _trimAlignValue: function(val) {
            if (val <= this._valueMin()) return this._valueMin();
            if (val >= this._valueMax()) return this._valueMax();
            var step = this.options.step > 0 ? this.options.step : 1, valModStep = (val - this._valueMin()) % step, alignValue = val - valModStep;
            // Since JavaScript has problems with large floats, round
            // the final value to 5 digits after the decimal point (see #4124)
            return 2 * Math.abs(valModStep) >= step && (alignValue += valModStep > 0 ? step : -step), 
            parseFloat(alignValue.toFixed(5));
        },
        _calculateNewMax: function() {
            var max = this.options.max, min = this._valueMin(), step = this.options.step, aboveMin = Math.floor(+(max - min).toFixed(this._precision()) / step) * step;
            max = aboveMin + min, this.max = parseFloat(max.toFixed(this._precision()));
        },
        _precision: function() {
            var precision = this._precisionOf(this.options.step);
            return null !== this.options.min && (precision = Math.max(precision, this._precisionOf(this.options.min))), 
            precision;
        },
        _precisionOf: function(num) {
            var str = num.toString(), decimal = str.indexOf(".");
            return -1 === decimal ? 0 : str.length - decimal - 1;
        },
        _valueMin: function() {
            return this.options.min;
        },
        _valueMax: function() {
            return this.max;
        },
        _refreshValue: function() {
            var lastValPercent, valPercent, value, valueMin, valueMax, oRange = this.options.range, o = this.options, that = this, animate = this._animateOff ? !1 : o.animate, _set = {};
            this.options.values && this.options.values.length ? this.handles.each(function(i) {
                valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100, 
                _set["horizontal" === that.orientation ? "left" : "bottom"] = valPercent + "%", 
                $(this).stop(1, 1)[animate ? "animate" : "css"](_set, o.animate), that.options.range === !0 && ("horizontal" === that.orientation ? (0 === i && that.range.stop(1, 1)[animate ? "animate" : "css"]({
                    left: valPercent + "%"
                }, o.animate), 1 === i && that.range[animate ? "animate" : "css"]({
                    width: valPercent - lastValPercent + "%"
                }, {
                    queue: !1,
                    duration: o.animate
                })) : (0 === i && that.range.stop(1, 1)[animate ? "animate" : "css"]({
                    bottom: valPercent + "%"
                }, o.animate), 1 === i && that.range[animate ? "animate" : "css"]({
                    height: valPercent - lastValPercent + "%"
                }, {
                    queue: !1,
                    duration: o.animate
                }))), lastValPercent = valPercent;
            }) : (value = this.value(), valueMin = this._valueMin(), valueMax = this._valueMax(), 
            valPercent = valueMax !== valueMin ? (value - valueMin) / (valueMax - valueMin) * 100 : 0, 
            _set["horizontal" === this.orientation ? "left" : "bottom"] = valPercent + "%", 
            this.handle.stop(1, 1)[animate ? "animate" : "css"](_set, o.animate), "min" === oRange && "horizontal" === this.orientation && this.range.stop(1, 1)[animate ? "animate" : "css"]({
                width: valPercent + "%"
            }, o.animate), "max" === oRange && "horizontal" === this.orientation && this.range[animate ? "animate" : "css"]({
                width: 100 - valPercent + "%"
            }, {
                queue: !1,
                duration: o.animate
            }), "min" === oRange && "vertical" === this.orientation && this.range.stop(1, 1)[animate ? "animate" : "css"]({
                height: valPercent + "%"
            }, o.animate), "max" === oRange && "vertical" === this.orientation && this.range[animate ? "animate" : "css"]({
                height: 100 - valPercent + "%"
            }, {
                queue: !1,
                duration: o.animate
            }));
        },
        _handleEvents: {
            keydown: function(event) {
                var allowed, curVal, newVal, step, index = $(event.target).data("ui-slider-handle-index");
                switch (event.keyCode) {
                  case $.ui.keyCode.HOME:
                  case $.ui.keyCode.END:
                  case $.ui.keyCode.PAGE_UP:
                  case $.ui.keyCode.PAGE_DOWN:
                  case $.ui.keyCode.UP:
                  case $.ui.keyCode.RIGHT:
                  case $.ui.keyCode.DOWN:
                  case $.ui.keyCode.LEFT:
                    if (event.preventDefault(), !this._keySliding && (this._keySliding = !0, $(event.target).addClass("ui-state-active"), 
                    allowed = this._start(event, index), allowed === !1)) return;
                }
                switch (step = this.options.step, curVal = newVal = this.options.values && this.options.values.length ? this.values(index) : this.value(), 
                event.keyCode) {
                  case $.ui.keyCode.HOME:
                    newVal = this._valueMin();
                    break;

                  case $.ui.keyCode.END:
                    newVal = this._valueMax();
                    break;

                  case $.ui.keyCode.PAGE_UP:
                    newVal = this._trimAlignValue(curVal + (this._valueMax() - this._valueMin()) / this.numPages);
                    break;

                  case $.ui.keyCode.PAGE_DOWN:
                    newVal = this._trimAlignValue(curVal - (this._valueMax() - this._valueMin()) / this.numPages);
                    break;

                  case $.ui.keyCode.UP:
                  case $.ui.keyCode.RIGHT:
                    if (curVal === this._valueMax()) return;
                    newVal = this._trimAlignValue(curVal + step);
                    break;

                  case $.ui.keyCode.DOWN:
                  case $.ui.keyCode.LEFT:
                    if (curVal === this._valueMin()) return;
                    newVal = this._trimAlignValue(curVal - step);
                }
                this._slide(event, index, newVal);
            },
            keyup: function(event) {
                var index = $(event.target).data("ui-slider-handle-index");
                this._keySliding && (this._keySliding = !1, this._stop(event, index), this._change(event, index), 
                $(event.target).removeClass("ui-state-active"));
            }
        }
    }), $.widget("ui.sortable", $.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "sort",
        ready: !1,
        options: {
            appendTo: "parent",
            axis: !1,
            connectWith: !1,
            containment: !1,
            cursor: "auto",
            cursorAt: !1,
            dropOnEmpty: !0,
            forcePlaceholderSize: !1,
            forceHelperSize: !1,
            grid: !1,
            handle: !1,
            helper: "original",
            items: "> *",
            opacity: !1,
            placeholder: !1,
            revert: !1,
            scroll: !0,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            scope: "default",
            tolerance: "intersect",
            zIndex: 1e3,
            // callbacks
            activate: null,
            beforeStop: null,
            change: null,
            deactivate: null,
            out: null,
            over: null,
            receive: null,
            remove: null,
            sort: null,
            start: null,
            stop: null,
            update: null
        },
        _isOverAxis: function(x, reference, size) {
            return x >= reference && reference + size > x;
        },
        _isFloating: function(item) {
            return /left|right/.test(item.css("float")) || /inline|table-cell/.test(item.css("display"));
        },
        _create: function() {
            this.containerCache = {}, this.element.addClass("ui-sortable"), //Get the items
            this.refresh(), //Let's determine the parent's offset
            this.offset = this.element.offset(), //Initialize mouse events for interaction
            this._mouseInit(), this._setHandleClassName(), //We're ready to go
            this.ready = !0;
        },
        _setOption: function(key, value) {
            this._super(key, value), "handle" === key && this._setHandleClassName();
        },
        _setHandleClassName: function() {
            this.element.find(".ui-sortable-handle").removeClass("ui-sortable-handle"), $.each(this.items, function() {
                (this.instance.options.handle ? this.item.find(this.instance.options.handle) : this.item).addClass("ui-sortable-handle");
            });
        },
        _destroy: function() {
            this.element.removeClass("ui-sortable ui-sortable-disabled").find(".ui-sortable-handle").removeClass("ui-sortable-handle"), 
            this._mouseDestroy();
            for (var i = this.items.length - 1; i >= 0; i--) this.items[i].item.removeData(this.widgetName + "-item");
            return this;
        },
        _mouseCapture: function(event, overrideHandle) {
            var currentItem = null, validHandle = !1, that = this;
            //We have to refresh the items data once first
            //Find out if the clicked node (or one of its parents) is a actual item in this.items
            return this.reverting ? !1 : this.options.disabled || "static" === this.options.type ? !1 : (this._refreshItems(event), 
            $(event.target).parents().each(function() {
                return $.data(this, that.widgetName + "-item") === that ? (currentItem = $(this), 
                !1) : void 0;
            }), $.data(event.target, that.widgetName + "-item") === that && (currentItem = $(event.target)), 
            currentItem && (!this.options.handle || overrideHandle || ($(this.options.handle, currentItem).find("*").addBack().each(function() {
                this === event.target && (validHandle = !0);
            }), validHandle)) ? (this.currentItem = currentItem, this._removeCurrentsFromItems(), 
            !0) : !1);
        },
        _mouseStart: function(event, overrideHandle, noActivation) {
            var i, body, o = this.options;
            //Post "activate" events to possible containers
            if (this.currentContainer = this, //We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
            this.refreshPositions(), //Create and append the visible helper
            this.helper = this._createHelper(event), //Cache the helper size
            this._cacheHelperProportions(), /*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */
            //Cache the margins of the original element
            this._cacheMargins(), //Get the next scrolling parent
            this.scrollParent = this.helper.scrollParent(), //The element's absolute position on the page minus margins
            this.offset = this.currentItem.offset(), this.offset = {
                top: this.offset.top - this.margins.top,
                left: this.offset.left - this.margins.left
            }, $.extend(this.offset, {
                click: {
                    //Where the click happened, relative to the element
                    left: event.pageX - this.offset.left,
                    top: event.pageY - this.offset.top
                },
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            }), // Only after we got the offset, we can change the helper's position to absolute
            // TODO: Still need to figure out a way to make relative sorting possible
            this.helper.css("position", "absolute"), this.cssPosition = this.helper.css("position"), 
            //Generate the original position
            this.originalPosition = this._generatePosition(event), this.originalPageX = event.pageX, 
            this.originalPageY = event.pageY, //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
            o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt), //Cache the former DOM position
            this.domPosition = {
                prev: this.currentItem.prev()[0],
                parent: this.currentItem.parent()[0]
            }, //If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
            this.helper[0] !== this.currentItem[0] && this.currentItem.hide(), //Create the placeholder
            this._createPlaceholder(), //Set a containment if given in the options
            o.containment && this._setContainment(), o.cursor && "auto" !== o.cursor && (body = this.document.find("body"), 
            this.storedCursor = body.css("cursor"), body.css("cursor", o.cursor), this.storedStylesheet = $("<style>*{ cursor: " + o.cursor + " !important; }</style>").appendTo(body)), 
            o.opacity && (// opacity option
            this.helper.css("opacity") && (this._storedOpacity = this.helper.css("opacity")), 
            this.helper.css("opacity", o.opacity)), o.zIndex && (// zIndex option
            this.helper.css("zIndex") && (this._storedZIndex = this.helper.css("zIndex")), this.helper.css("zIndex", o.zIndex)), 
            //Prepare scrolling
            this.scrollParent[0] !== this.document[0] && "HTML" !== this.scrollParent[0].tagName && (this.overflowOffset = this.scrollParent.offset()), 
            //Call callbacks
            this._trigger("start", event, this._uiHash()), //Recache the helper size
            this._preserveHelperProportions || this._cacheHelperProportions(), !noActivation) for (i = this.containers.length - 1; i >= 0; i--) this.containers[i]._trigger("activate", event, this._uiHash(this));
            //Execute the drag once - this causes the helper not to be visible before getting its correct position
            //Prepare possible droppables
            return $.ui.ddmanager && ($.ui.ddmanager.current = this), $.ui.ddmanager && !o.dropBehaviour && $.ui.ddmanager.prepareOffsets(this, event), 
            this.dragging = !0, this.helper.addClass("ui-sortable-helper"), this._mouseDrag(event), 
            !0;
        },
        _mouseDrag: function(event) {
            var i, item, itemElement, intersection, o = this.options, scrolled = !1;
            //Rearrange
            for (//Compute the helpers position
            this.position = this._generatePosition(event), this.positionAbs = this._convertPositionTo("absolute"), 
            this.lastPositionAbs || (this.lastPositionAbs = this.positionAbs), //Do scrolling
            this.options.scroll && (this.scrollParent[0] !== this.document[0] && "HTML" !== this.scrollParent[0].tagName ? (this.overflowOffset.top + this.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity ? this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed : event.pageY - this.overflowOffset.top < o.scrollSensitivity && (this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed), 
            this.overflowOffset.left + this.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity ? this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed : event.pageX - this.overflowOffset.left < o.scrollSensitivity && (this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed)) : (event.pageY - this.document.scrollTop() < o.scrollSensitivity ? scrolled = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed) : this.window.height() - (event.pageY - this.document.scrollTop()) < o.scrollSensitivity && (scrolled = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed)), 
            event.pageX - this.document.scrollLeft() < o.scrollSensitivity ? scrolled = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed) : this.window.width() - (event.pageX - this.document.scrollLeft()) < o.scrollSensitivity && (scrolled = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed))), 
            scrolled !== !1 && $.ui.ddmanager && !o.dropBehaviour && $.ui.ddmanager.prepareOffsets(this, event)), 
            //Regenerate the absolute position used for position checks
            this.positionAbs = this._convertPositionTo("absolute"), //Set the helper position
            this.options.axis && "y" === this.options.axis || (this.helper[0].style.left = this.position.left + "px"), 
            this.options.axis && "x" === this.options.axis || (this.helper[0].style.top = this.position.top + "px"), 
            i = this.items.length - 1; i >= 0; i--) if (item = this.items[i], itemElement = item.item[0], 
            intersection = this._intersectsWithPointer(item), intersection && item.instance === this.currentContainer && itemElement !== this.currentItem[0] && this.placeholder[1 === intersection ? "next" : "prev"]()[0] !== itemElement && !$.contains(this.placeholder[0], itemElement) && ("semi-dynamic" === this.options.type ? !$.contains(this.element[0], itemElement) : !0)) {
                if (this.direction = 1 === intersection ? "down" : "up", "pointer" !== this.options.tolerance && !this._intersectsWithSides(item)) break;
                this._rearrange(event, item), this._trigger("change", event, this._uiHash());
                break;
            }
            //Post events to containers
            //Interconnect with droppables
            //Call callbacks
            return this._contactContainers(event), $.ui.ddmanager && $.ui.ddmanager.drag(this, event), 
            this._trigger("sort", event, this._uiHash()), this.lastPositionAbs = this.positionAbs, 
            !1;
        },
        _mouseStop: function(event, noPropagation) {
            if (event) {
                if (//If we are using droppables, inform the manager about the drop
                $.ui.ddmanager && !this.options.dropBehaviour && $.ui.ddmanager.drop(this, event), 
                this.options.revert) {
                    var that = this, cur = this.placeholder.offset(), axis = this.options.axis, animation = {};
                    axis && "x" !== axis || (animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft)), 
                    axis && "y" !== axis || (animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop)), 
                    this.reverting = !0, $(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500, function() {
                        that._clear(event);
                    });
                } else this._clear(event, noPropagation);
                return !1;
            }
        },
        cancel: function() {
            if (this.dragging) {
                this._mouseUp({
                    target: null
                }), "original" === this.options.helper ? this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper") : this.currentItem.show();
                //Post deactivating events to containers
                for (var i = this.containers.length - 1; i >= 0; i--) this.containers[i]._trigger("deactivate", null, this._uiHash(this)), 
                this.containers[i].containerCache.over && (this.containers[i]._trigger("out", null, this._uiHash(this)), 
                this.containers[i].containerCache.over = 0);
            }
            //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
            return this.placeholder && (this.placeholder[0].parentNode && this.placeholder[0].parentNode.removeChild(this.placeholder[0]), 
            "original" !== this.options.helper && this.helper && this.helper[0].parentNode && this.helper.remove(), 
            $.extend(this, {
                helper: null,
                dragging: !1,
                reverting: !1,
                _noFinalSort: null
            }), this.domPosition.prev ? $(this.domPosition.prev).after(this.currentItem) : $(this.domPosition.parent).prepend(this.currentItem)), 
            this;
        },
        serialize: function(o) {
            var items = this._getItemsAsjQuery(o && o.connected), str = [];
            return o = o || {}, $(items).each(function() {
                var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || /(.+)[\-=_](.+)/);
                res && str.push((o.key || res[1] + "[]") + "=" + (o.key && o.expression ? res[1] : res[2]));
            }), !str.length && o.key && str.push(o.key + "="), str.join("&");
        },
        toArray: function(o) {
            var items = this._getItemsAsjQuery(o && o.connected), ret = [];
            return o = o || {}, items.each(function() {
                ret.push($(o.item || this).attr(o.attribute || "id") || "");
            }), ret;
        },
        /* Be careful with the following core functions */
        _intersectsWith: function(item) {
            var x1 = this.positionAbs.left, x2 = x1 + this.helperProportions.width, y1 = this.positionAbs.top, y2 = y1 + this.helperProportions.height, l = item.left, r = l + item.width, t = item.top, b = t + item.height, dyClick = this.offset.click.top, dxClick = this.offset.click.left, isOverElementHeight = "x" === this.options.axis || y1 + dyClick > t && b > y1 + dyClick, isOverElementWidth = "y" === this.options.axis || x1 + dxClick > l && r > x1 + dxClick, isOverElement = isOverElementHeight && isOverElementWidth;
            // Right Half
            // Left Half
            // Bottom Half
            return "pointer" === this.options.tolerance || this.options.forcePointerForContainers || "pointer" !== this.options.tolerance && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"] ? isOverElement : l < x1 + this.helperProportions.width / 2 && x2 - this.helperProportions.width / 2 < r && t < y1 + this.helperProportions.height / 2 && y2 - this.helperProportions.height / 2 < b;
        },
        _intersectsWithPointer: function(item) {
            var isOverElementHeight = "x" === this.options.axis || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height), isOverElementWidth = "y" === this.options.axis || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width), isOverElement = isOverElementHeight && isOverElementWidth, verticalDirection = this._getDragVerticalDirection(), horizontalDirection = this._getDragHorizontalDirection();
            return isOverElement ? this.floating ? horizontalDirection && "right" === horizontalDirection || "down" === verticalDirection ? 2 : 1 : verticalDirection && ("down" === verticalDirection ? 2 : 1) : !1;
        },
        _intersectsWithSides: function(item) {
            var isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + item.height / 2, item.height), isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + item.width / 2, item.width), verticalDirection = this._getDragVerticalDirection(), horizontalDirection = this._getDragHorizontalDirection();
            return this.floating && horizontalDirection ? "right" === horizontalDirection && isOverRightHalf || "left" === horizontalDirection && !isOverRightHalf : verticalDirection && ("down" === verticalDirection && isOverBottomHalf || "up" === verticalDirection && !isOverBottomHalf);
        },
        _getDragVerticalDirection: function() {
            var delta = this.positionAbs.top - this.lastPositionAbs.top;
            return 0 !== delta && (delta > 0 ? "down" : "up");
        },
        _getDragHorizontalDirection: function() {
            var delta = this.positionAbs.left - this.lastPositionAbs.left;
            return 0 !== delta && (delta > 0 ? "right" : "left");
        },
        refresh: function(event) {
            return this._refreshItems(event), this._setHandleClassName(), this.refreshPositions(), 
            this;
        },
        _connectWith: function() {
            var options = this.options;
            return options.connectWith.constructor === String ? [ options.connectWith ] : options.connectWith;
        },
        _getItemsAsjQuery: function(connected) {
            function addItems() {
                items.push(this);
            }
            var i, j, cur, inst, items = [], queries = [], connectWith = this._connectWith();
            if (connectWith && connected) for (i = connectWith.length - 1; i >= 0; i--) for (cur = $(connectWith[i], this.document[0]), 
            j = cur.length - 1; j >= 0; j--) inst = $.data(cur[j], this.widgetFullName), inst && inst !== this && !inst.options.disabled && queries.push([ $.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst ]);
            for (queries.push([ $.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
                options: this.options,
                item: this.currentItem
            }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this ]), 
            i = queries.length - 1; i >= 0; i--) queries[i][0].each(addItems);
            return $(items);
        },
        _removeCurrentsFromItems: function() {
            var list = this.currentItem.find(":data(" + this.widgetName + "-item)");
            this.items = $.grep(this.items, function(item) {
                for (var j = 0; j < list.length; j++) if (list[j] === item.item[0]) return !1;
                return !0;
            });
        },
        _refreshItems: function(event) {
            this.items = [], this.containers = [ this ];
            var i, j, cur, inst, targetData, _queries, item, queriesLength, items = this.items, queries = [ [ $.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, {
                item: this.currentItem
            }) : $(this.options.items, this.element), this ] ], connectWith = this._connectWith();
            if (connectWith && this.ready) //Shouldn't be run the first time through due to massive slow-down
            for (i = connectWith.length - 1; i >= 0; i--) for (cur = $(connectWith[i], this.document[0]), 
            j = cur.length - 1; j >= 0; j--) inst = $.data(cur[j], this.widgetFullName), inst && inst !== this && !inst.options.disabled && (queries.push([ $.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, {
                item: this.currentItem
            }) : $(inst.options.items, inst.element), inst ]), this.containers.push(inst));
            for (i = queries.length - 1; i >= 0; i--) for (targetData = queries[i][1], _queries = queries[i][0], 
            j = 0, queriesLength = _queries.length; queriesLength > j; j++) item = $(_queries[j]), 
            item.data(this.widgetName + "-item", targetData), items.push({
                item: item,
                instance: targetData,
                width: 0,
                height: 0,
                left: 0,
                top: 0
            });
        },
        refreshPositions: function(fast) {
            // Determine whether items are being displayed horizontally
            this.floating = this.items.length ? "x" === this.options.axis || this._isFloating(this.items[0].item) : !1, 
            //This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
            this.offsetParent && this.helper && (this.offset.parent = this._getParentOffset());
            var i, item, t, p;
            for (i = this.items.length - 1; i >= 0; i--) item = this.items[i], item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0] || (t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item, 
            fast || (item.width = t.outerWidth(), item.height = t.outerHeight()), p = t.offset(), 
            item.left = p.left, item.top = p.top);
            if (this.options.custom && this.options.custom.refreshContainers) this.options.custom.refreshContainers.call(this); else for (i = this.containers.length - 1; i >= 0; i--) p = this.containers[i].element.offset(), 
            this.containers[i].containerCache.left = p.left, this.containers[i].containerCache.top = p.top, 
            this.containers[i].containerCache.width = this.containers[i].element.outerWidth(), 
            this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
            return this;
        },
        _createPlaceholder: function(that) {
            that = that || this;
            var className, o = that.options;
            o.placeholder && o.placeholder.constructor !== String || (className = o.placeholder, 
            o.placeholder = {
                element: function() {
                    var nodeName = that.currentItem[0].nodeName.toLowerCase(), element = $("<" + nodeName + ">", that.document[0]).addClass(className || that.currentItem[0].className + " ui-sortable-placeholder").removeClass("ui-sortable-helper");
                    return "tbody" === nodeName ? that._createTrPlaceholder(that.currentItem.find("tr").eq(0), $("<tr>", that.document[0]).appendTo(element)) : "tr" === nodeName ? that._createTrPlaceholder(that.currentItem, element) : "img" === nodeName && element.attr("src", that.currentItem.attr("src")), 
                    className || element.css("visibility", "hidden"), element;
                },
                update: function(container, p) {
                    (!className || o.forcePlaceholderSize) && (p.height() || p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop") || 0, 10) - parseInt(that.currentItem.css("paddingBottom") || 0, 10)), 
                    p.width() || p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft") || 0, 10) - parseInt(that.currentItem.css("paddingRight") || 0, 10)));
                }
            }), //Create the placeholder
            that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem)), 
            //Append it after the actual current item
            that.currentItem.after(that.placeholder), //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
            o.placeholder.update(that, that.placeholder);
        },
        _createTrPlaceholder: function(sourceTr, targetTr) {
            var that = this;
            sourceTr.children().each(function() {
                $("<td>&#160;</td>", that.document[0]).attr("colspan", $(this).attr("colspan") || 1).appendTo(targetTr);
            });
        },
        _contactContainers: function(event) {
            var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom, floating, axis, innermostContainer = null, innermostIndex = null;
            // get innermost container that intersects with item
            for (i = this.containers.length - 1; i >= 0; i--) // never consider a container that's located within the item itself
            if (!$.contains(this.currentItem[0], this.containers[i].element[0])) if (this._intersectsWith(this.containers[i].containerCache)) {
                // if we've already found a container and it's more "inner" than this, then continue
                if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) continue;
                innermostContainer = this.containers[i], innermostIndex = i;
            } else // container doesn't intersect. trigger "out" event if necessary
            this.containers[i].containerCache.over && (this.containers[i]._trigger("out", event, this._uiHash(this)), 
            this.containers[i].containerCache.over = 0);
            // if no intersecting containers found, return
            if (innermostContainer) // move the item into the container if it's not there already
            if (1 === this.containers.length) this.containers[innermostIndex].containerCache.over || (this.containers[innermostIndex]._trigger("over", event, this._uiHash(this)), 
            this.containers[innermostIndex].containerCache.over = 1); else {
                for (dist = 1e4, itemWithLeastDistance = null, floating = innermostContainer.floating || this._isFloating(this.currentItem), 
                posProperty = floating ? "left" : "top", sizeProperty = floating ? "width" : "height", 
                axis = floating ? "clientX" : "clientY", j = this.items.length - 1; j >= 0; j--) $.contains(this.containers[innermostIndex].element[0], this.items[j].item[0]) && this.items[j].item[0] !== this.currentItem[0] && (cur = this.items[j].item.offset()[posProperty], 
                nearBottom = !1, event[axis] - cur > this.items[j][sizeProperty] / 2 && (nearBottom = !0), 
                Math.abs(event[axis] - cur) < dist && (dist = Math.abs(event[axis] - cur), itemWithLeastDistance = this.items[j], 
                this.direction = nearBottom ? "up" : "down"));
                //Check if dropOnEmpty is enabled
                if (!itemWithLeastDistance && !this.options.dropOnEmpty) return;
                if (this.currentContainer === this.containers[innermostIndex]) return void (this.currentContainer.containerCache.over || (this.containers[innermostIndex]._trigger("over", event, this._uiHash()), 
                this.currentContainer.containerCache.over = 1));
                itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, !0) : this._rearrange(event, null, this.containers[innermostIndex].element, !0), 
                this._trigger("change", event, this._uiHash()), this.containers[innermostIndex]._trigger("change", event, this._uiHash(this)), 
                this.currentContainer = this.containers[innermostIndex], //Update the placeholder
                this.options.placeholder.update(this.currentContainer, this.placeholder), this.containers[innermostIndex]._trigger("over", event, this._uiHash(this)), 
                this.containers[innermostIndex].containerCache.over = 1;
            }
        },
        _createHelper: function(event) {
            var o = this.options, helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [ event, this.currentItem ])) : "clone" === o.helper ? this.currentItem.clone() : this.currentItem;
            //Add the helper to the DOM if that didn't happen already
            return helper.parents("body").length || $("parent" !== o.appendTo ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]), 
            helper[0] === this.currentItem[0] && (this._storedCSS = {
                width: this.currentItem[0].style.width,
                height: this.currentItem[0].style.height,
                position: this.currentItem.css("position"),
                top: this.currentItem.css("top"),
                left: this.currentItem.css("left")
            }), (!helper[0].style.width || o.forceHelperSize) && helper.width(this.currentItem.width()), 
            (!helper[0].style.height || o.forceHelperSize) && helper.height(this.currentItem.height()), 
            helper;
        },
        _adjustOffsetFromHelper: function(obj) {
            "string" == typeof obj && (obj = obj.split(" ")), $.isArray(obj) && (obj = {
                left: +obj[0],
                top: +obj[1] || 0
            }), "left" in obj && (this.offset.click.left = obj.left + this.margins.left), "right" in obj && (this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left), 
            "top" in obj && (this.offset.click.top = obj.top + this.margins.top), "bottom" in obj && (this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top);
        },
        _getParentOffset: function() {
            //Get the offsetParent and cache its position
            this.offsetParent = this.helper.offsetParent();
            var po = this.offsetParent.offset();
            // This is a special case where we need to modify a offset calculated on start, since the following happened:
            // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
            // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
            //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
            // This needs to be actually done for all browsers, since pageX/pageY includes this information
            // with an ugly IE fix
            return "absolute" === this.cssPosition && this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0]) && (po.left += this.scrollParent.scrollLeft(), 
            po.top += this.scrollParent.scrollTop()), (this.offsetParent[0] === this.document[0].body || this.offsetParent[0].tagName && "html" === this.offsetParent[0].tagName.toLowerCase() && $.ui.ie) && (po = {
                top: 0,
                left: 0
            }), {
                top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            };
        },
        _getRelativeOffset: function() {
            if ("relative" === this.cssPosition) {
                var p = this.currentItem.position();
                return {
                    top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                    left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                };
            }
            return {
                top: 0,
                left: 0
            };
        },
        _cacheMargins: function() {
            this.margins = {
                left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
                top: parseInt(this.currentItem.css("marginTop"), 10) || 0
            };
        },
        _cacheHelperProportions: function() {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
        },
        _setContainment: function() {
            var ce, co, over, o = this.options;
            "parent" === o.containment && (o.containment = this.helper[0].parentNode), ("document" === o.containment || "window" === o.containment) && (this.containment = [ 0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, "document" === o.containment ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left, ("document" === o.containment ? this.document.width() : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ]), 
            /^(document|window|parent)$/.test(o.containment) || (ce = $(o.containment)[0], co = $(o.containment).offset(), 
            over = "hidden" !== $(ce).css("overflow"), this.containment = [ co.left + (parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"), 10) || 0) - this.margins.left, co.top + (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0) - this.margins.top, co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top ]);
        },
        _convertPositionTo: function(d, pos) {
            pos || (pos = this.position);
            var mod = "absolute" === d ? 1 : -1, scroll = "absolute" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent, scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
            return {
                top: pos.top + // The absolute mouse position
                this.offset.relative.top * mod + // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.parent.top * mod - // The offsetParent's offset without borders (offset + border)
                ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()) * mod,
                left: pos.left + // The absolute mouse position
                this.offset.relative.left * mod + // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.parent.left * mod - // The offsetParent's offset without borders (offset + border)
                ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod
            };
        },
        _generatePosition: function(event) {
            var top, left, o = this.options, pageX = event.pageX, pageY = event.pageY, scroll = "absolute" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent, scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
            // This is another very weird special case that only happens for relative elements:
            // 1. If the css position is relative
            // 2. and the scroll parent is the document or similar to the offset parent
            // we have to refresh the relative offset during the scroll so there are no jumps
            /*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */
            //If we are not dragging yet, we won't check for options
            return "relative" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0] || (this.offset.relative = this._getRelativeOffset()), 
            this.originalPosition && (this.containment && (event.pageX - this.offset.click.left < this.containment[0] && (pageX = this.containment[0] + this.offset.click.left), 
            event.pageY - this.offset.click.top < this.containment[1] && (pageY = this.containment[1] + this.offset.click.top), 
            event.pageX - this.offset.click.left > this.containment[2] && (pageX = this.containment[2] + this.offset.click.left), 
            event.pageY - this.offset.click.top > this.containment[3] && (pageY = this.containment[3] + this.offset.click.top)), 
            o.grid && (top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1], 
            pageY = this.containment ? top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3] ? top : top - this.offset.click.top >= this.containment[1] ? top - o.grid[1] : top + o.grid[1] : top, 
            left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0], 
            pageX = this.containment ? left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2] ? left : left - this.offset.click.left >= this.containment[0] ? left - o.grid[0] : left + o.grid[0] : left)), 
            {
                top: pageY - // The absolute mouse position
                this.offset.click.top - // Click offset (relative to the element)
                this.offset.relative.top - // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.parent.top + (// The offsetParent's offset without borders (offset + border)
                "fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()),
                left: pageX - // The absolute mouse position
                this.offset.click.left - // Click offset (relative to the element)
                this.offset.relative.left - // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.parent.left + (// The offsetParent's offset without borders (offset + border)
                "fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft())
            };
        },
        _rearrange: function(event, i, a, hardRefresh) {
            a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], "down" === this.direction ? i.item[0] : i.item[0].nextSibling), 
            //Various things done here to improve the performance:
            // 1. we create a setTimeout, that calls refreshPositions
            // 2. on the instance, we have a counter variable, that get's higher after every append
            // 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
            // 4. this lets only the last addition to the timeout stack through
            this.counter = this.counter ? ++this.counter : 1;
            var counter = this.counter;
            this._delay(function() {
                counter === this.counter && this.refreshPositions(!hardRefresh);
            });
        },
        _clear: function(event, noPropagation) {
            //Post events to containers
            function delayEvent(type, instance, container) {
                return function(event) {
                    container._trigger(type, event, instance._uiHash(instance));
                };
            }
            this.reverting = !1;
            // We delay all events that have to be triggered to after the point where the placeholder has been removed and
            // everything else normalized again
            var i, delayedTriggers = [];
            if (// We first have to update the dom position of the actual currentItem
            // Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
            !this._noFinalSort && this.currentItem.parent().length && this.placeholder.before(this.currentItem), 
            this._noFinalSort = null, this.helper[0] === this.currentItem[0]) {
                for (i in this._storedCSS) ("auto" === this._storedCSS[i] || "static" === this._storedCSS[i]) && (this._storedCSS[i] = "");
                this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
            } else this.currentItem.show();
            for (this.fromOutside && !noPropagation && delayedTriggers.push(function(event) {
                this._trigger("receive", event, this._uiHash(this.fromOutside));
            }), !this.fromOutside && this.domPosition.prev === this.currentItem.prev().not(".ui-sortable-helper")[0] && this.domPosition.parent === this.currentItem.parent()[0] || noPropagation || delayedTriggers.push(function(event) {
                this._trigger("update", event, this._uiHash());
            }), // Check if the items Container has Changed and trigger appropriate
            // events.
            this !== this.currentContainer && (noPropagation || (delayedTriggers.push(function(event) {
                this._trigger("remove", event, this._uiHash());
            }), delayedTriggers.push(function(c) {
                return function(event) {
                    c._trigger("receive", event, this._uiHash(this));
                };
            }.call(this, this.currentContainer)), delayedTriggers.push(function(c) {
                return function(event) {
                    c._trigger("update", event, this._uiHash(this));
                };
            }.call(this, this.currentContainer)))), i = this.containers.length - 1; i >= 0; i--) noPropagation || delayedTriggers.push(delayEvent("deactivate", this, this.containers[i])), 
            this.containers[i].containerCache.over && (delayedTriggers.push(delayEvent("out", this, this.containers[i])), 
            this.containers[i].containerCache.over = 0);
            if (//Do what was originally in plugins
            this.storedCursor && (this.document.find("body").css("cursor", this.storedCursor), 
            this.storedStylesheet.remove()), this._storedOpacity && this.helper.css("opacity", this._storedOpacity), 
            this._storedZIndex && this.helper.css("zIndex", "auto" === this._storedZIndex ? "" : this._storedZIndex), 
            this.dragging = !1, noPropagation || this._trigger("beforeStop", event, this._uiHash()), 
            //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
            this.placeholder[0].parentNode.removeChild(this.placeholder[0]), this.cancelHelperRemoval || (this.helper[0] !== this.currentItem[0] && this.helper.remove(), 
            this.helper = null), !noPropagation) {
                for (i = 0; i < delayedTriggers.length; i++) delayedTriggers[i].call(this, event);
                //Trigger all delayed events
                this._trigger("stop", event, this._uiHash());
            }
            return this.fromOutside = !1, !this.cancelHelperRemoval;
        },
        _trigger: function() {
            $.Widget.prototype._trigger.apply(this, arguments) === !1 && this.cancel();
        },
        _uiHash: function(_inst) {
            var inst = _inst || this;
            return {
                helper: inst.helper,
                placeholder: inst.placeholder || $([]),
                position: inst.position,
                originalPosition: inst.originalPosition,
                offset: inst.positionAbs,
                item: inst.currentItem,
                sender: _inst ? _inst.element : null
            };
        }
    }), $.widget("ui.spinner", {
        version: "1.11.4",
        defaultElement: "<input>",
        widgetEventPrefix: "spin",
        options: {
            culture: null,
            icons: {
                down: "ui-icon-triangle-1-s",
                up: "ui-icon-triangle-1-n"
            },
            incremental: !0,
            max: null,
            min: null,
            numberFormat: null,
            page: 10,
            step: 1,
            change: null,
            spin: null,
            start: null,
            stop: null
        },
        _create: function() {
            // handle string values that need to be parsed
            this._setOption("max", this.options.max), this._setOption("min", this.options.min), 
            this._setOption("step", this.options.step), // Only format if there is a value, prevents the field from being marked
            // as invalid in Firefox, see #9573.
            "" !== this.value() && // Format the value, but don't constrain.
            this._value(this.element.val(), !0), this._draw(), this._on(this._events), this._refresh(), 
            // turning off autocomplete prevents the browser from remembering the
            // value when navigating through history, so we re-enable autocomplete
            // if the page is unloaded before the widget is destroyed. #7790
            this._on(this.window, {
                beforeunload: function() {
                    this.element.removeAttr("autocomplete");
                }
            });
        },
        _getCreateOptions: function() {
            var options = {}, element = this.element;
            return $.each([ "min", "max", "step" ], function(i, option) {
                var value = element.attr(option);
                void 0 !== value && value.length && (options[option] = value);
            }), options;
        },
        _events: {
            keydown: function(event) {
                this._start(event) && this._keydown(event) && event.preventDefault();
            },
            keyup: "_stop",
            focus: function() {
                this.previous = this.element.val();
            },
            blur: function(event) {
                return this.cancelBlur ? void delete this.cancelBlur : (this._stop(), this._refresh(), 
                void (this.previous !== this.element.val() && this._trigger("change", event)));
            },
            mousewheel: function(event, delta) {
                if (delta) {
                    if (!this.spinning && !this._start(event)) return !1;
                    this._spin((delta > 0 ? 1 : -1) * this.options.step, event), clearTimeout(this.mousewheelTimer), 
                    this.mousewheelTimer = this._delay(function() {
                        this.spinning && this._stop(event);
                    }, 100), event.preventDefault();
                }
            },
            "mousedown .ui-spinner-button": function(event) {
                function checkFocus() {
                    var isActive = this.element[0] === this.document[0].activeElement;
                    isActive || (this.element.focus(), this.previous = previous, // support: IE
                    // IE sets focus asynchronously, so we need to check if focus
                    // moved off of the input because the user clicked on the button.
                    this._delay(function() {
                        this.previous = previous;
                    }));
                }
                var previous;
                previous = this.element[0] === this.document[0].activeElement ? this.previous : this.element.val(), 
                event.preventDefault(), checkFocus.call(this), this.cancelBlur = !0, this._delay(function() {
                    delete this.cancelBlur, checkFocus.call(this);
                }), this._start(event) !== !1 && this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event);
            },
            "mouseup .ui-spinner-button": "_stop",
            "mouseenter .ui-spinner-button": function(event) {
                return $(event.currentTarget).hasClass("ui-state-active") ? this._start(event) === !1 ? !1 : void this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event) : void 0;
            },
            // TODO: do we really want to consider this a stop?
            // shouldn't we just stop the repeater and wait until mouseup before
            // we trigger the stop event?
            "mouseleave .ui-spinner-button": "_stop"
        },
        _draw: function() {
            var uiSpinner = this.uiSpinner = this.element.addClass("ui-spinner-input").attr("autocomplete", "off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml());
            this.element.attr("role", "spinbutton"), // button bindings
            this.buttons = uiSpinner.find(".ui-spinner-button").attr("tabIndex", -1).button().removeClass("ui-corner-all"), 
            // IE 6 doesn't understand height: 50% for the buttons
            // unless the wrapper has an explicit height
            this.buttons.height() > Math.ceil(.5 * uiSpinner.height()) && uiSpinner.height() > 0 && uiSpinner.height(uiSpinner.height()), 
            // disable spinner if element was already disabled
            this.options.disabled && this.disable();
        },
        _keydown: function(event) {
            var options = this.options, keyCode = $.ui.keyCode;
            switch (event.keyCode) {
              case keyCode.UP:
                return this._repeat(null, 1, event), !0;

              case keyCode.DOWN:
                return this._repeat(null, -1, event), !0;

              case keyCode.PAGE_UP:
                return this._repeat(null, options.page, event), !0;

              case keyCode.PAGE_DOWN:
                return this._repeat(null, -options.page, event), !0;
            }
            return !1;
        },
        _uiSpinnerHtml: function() {
            return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>";
        },
        _buttonHtml: function() {
            return "<a class='ui-spinner-button ui-spinner-up ui-corner-tr'><span class='ui-icon " + this.options.icons.up + "'>&#9650;</span></a><a class='ui-spinner-button ui-spinner-down ui-corner-br'><span class='ui-icon " + this.options.icons.down + "'>&#9660;</span></a>";
        },
        _start: function(event) {
            return this.spinning || this._trigger("start", event) !== !1 ? (this.counter || (this.counter = 1), 
            this.spinning = !0, !0) : !1;
        },
        _repeat: function(i, steps, event) {
            i = i || 500, clearTimeout(this.timer), this.timer = this._delay(function() {
                this._repeat(40, steps, event);
            }, i), this._spin(steps * this.options.step, event);
        },
        _spin: function(step, event) {
            var value = this.value() || 0;
            this.counter || (this.counter = 1), value = this._adjustValue(value + step * this._increment(this.counter)), 
            this.spinning && this._trigger("spin", event, {
                value: value
            }) === !1 || (this._value(value), this.counter++);
        },
        _increment: function(i) {
            var incremental = this.options.incremental;
            return incremental ? $.isFunction(incremental) ? incremental(i) : Math.floor(i * i * i / 5e4 - i * i / 500 + 17 * i / 200 + 1) : 1;
        },
        _precision: function() {
            var precision = this._precisionOf(this.options.step);
            return null !== this.options.min && (precision = Math.max(precision, this._precisionOf(this.options.min))), 
            precision;
        },
        _precisionOf: function(num) {
            var str = num.toString(), decimal = str.indexOf(".");
            return -1 === decimal ? 0 : str.length - decimal - 1;
        },
        _adjustValue: function(value) {
            var base, aboveMin, options = this.options;
            return base = null !== options.min ? options.min : 0, aboveMin = value - base, aboveMin = Math.round(aboveMin / options.step) * options.step, 
            value = base + aboveMin, value = parseFloat(value.toFixed(this._precision())), null !== options.max && value > options.max ? options.max : null !== options.min && value < options.min ? options.min : value;
        },
        _stop: function(event) {
            this.spinning && (clearTimeout(this.timer), clearTimeout(this.mousewheelTimer), 
            this.counter = 0, this.spinning = !1, this._trigger("stop", event));
        },
        _setOption: function(key, value) {
            if ("culture" === key || "numberFormat" === key) {
                var prevValue = this._parse(this.element.val());
                return this.options[key] = value, void this.element.val(this._format(prevValue));
            }
            ("max" === key || "min" === key || "step" === key) && "string" == typeof value && (value = this._parse(value)), 
            "icons" === key && (this.buttons.first().find(".ui-icon").removeClass(this.options.icons.up).addClass(value.up), 
            this.buttons.last().find(".ui-icon").removeClass(this.options.icons.down).addClass(value.down)), 
            this._super(key, value), "disabled" === key && (this.widget().toggleClass("ui-state-disabled", !!value), 
            this.element.prop("disabled", !!value), this.buttons.button(value ? "disable" : "enable"));
        },
        _setOptions: spinner_modifier(function(options) {
            this._super(options);
        }),
        _parse: function(val) {
            return "string" == typeof val && "" !== val && (val = window.Globalize && this.options.numberFormat ? Globalize.parseFloat(val, 10, this.options.culture) : +val), 
            "" === val || isNaN(val) ? null : val;
        },
        _format: function(value) {
            return "" === value ? "" : window.Globalize && this.options.numberFormat ? Globalize.format(value, this.options.numberFormat, this.options.culture) : value;
        },
        _refresh: function() {
            this.element.attr({
                "aria-valuemin": this.options.min,
                "aria-valuemax": this.options.max,
                // TODO: what should we do with values that can't be parsed?
                "aria-valuenow": this._parse(this.element.val())
            });
        },
        isValid: function() {
            var value = this.value();
            // null is invalid
            // null is invalid
            return null === value ? !1 : value === this._adjustValue(value);
        },
        // update the value without triggering change
        _value: function(value, allowAny) {
            var parsed;
            "" !== value && (parsed = this._parse(value), null !== parsed && (allowAny || (parsed = this._adjustValue(parsed)), 
            value = this._format(parsed))), this.element.val(value), this._refresh();
        },
        _destroy: function() {
            this.element.removeClass("ui-spinner-input").prop("disabled", !1).removeAttr("autocomplete").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow"), 
            this.uiSpinner.replaceWith(this.element);
        },
        stepUp: spinner_modifier(function(steps) {
            this._stepUp(steps);
        }),
        _stepUp: function(steps) {
            this._start() && (this._spin((steps || 1) * this.options.step), this._stop());
        },
        stepDown: spinner_modifier(function(steps) {
            this._stepDown(steps);
        }),
        _stepDown: function(steps) {
            this._start() && (this._spin((steps || 1) * -this.options.step), this._stop());
        },
        pageUp: spinner_modifier(function(pages) {
            this._stepUp((pages || 1) * this.options.page);
        }),
        pageDown: spinner_modifier(function(pages) {
            this._stepDown((pages || 1) * this.options.page);
        }),
        value: function(newVal) {
            return arguments.length ? void spinner_modifier(this._value).call(this, newVal) : this._parse(this.element.val());
        },
        widget: function() {
            return this.uiSpinner;
        }
    }), $.widget("ui.tabs", {
        version: "1.11.4",
        delay: 300,
        options: {
            active: null,
            collapsible: !1,
            event: "click",
            heightStyle: "content",
            hide: null,
            show: null,
            // callbacks
            activate: null,
            beforeActivate: null,
            beforeLoad: null,
            load: null
        },
        _isLocal: function() {
            var rhash = /#.*$/;
            return function(anchor) {
                var anchorUrl, locationUrl;
                anchor = anchor.cloneNode(!1), anchorUrl = anchor.href.replace(rhash, ""), locationUrl = location.href.replace(rhash, "");
                // decoding may throw an error if the URL isn't UTF-8 (#9518)
                try {
                    anchorUrl = decodeURIComponent(anchorUrl);
                } catch (error) {}
                try {
                    locationUrl = decodeURIComponent(locationUrl);
                } catch (error) {}
                return anchor.hash.length > 1 && anchorUrl === locationUrl;
            };
        }(),
        _create: function() {
            var that = this, options = this.options;
            this.running = !1, this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all").toggleClass("ui-tabs-collapsible", options.collapsible), 
            this._processTabs(), options.active = this._initialActive(), // Take disabling tabs via class attribute from HTML
            // into account and update option properly.
            $.isArray(options.disabled) && (options.disabled = $.unique(options.disabled.concat($.map(this.tabs.filter(".ui-state-disabled"), function(li) {
                return that.tabs.index(li);
            }))).sort()), // check for length avoids error when initializing empty list
            this.options.active !== !1 && this.anchors.length ? this.active = this._findActive(options.active) : this.active = $(), 
            this._refresh(), this.active.length && this.load(options.active);
        },
        _initialActive: function() {
            var active = this.options.active, collapsible = this.options.collapsible, locationHash = location.hash.substring(1);
            // check the fragment identifier in the URL
            // check for a tab marked active via a class
            // no active tab, set to false
            // handle numbers: negative, out of range
            // don't allow collapsible: false and active: false
            return null === active && (locationHash && this.tabs.each(function(i, tab) {
                return $(tab).attr("aria-controls") === locationHash ? (active = i, !1) : void 0;
            }), null === active && (active = this.tabs.index(this.tabs.filter(".ui-tabs-active"))), 
            (null === active || -1 === active) && (active = this.tabs.length ? 0 : !1)), active !== !1 && (active = this.tabs.index(this.tabs.eq(active)), 
            -1 === active && (active = collapsible ? !1 : 0)), !collapsible && active === !1 && this.anchors.length && (active = 0), 
            active;
        },
        _getCreateEventData: function() {
            return {
                tab: this.active,
                panel: this.active.length ? this._getPanelForTab(this.active) : $()
            };
        },
        _tabKeydown: function(event) {
            var focusedTab = $(this.document[0].activeElement).closest("li"), selectedIndex = this.tabs.index(focusedTab), goingForward = !0;
            if (!this._handlePageNav(event)) {
                switch (event.keyCode) {
                  case $.ui.keyCode.RIGHT:
                  case $.ui.keyCode.DOWN:
                    selectedIndex++;
                    break;

                  case $.ui.keyCode.UP:
                  case $.ui.keyCode.LEFT:
                    goingForward = !1, selectedIndex--;
                    break;

                  case $.ui.keyCode.END:
                    selectedIndex = this.anchors.length - 1;
                    break;

                  case $.ui.keyCode.HOME:
                    selectedIndex = 0;
                    break;

                  case $.ui.keyCode.SPACE:
                    // Activate only, no collapsing
                    return event.preventDefault(), clearTimeout(this.activating), void this._activate(selectedIndex);

                  case $.ui.keyCode.ENTER:
                    // Toggle (cancel delayed activation, allow collapsing)
                    // Determine if we should collapse or activate
                    return event.preventDefault(), clearTimeout(this.activating), void this._activate(selectedIndex === this.options.active ? !1 : selectedIndex);

                  default:
                    return;
                }
                // Focus the appropriate tab, based on which key was pressed
                event.preventDefault(), clearTimeout(this.activating), selectedIndex = this._focusNextTab(selectedIndex, goingForward), 
                // Navigating with control/command key will prevent automatic activation
                event.ctrlKey || event.metaKey || (// Update aria-selected immediately so that AT think the tab is already selected.
                // Otherwise AT may confuse the user by stating that they need to activate the tab,
                // but the tab will already be activated by the time the announcement finishes.
                focusedTab.attr("aria-selected", "false"), this.tabs.eq(selectedIndex).attr("aria-selected", "true"), 
                this.activating = this._delay(function() {
                    this.option("active", selectedIndex);
                }, this.delay));
            }
        },
        _panelKeydown: function(event) {
            this._handlePageNav(event) || // Ctrl+up moves focus to the current tab
            event.ctrlKey && event.keyCode === $.ui.keyCode.UP && (event.preventDefault(), this.active.focus());
        },
        // Alt+page up/down moves focus to the previous/next tab (and activates)
        _handlePageNav: function(event) {
            return event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ? (this._activate(this._focusNextTab(this.options.active - 1, !1)), 
            !0) : event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ? (this._activate(this._focusNextTab(this.options.active + 1, !0)), 
            !0) : void 0;
        },
        _findNextTab: function(index, goingForward) {
            function constrain() {
                return index > lastTabIndex && (index = 0), 0 > index && (index = lastTabIndex), 
                index;
            }
            for (var lastTabIndex = this.tabs.length - 1; -1 !== $.inArray(constrain(), this.options.disabled); ) index = goingForward ? index + 1 : index - 1;
            return index;
        },
        _focusNextTab: function(index, goingForward) {
            return index = this._findNextTab(index, goingForward), this.tabs.eq(index).focus(), 
            index;
        },
        _setOption: function(key, value) {
            // _activate() will handle invalid values and update this.options
            // don't use the widget factory's disabled handling
            // Setting collapsible: false while collapsed; open first panel
            return "active" === key ? void this._activate(value) : "disabled" === key ? void this._setupDisabled(value) : (this._super(key, value), 
            "collapsible" === key && (this.element.toggleClass("ui-tabs-collapsible", value), 
            value || this.options.active !== !1 || this._activate(0)), "event" === key && this._setupEvents(value), 
            void ("heightStyle" === key && this._setupHeightStyle(value)));
        },
        _sanitizeSelector: function(hash) {
            return hash ? hash.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : "";
        },
        refresh: function() {
            var options = this.options, lis = this.tablist.children(":has(a[href])");
            // get disabled tabs from class attribute from HTML
            // this will get converted to a boolean if needed in _refresh()
            options.disabled = $.map(lis.filter(".ui-state-disabled"), function(tab) {
                return lis.index(tab);
            }), this._processTabs(), // was collapsed or no tabs
            options.active !== !1 && this.anchors.length ? this.active.length && !$.contains(this.tablist[0], this.active[0]) ? // all remaining tabs are disabled
            this.tabs.length === options.disabled.length ? (options.active = !1, this.active = $()) : this._activate(this._findNextTab(Math.max(0, options.active - 1), !1)) : options.active = this.tabs.index(this.active) : (options.active = !1, 
            this.active = $()), this._refresh();
        },
        _refresh: function() {
            this._setupDisabled(this.options.disabled), this._setupEvents(this.options.event), 
            this._setupHeightStyle(this.options.heightStyle), this.tabs.not(this.active).attr({
                "aria-selected": "false",
                "aria-expanded": "false",
                tabIndex: -1
            }), this.panels.not(this._getPanelForTab(this.active)).hide().attr({
                "aria-hidden": "true"
            }), // Make sure one tab is in the tab order
            this.active.length ? (this.active.addClass("ui-tabs-active ui-state-active").attr({
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0
            }), this._getPanelForTab(this.active).show().attr({
                "aria-hidden": "false"
            })) : this.tabs.eq(0).attr("tabIndex", 0);
        },
        _processTabs: function() {
            var that = this, prevTabs = this.tabs, prevAnchors = this.anchors, prevPanels = this.panels;
            this.tablist = this._getList().addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").attr("role", "tablist").delegate("> li", "mousedown" + this.eventNamespace, function(event) {
                $(this).is(".ui-state-disabled") && event.preventDefault();
            }).delegate(".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
                $(this).closest("li").is(".ui-state-disabled") && this.blur();
            }), this.tabs = this.tablist.find("> li:has(a[href])").addClass("ui-state-default ui-corner-top").attr({
                role: "tab",
                tabIndex: -1
            }), this.anchors = this.tabs.map(function() {
                return $("a", this)[0];
            }).addClass("ui-tabs-anchor").attr({
                role: "presentation",
                tabIndex: -1
            }), this.panels = $(), this.anchors.each(function(i, anchor) {
                var selector, panel, panelId, anchorId = $(anchor).uniqueId().attr("id"), tab = $(anchor).closest("li"), originalAriaControls = tab.attr("aria-controls");
                // inline tab
                that._isLocal(anchor) ? (selector = anchor.hash, panelId = selector.substring(1), 
                panel = that.element.find(that._sanitizeSelector(selector))) : (panelId = tab.attr("aria-controls") || $({}).uniqueId()[0].id, 
                selector = "#" + panelId, panel = that.element.find(selector), panel.length || (panel = that._createPanel(panelId), 
                panel.insertAfter(that.panels[i - 1] || that.tablist)), panel.attr("aria-live", "polite")), 
                panel.length && (that.panels = that.panels.add(panel)), originalAriaControls && tab.data("ui-tabs-aria-controls", originalAriaControls), 
                tab.attr({
                    "aria-controls": panelId,
                    "aria-labelledby": anchorId
                }), panel.attr("aria-labelledby", anchorId);
            }), this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").attr("role", "tabpanel"), 
            // Avoid memory leaks (#10056)
            prevTabs && (this._off(prevTabs.not(this.tabs)), this._off(prevAnchors.not(this.anchors)), 
            this._off(prevPanels.not(this.panels)));
        },
        // allow overriding how to find the list for rare usage scenarios (#7715)
        _getList: function() {
            return this.tablist || this.element.find("ol,ul").eq(0);
        },
        _createPanel: function(id) {
            return $("<div>").attr("id", id).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").data("ui-tabs-destroy", !0);
        },
        _setupDisabled: function(disabled) {
            $.isArray(disabled) && (disabled.length ? disabled.length === this.anchors.length && (disabled = !0) : disabled = !1);
            // disable tabs
            for (var li, i = 0; li = this.tabs[i]; i++) disabled === !0 || -1 !== $.inArray(i, disabled) ? $(li).addClass("ui-state-disabled").attr("aria-disabled", "true") : $(li).removeClass("ui-state-disabled").removeAttr("aria-disabled");
            this.options.disabled = disabled;
        },
        _setupEvents: function(event) {
            var events = {};
            event && $.each(event.split(" "), function(index, eventName) {
                events[eventName] = "_eventHandler";
            }), this._off(this.anchors.add(this.tabs).add(this.panels)), // Always prevent the default action, even when disabled
            this._on(!0, this.anchors, {
                click: function(event) {
                    event.preventDefault();
                }
            }), this._on(this.anchors, events), this._on(this.tabs, {
                keydown: "_tabKeydown"
            }), this._on(this.panels, {
                keydown: "_panelKeydown"
            }), this._focusable(this.tabs), this._hoverable(this.tabs);
        },
        _setupHeightStyle: function(heightStyle) {
            var maxHeight, parent = this.element.parent();
            "fill" === heightStyle ? (maxHeight = parent.height(), maxHeight -= this.element.outerHeight() - this.element.height(), 
            this.element.siblings(":visible").each(function() {
                var elem = $(this), position = elem.css("position");
                "absolute" !== position && "fixed" !== position && (maxHeight -= elem.outerHeight(!0));
            }), this.element.children().not(this.panels).each(function() {
                maxHeight -= $(this).outerHeight(!0);
            }), this.panels.each(function() {
                $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
            }).css("overflow", "auto")) : "auto" === heightStyle && (maxHeight = 0, this.panels.each(function() {
                maxHeight = Math.max(maxHeight, $(this).height("").height());
            }).height(maxHeight));
        },
        _eventHandler: function(event) {
            var options = this.options, active = this.active, anchor = $(event.currentTarget), tab = anchor.closest("li"), clickedIsActive = tab[0] === active[0], collapsing = clickedIsActive && options.collapsible, toShow = collapsing ? $() : this._getPanelForTab(tab), toHide = active.length ? this._getPanelForTab(active) : $(), eventData = {
                oldTab: active,
                oldPanel: toHide,
                newTab: collapsing ? $() : tab,
                newPanel: toShow
            };
            event.preventDefault(), tab.hasClass("ui-state-disabled") || tab.hasClass("ui-tabs-loading") || this.running || clickedIsActive && !options.collapsible || this._trigger("beforeActivate", event, eventData) === !1 || (options.active = collapsing ? !1 : this.tabs.index(tab), 
            this.active = clickedIsActive ? $() : tab, this.xhr && this.xhr.abort(), toHide.length || toShow.length || $.error("jQuery UI Tabs: Mismatching fragment identifier."), 
            toShow.length && this.load(this.tabs.index(tab), event), this._toggle(event, eventData));
        },
        // handles show/hide for selecting tabs
        _toggle: function(event, eventData) {
            function complete() {
                that.running = !1, that._trigger("activate", event, eventData);
            }
            function show() {
                eventData.newTab.closest("li").addClass("ui-tabs-active ui-state-active"), toShow.length && that.options.show ? that._show(toShow, that.options.show, complete) : (toShow.show(), 
                complete());
            }
            var that = this, toShow = eventData.newPanel, toHide = eventData.oldPanel;
            this.running = !0, // start out by hiding, then showing, then completing
            toHide.length && this.options.hide ? this._hide(toHide, this.options.hide, function() {
                eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"), show();
            }) : (eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"), 
            toHide.hide(), show()), toHide.attr("aria-hidden", "true"), eventData.oldTab.attr({
                "aria-selected": "false",
                "aria-expanded": "false"
            }), // If we're switching tabs, remove the old tab from the tab order.
            // If we're opening from collapsed state, remove the previous tab from the tab order.
            // If we're collapsing, then keep the collapsing tab in the tab order.
            toShow.length && toHide.length ? eventData.oldTab.attr("tabIndex", -1) : toShow.length && this.tabs.filter(function() {
                return 0 === $(this).attr("tabIndex");
            }).attr("tabIndex", -1), toShow.attr("aria-hidden", "false"), eventData.newTab.attr({
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0
            });
        },
        _activate: function(index) {
            var anchor, active = this._findActive(index);
            // trying to activate the already active panel
            active[0] !== this.active[0] && (// trying to collapse, simulate a click on the current active header
            active.length || (active = this.active), anchor = active.find(".ui-tabs-anchor")[0], 
            this._eventHandler({
                target: anchor,
                currentTarget: anchor,
                preventDefault: $.noop
            }));
        },
        _findActive: function(index) {
            return index === !1 ? $() : this.tabs.eq(index);
        },
        _getIndex: function(index) {
            // meta-function to give users option to provide a href string instead of a numerical index.
            return "string" == typeof index && (index = this.anchors.index(this.anchors.filter("[href$='" + index + "']"))), 
            index;
        },
        _destroy: function() {
            this.xhr && this.xhr.abort(), this.element.removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible"), 
            this.tablist.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").removeAttr("role"), 
            this.anchors.removeClass("ui-tabs-anchor").removeAttr("role").removeAttr("tabIndex").removeUniqueId(), 
            this.tablist.unbind(this.eventNamespace), this.tabs.add(this.panels).each(function() {
                $.data(this, "ui-tabs-destroy") ? $(this).remove() : $(this).removeClass("ui-state-default ui-state-active ui-state-disabled ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel").removeAttr("tabIndex").removeAttr("aria-live").removeAttr("aria-busy").removeAttr("aria-selected").removeAttr("aria-labelledby").removeAttr("aria-hidden").removeAttr("aria-expanded").removeAttr("role");
            }), this.tabs.each(function() {
                var li = $(this), prev = li.data("ui-tabs-aria-controls");
                prev ? li.attr("aria-controls", prev).removeData("ui-tabs-aria-controls") : li.removeAttr("aria-controls");
            }), this.panels.show(), "content" !== this.options.heightStyle && this.panels.css("height", "");
        },
        enable: function(index) {
            var disabled = this.options.disabled;
            disabled !== !1 && (void 0 === index ? disabled = !1 : (index = this._getIndex(index), 
            disabled = $.isArray(disabled) ? $.map(disabled, function(num) {
                return num !== index ? num : null;
            }) : $.map(this.tabs, function(li, num) {
                return num !== index ? num : null;
            })), this._setupDisabled(disabled));
        },
        disable: function(index) {
            var disabled = this.options.disabled;
            if (disabled !== !0) {
                if (void 0 === index) disabled = !0; else {
                    if (index = this._getIndex(index), -1 !== $.inArray(index, disabled)) return;
                    disabled = $.isArray(disabled) ? $.merge([ index ], disabled).sort() : [ index ];
                }
                this._setupDisabled(disabled);
            }
        },
        load: function(index, event) {
            index = this._getIndex(index);
            var that = this, tab = this.tabs.eq(index), anchor = tab.find(".ui-tabs-anchor"), panel = this._getPanelForTab(tab), eventData = {
                tab: tab,
                panel: panel
            }, complete = function(jqXHR, status) {
                "abort" === status && that.panels.stop(!1, !0), tab.removeClass("ui-tabs-loading"), 
                panel.removeAttr("aria-busy"), jqXHR === that.xhr && delete that.xhr;
            };
            // not remote
            this._isLocal(anchor[0]) || (this.xhr = $.ajax(this._ajaxSettings(anchor, event, eventData)), 
            // support: jQuery <1.8
            // jQuery <1.8 returns false if the request is canceled in beforeSend,
            // but as of 1.8, $.ajax() always returns a jqXHR object.
            this.xhr && "canceled" !== this.xhr.statusText && (tab.addClass("ui-tabs-loading"), 
            panel.attr("aria-busy", "true"), this.xhr.done(function(response, status, jqXHR) {
                // support: jQuery <1.8
                // http://bugs.jquery.com/ticket/11778
                setTimeout(function() {
                    panel.html(response), that._trigger("load", event, eventData), complete(jqXHR, status);
                }, 1);
            }).fail(function(jqXHR, status) {
                // support: jQuery <1.8
                // http://bugs.jquery.com/ticket/11778
                setTimeout(function() {
                    complete(jqXHR, status);
                }, 1);
            })));
        },
        _ajaxSettings: function(anchor, event, eventData) {
            var that = this;
            return {
                url: anchor.attr("href"),
                beforeSend: function(jqXHR, settings) {
                    return that._trigger("beforeLoad", event, $.extend({
                        jqXHR: jqXHR,
                        ajaxSettings: settings
                    }, eventData));
                }
            };
        },
        _getPanelForTab: function(tab) {
            var id = $(tab).attr("aria-controls");
            return this.element.find(this._sanitizeSelector("#" + id));
        }
    }), $.widget("ui.tooltip", {
        version: "1.11.4",
        options: {
            content: function() {
                // support: IE<9, Opera in jQuery <1.7
                // .text() can't accept undefined, so coerce to a string
                var title = $(this).attr("title") || "";
                // Escape title, since we're going from an attribute to raw HTML
                return $("<a>").text(title).html();
            },
            hide: !0,
            // Disabled elements have inconsistent behavior across browsers (#8661)
            items: "[title]:not([disabled])",
            position: {
                my: "left top+15",
                at: "left bottom",
                collision: "flipfit flip"
            },
            show: !0,
            tooltipClass: null,
            track: !1,
            // callbacks
            close: null,
            open: null
        },
        _addDescribedBy: function(elem, id) {
            var describedby = (elem.attr("aria-describedby") || "").split(/\s+/);
            describedby.push(id), elem.data("ui-tooltip-id", id).attr("aria-describedby", $.trim(describedby.join(" ")));
        },
        _removeDescribedBy: function(elem) {
            var id = elem.data("ui-tooltip-id"), describedby = (elem.attr("aria-describedby") || "").split(/\s+/), index = $.inArray(id, describedby);
            -1 !== index && describedby.splice(index, 1), elem.removeData("ui-tooltip-id"), 
            describedby = $.trim(describedby.join(" ")), describedby ? elem.attr("aria-describedby", describedby) : elem.removeAttr("aria-describedby");
        },
        _create: function() {
            this._on({
                mouseover: "open",
                focusin: "open"
            }), // IDs of generated tooltips, needed for destroy
            this.tooltips = {}, // IDs of parent tooltips where we removed the title attribute
            this.parents = {}, this.options.disabled && this._disable(), // Append the aria-live region so tooltips announce correctly
            this.liveRegion = $("<div>").attr({
                role: "log",
                "aria-live": "assertive",
                "aria-relevant": "additions"
            }).addClass("ui-helper-hidden-accessible").appendTo(this.document[0].body);
        },
        _setOption: function(key, value) {
            var that = this;
            return "disabled" === key ? (this[value ? "_disable" : "_enable"](), void (this.options[key] = value)) : (this._super(key, value), 
            void ("content" === key && $.each(this.tooltips, function(id, tooltipData) {
                that._updateContent(tooltipData.element);
            })));
        },
        _disable: function() {
            var that = this;
            // close open tooltips
            $.each(this.tooltips, function(id, tooltipData) {
                var event = $.Event("blur");
                event.target = event.currentTarget = tooltipData.element[0], that.close(event, !0);
            }), // remove title attributes to prevent native tooltips
            this.element.find(this.options.items).addBack().each(function() {
                var element = $(this);
                element.is("[title]") && element.data("ui-tooltip-title", element.attr("title")).removeAttr("title");
            });
        },
        _enable: function() {
            // restore title attributes
            this.element.find(this.options.items).addBack().each(function() {
                var element = $(this);
                element.data("ui-tooltip-title") && element.attr("title", element.data("ui-tooltip-title"));
            });
        },
        open: function(event) {
            var that = this, target = $(event ? event.target : this.element).closest(this.options.items);
            // No element to show a tooltip for or the tooltip is already open
            target.length && !target.data("ui-tooltip-id") && (target.attr("title") && target.data("ui-tooltip-title", target.attr("title")), 
            target.data("ui-tooltip-open", !0), // kill parent tooltips, custom or native, for hover
            event && "mouseover" === event.type && target.parents().each(function() {
                var blurEvent, parent = $(this);
                parent.data("ui-tooltip-open") && (blurEvent = $.Event("blur"), blurEvent.target = blurEvent.currentTarget = this, 
                that.close(blurEvent, !0)), parent.attr("title") && (parent.uniqueId(), that.parents[this.id] = {
                    element: this,
                    title: parent.attr("title")
                }, parent.attr("title", ""));
            }), this._registerCloseHandlers(event, target), this._updateContent(target, event));
        },
        _updateContent: function(target, event) {
            var content, contentOption = this.options.content, that = this, eventType = event ? event.type : null;
            return "string" == typeof contentOption ? this._open(event, target, contentOption) : (content = contentOption.call(target[0], function(response) {
                // IE may instantly serve a cached response for ajax requests
                // delay this call to _open so the other call to _open runs first
                that._delay(function() {
                    // Ignore async response if tooltip was closed already
                    target.data("ui-tooltip-open") && (// jQuery creates a special event for focusin when it doesn't
                    // exist natively. To improve performance, the native event
                    // object is reused and the type is changed. Therefore, we can't
                    // rely on the type being correct after the event finished
                    // bubbling, so we set it back to the previous value. (#8740)
                    event && (event.type = eventType), this._open(event, target, response));
                });
            }), void (content && this._open(event, target, content)));
        },
        _open: function(event, target, content) {
            function position(event) {
                positionOption.of = event, tooltip.is(":hidden") || tooltip.position(positionOption);
            }
            var tooltipData, tooltip, delayedShow, a11yContent, positionOption = $.extend({}, this.options.position);
            if (content) {
                if (tooltipData = this._find(target)) return void tooltipData.tooltip.find(".ui-tooltip-content").html(content);
                // if we have a title, clear it to prevent the native tooltip
                // we have to check first to avoid defining a title if none exists
                // (we don't want to cause an element to start matching [title])
                //
                // We use removeAttr only for key events, to allow IE to export the correct
                // accessible attributes. For mouse events, set to empty string to avoid
                // native tooltip showing up (happens only when removing inside mouseover).
                target.is("[title]") && (event && "mouseover" === event.type ? target.attr("title", "") : target.removeAttr("title")), 
                tooltipData = this._tooltip(target), tooltip = tooltipData.tooltip, this._addDescribedBy(target, tooltip.attr("id")), 
                tooltip.find(".ui-tooltip-content").html(content), // Support: Voiceover on OS X, JAWS on IE <= 9
                // JAWS announces deletions even when aria-relevant="additions"
                // Voiceover will sometimes re-read the entire log region's contents from the beginning
                this.liveRegion.children().hide(), content.clone ? (a11yContent = content.clone(), 
                a11yContent.removeAttr("id").find("[id]").removeAttr("id")) : a11yContent = content, 
                $("<div>").html(a11yContent).appendTo(this.liveRegion), this.options.track && event && /^mouse/.test(event.type) ? (this._on(this.document, {
                    mousemove: position
                }), // trigger once to override element-relative positioning
                position(event)) : tooltip.position($.extend({
                    of: target
                }, this.options.position)), tooltip.hide(), this._show(tooltip, this.options.show), 
                // Handle tracking tooltips that are shown with a delay (#8644). As soon
                // as the tooltip is visible, position the tooltip using the most recent
                // event.
                this.options.show && this.options.show.delay && (delayedShow = this.delayedShow = setInterval(function() {
                    tooltip.is(":visible") && (position(positionOption.of), clearInterval(delayedShow));
                }, $.fx.interval)), this._trigger("open", event, {
                    tooltip: tooltip
                });
            }
        },
        _registerCloseHandlers: function(event, target) {
            var events = {
                keyup: function(event) {
                    if (event.keyCode === $.ui.keyCode.ESCAPE) {
                        var fakeEvent = $.Event(event);
                        fakeEvent.currentTarget = target[0], this.close(fakeEvent, !0);
                    }
                }
            };
            // Only bind remove handler for delegated targets. Non-delegated
            // tooltips will handle this in destroy.
            target[0] !== this.element[0] && (events.remove = function() {
                this._removeTooltip(this._find(target).tooltip);
            }), event && "mouseover" !== event.type || (events.mouseleave = "close"), event && "focusin" !== event.type || (events.focusout = "close"), 
            this._on(!0, target, events);
        },
        close: function(event) {
            var tooltip, that = this, target = $(event ? event.currentTarget : this.element), tooltipData = this._find(target);
            // The tooltip may already be closed
            // The tooltip may already be closed
            // disabling closes the tooltip, so we need to track when we're closing
            // to avoid an infinite loop in case the tooltip becomes disabled on close
            // Clear the interval for delayed tracking tooltips
            // only set title if we had one before (see comment in _open())
            // If the title attribute has changed since open(), don't restore
            // Remove 'remove' binding only on delegated targets
            // We set ui-tooltip-open immediately upon open (in open()), but only set the
            // additional data once there's actually content to show (in _open()). So even if the
            // tooltip doesn't have full data, we always remove ui-tooltip-open in case we're in
            // the period between open() and _open().
            return tooltipData ? (tooltip = tooltipData.tooltip, void (tooltipData.closing || (clearInterval(this.delayedShow), 
            target.data("ui-tooltip-title") && !target.attr("title") && target.attr("title", target.data("ui-tooltip-title")), 
            this._removeDescribedBy(target), tooltipData.hiding = !0, tooltip.stop(!0), this._hide(tooltip, this.options.hide, function() {
                that._removeTooltip($(this));
            }), target.removeData("ui-tooltip-open"), this._off(target, "mouseleave focusout keyup"), 
            target[0] !== this.element[0] && this._off(target, "remove"), this._off(this.document, "mousemove"), 
            event && "mouseleave" === event.type && $.each(this.parents, function(id, parent) {
                $(parent.element).attr("title", parent.title), delete that.parents[id];
            }), tooltipData.closing = !0, this._trigger("close", event, {
                tooltip: tooltip
            }), tooltipData.hiding || (tooltipData.closing = !1)))) : void target.removeData("ui-tooltip-open");
        },
        _tooltip: function(element) {
            var tooltip = $("<div>").attr("role", "tooltip").addClass("ui-tooltip ui-widget ui-corner-all ui-widget-content " + (this.options.tooltipClass || "")), id = tooltip.uniqueId().attr("id");
            return $("<div>").addClass("ui-tooltip-content").appendTo(tooltip), tooltip.appendTo(this.document[0].body), 
            this.tooltips[id] = {
                element: element,
                tooltip: tooltip
            };
        },
        _find: function(target) {
            var id = target.data("ui-tooltip-id");
            return id ? this.tooltips[id] : null;
        },
        _removeTooltip: function(tooltip) {
            tooltip.remove(), delete this.tooltips[tooltip.attr("id")];
        },
        _destroy: function() {
            var that = this;
            // close open tooltips
            $.each(this.tooltips, function(id, tooltipData) {
                // Delegate to close method to handle common cleanup
                var event = $.Event("blur"), element = tooltipData.element;
                event.target = event.currentTarget = element[0], that.close(event, !0), // Remove immediately; destroying an open tooltip doesn't use the
                // hide animation
                $("#" + id).remove(), // Restore the title
                element.data("ui-tooltip-title") && (// If the title attribute has changed since open(), don't restore
                element.attr("title") || element.attr("title", element.data("ui-tooltip-title")), 
                element.removeData("ui-tooltip-title"));
            }), this.liveRegion.remove();
        }
    });
}), /*
 * Gritter for jQuery
 * http://www.boedesign.com/
 *
 * Copyright (c) 2012 Jordan Boesch
 * Dual licensed under the MIT and GPL licenses.
 *
 * Date: February 24, 2012
 * Version: 1.7.4
 */
function($) {
    /**
	* Set it up as an object under the jQuery namespace
	*/
    $.gritter = {}, /**
	* Set up global options that the user can over-ride
	*/
    $.gritter.options = {
        position: "",
        class_name: "",
        // could be set to 'gritter-light' to use white notifications
        fade_in_speed: "medium",
        // how fast notifications fade in
        fade_out_speed: 1e3,
        // how fast the notices fade out
        time: 6e3
    }, /**
	* Add a gritter notification to the screen
	* @see Gritter#add();
	*/
    $.gritter.add = function(params) {
        try {
            return Gritter.add(params || {});
        } catch (e) {
            var err = "Gritter Error: " + e;
            "undefined" != typeof console && console.error ? console.error(err, params) : alert(err);
        }
    }, /**
	* Remove a gritter notification from the screen
	* @see Gritter#removeSpecific();
	*/
    $.gritter.remove = function(id, params) {
        Gritter.removeSpecific(id, params || {});
    }, /**
	* Remove all notifications
	* @see Gritter#stop();
	*/
    $.gritter.removeAll = function(params) {
        Gritter.stop(params || {});
    };
    /**
	* Big fat Gritter object
	* @constructor (not really since its object literal)
	*/
    var Gritter = {
        // Public - options to over-ride with $.gritter.options in "add"
        position: "",
        fade_in_speed: "",
        fade_out_speed: "",
        time: "",
        // Private - no touchy the private parts
        _custom_timer: 0,
        _item_count: 0,
        _is_setup: 0,
        _tpl_close: '<a class="gritter-close" href="#" tabindex="1">Close Notification</a>',
        _tpl_title: '<span class="gritter-title">[[title]]</span>',
        _tpl_item: '<div id="gritter-item-[[number]]" class="gritter-item-wrapper [[item_class]]" style="display:none" role="alert"><div class="gritter-top"></div><div class="gritter-item">[[close]][[image]]<div class="[[class_name]]">[[title]]<p>[[text]]</p></div><div style="clear:both"></div></div><div class="gritter-bottom"></div></div>',
        _tpl_wrap: '<div id="gritter-notice-wrapper"></div>',
        /**
		* Add a gritter notification to the screen
		* @param {Object} params The object that contains all the options for drawing the notification
		* @return {Integer} The specific numeric id to that gritter notification
		*/
        add: function(params) {
            // We might have some issues if we don't have a title or text!
            if (// Handle straight text
            "string" == typeof params && (params = {
                text: params
            }), null === params.text) throw 'You must supply "text" parameter.';
            // Check the options and set them once
            this._is_setup || this._runSetup();
            // Basics
            var title = params.title, text = params.text, image = params.image || "", sticky = params.sticky || !1, item_class = params.class_name || $.gritter.options.class_name, position = $.gritter.options.position, time_alive = params.time || "";
            this._verifyWrapper(), this._item_count++;
            var number = this._item_count, tmp = this._tpl_item;
            // Assign callbacks
            $([ "before_open", "after_open", "before_close", "after_close" ]).each(function(i, val) {
                Gritter["_" + val + "_" + number] = $.isFunction(params[val]) ? params[val] : function() {};
            }), // Reset
            this._custom_timer = 0, // A custom fade time set
            time_alive && (this._custom_timer = time_alive);
            var image_str = "" != image ? '<img src="' + image + '" class="gritter-image" />' : "", class_name = "" != image ? "gritter-with-image" : "gritter-without-image";
            // If it's false, don't show another gritter message
            if (// String replacements on the template
            title = title ? this._str_replace("[[title]]", title, this._tpl_title) : "", tmp = this._str_replace([ "[[title]]", "[[text]]", "[[close]]", "[[image]]", "[[number]]", "[[class_name]]", "[[item_class]]" ], [ title, text, this._tpl_close, image_str, this._item_count, class_name, item_class ], tmp), 
            this["_before_open_" + number]() === !1) return !1;
            $("#gritter-notice-wrapper").addClass(position).append(tmp);
            var item = $("#gritter-item-" + this._item_count);
            // Bind the hover/unhover states
            // Clicking (X) makes the perdy thing close
            return item.fadeIn(this.fade_in_speed, function() {
                Gritter["_after_open_" + number]($(this));
            }), sticky || this._setFadeTimer(item, number), $(item).bind("mouseenter mouseleave", function(event) {
                "mouseenter" == event.type ? sticky || Gritter._restoreItemIfFading($(this), number) : sticky || Gritter._setFadeTimer($(this), number), 
                Gritter._hoverState($(this), event.type);
            }), $(item).find(".gritter-close").click(function() {
                return Gritter.removeSpecific(number, {}, null, !0), !1;
            }), number;
        },
        /**
		* If we don't have any more gritter notifications, get rid of the wrapper using this check
		* @private
		* @param {Integer} unique_id The ID of the element that was just deleted, use it for a callback
		* @param {Object} e The jQuery element that we're going to perform the remove() action on
		* @param {Boolean} manual_close Did we close the gritter dialog with the (X) button
		*/
        _countRemoveWrapper: function(unique_id, e, manual_close) {
            // Remove it then run the callback function
            e.remove(), this["_after_close_" + unique_id](e, manual_close), // Check if the wrapper is empty, if it is.. remove the wrapper
            0 == $(".gritter-item-wrapper").length && $("#gritter-notice-wrapper").remove();
        },
        /**
		* Fade out an element after it's been on the screen for x amount of time
		* @private
		* @param {Object} e The jQuery element to get rid of
		* @param {Integer} unique_id The id of the element to remove
		* @param {Object} params An optional list of params to set fade speeds etc.
		* @param {Boolean} unbind_events Unbind the mouseenter/mouseleave events if they click (X)
		*/
        _fade: function(e, unique_id, params, unbind_events) {
            var params = params || {}, fade = "undefined" != typeof params.fade ? params.fade : !0, fade_out_speed = params.speed || this.fade_out_speed, manual_close = unbind_events;
            this["_before_close_" + unique_id](e, manual_close), // If this is true, then we are coming from clicking the (X)
            unbind_events && e.unbind("mouseenter mouseleave"), // Fade it out or remove it
            fade ? e.animate({
                opacity: 0
            }, fade_out_speed, function() {
                e.animate({
                    height: 0
                }, 300, function() {
                    Gritter._countRemoveWrapper(unique_id, e, manual_close);
                });
            }) : this._countRemoveWrapper(unique_id, e);
        },
        /**
		* Perform actions based on the type of bind (mouseenter, mouseleave) 
		* @private
		* @param {Object} e The jQuery element
		* @param {String} type The type of action we're performing: mouseenter or mouseleave
		*/
        _hoverState: function(e, type) {
            // Change the border styles and add the (X) close button when you hover
            "mouseenter" == type ? (e.addClass("hover"), // Show close button
            e.find(".gritter-close").show()) : (e.removeClass("hover"), // Hide close button
            e.find(".gritter-close").hide());
        },
        /**
		* Remove a specific notification based on an ID
		* @param {Integer} unique_id The ID used to delete a specific notification
		* @param {Object} params A set of options passed in to determine how to get rid of it
		* @param {Object} e The jQuery element that we're "fading" then removing
		* @param {Boolean} unbind_events If we clicked on the (X) we set this to true to unbind mouseenter/mouseleave
		*/
        removeSpecific: function(unique_id, params, e, unbind_events) {
            if (!e) var e = $("#gritter-item-" + unique_id);
            // We set the fourth param to let the _fade function know to 
            // unbind the "mouseleave" event.  Once you click (X) there's no going back!
            this._fade(e, unique_id, params || {}, unbind_events);
        },
        /**
		* If the item is fading out and we hover over it, restore it!
		* @private
		* @param {Object} e The HTML element to remove
		* @param {Integer} unique_id The ID of the element
		*/
        _restoreItemIfFading: function(e, unique_id) {
            clearTimeout(this["_int_id_" + unique_id]), e.stop().css({
                opacity: "",
                height: ""
            });
        },
        /**
		* Setup the global options - only once
		* @private
		*/
        _runSetup: function() {
            for (opt in $.gritter.options) this[opt] = $.gritter.options[opt];
            this._is_setup = 1;
        },
        /**
		* Set the notification to fade out after a certain amount of time
		* @private
		* @param {Object} item The HTML element we're dealing with
		* @param {Integer} unique_id The ID of the element
		*/
        _setFadeTimer: function(e, unique_id) {
            var timer_str = this._custom_timer ? this._custom_timer : this.time;
            this["_int_id_" + unique_id] = setTimeout(function() {
                Gritter._fade(e, unique_id);
            }, timer_str);
        },
        /**
		* Bring everything to a halt
		* @param {Object} params A list of callback functions to pass when all notifications are removed
		*/
        stop: function(params) {
            // callbacks (if passed)
            var before_close = $.isFunction(params.before_close) ? params.before_close : function() {}, after_close = $.isFunction(params.after_close) ? params.after_close : function() {}, wrap = $("#gritter-notice-wrapper");
            before_close(wrap), wrap.fadeOut(function() {
                $(this).remove(), after_close();
            });
        },
        /**
		* An extremely handy PHP function ported to JS, works well for templating
		* @private
		* @param {String/Array} search A list of things to search for
		* @param {String/Array} replace A list of things to replace the searches with
		* @return {String} sa The output
		*/
        _str_replace: function(search, replace, subject, count) {
            var i = 0, j = 0, temp = "", repl = "", sl = 0, fl = 0, f = [].concat(search), r = [].concat(replace), s = subject, ra = r instanceof Array, sa = s instanceof Array;
            for (s = [].concat(s), count && (this.window[count] = 0), i = 0, sl = s.length; sl > i; i++) if ("" !== s[i]) for (j = 0, 
            fl = f.length; fl > j; j++) temp = s[i] + "", repl = ra ? void 0 !== r[j] ? r[j] : "" : r[0], 
            s[i] = temp.split(f[j]).join(repl), count && s[i] !== temp && (this.window[count] += (temp.length - s[i].length) / f[j].length);
            return sa ? s : s[0];
        },
        /**
		* A check to make sure we have something to wrap our notices with
		* @private
		*/
        _verifyWrapper: function() {
            0 == $("#gritter-notice-wrapper").length && $("body").append(this._tpl_wrap);
        }
    };
}(jQuery), /*!
 * jQuery Mousewheel 3.1.13
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 */
function(factory) {
    "function" == typeof define && define.amd ? // AMD. Register as an anonymous module.
    define([ "jquery" ], factory) : "object" == typeof exports ? // Node/CommonJS style for Browserify
    module.exports = factory : // Browser globals
    factory(jQuery);
}(function($) {
    function handler(event) {
        var orgEvent = event || window.event, args = slice.call(arguments, 1), delta = 0, deltaX = 0, deltaY = 0, absDelta = 0, offsetX = 0, offsetY = 0;
        // No change actually happened, no reason to go any further
        if (event = $.event.fix(orgEvent), event.type = "mousewheel", "detail" in orgEvent && (deltaY = -1 * orgEvent.detail), 
        "wheelDelta" in orgEvent && (deltaY = orgEvent.wheelDelta), "wheelDeltaY" in orgEvent && (deltaY = orgEvent.wheelDeltaY), 
        "wheelDeltaX" in orgEvent && (deltaX = -1 * orgEvent.wheelDeltaX), "axis" in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS && (deltaX = -1 * deltaY, 
        deltaY = 0), delta = 0 === deltaY ? deltaX : deltaY, "deltaY" in orgEvent && (deltaY = -1 * orgEvent.deltaY, 
        delta = deltaY), "deltaX" in orgEvent && (deltaX = orgEvent.deltaX, 0 === deltaY && (delta = -1 * deltaX)), 
        0 !== deltaY || 0 !== deltaX) {
            // Need to convert lines and pages to pixels if we aren't already in pixels
            // There are three delta modes:
            //   * deltaMode 0 is by pixels, nothing to do
            //   * deltaMode 1 is by lines
            //   * deltaMode 2 is by pages
            if (1 === orgEvent.deltaMode) {
                var lineHeight = $.data(this, "mousewheel-line-height");
                delta *= lineHeight, deltaY *= lineHeight, deltaX *= lineHeight;
            } else if (2 === orgEvent.deltaMode) {
                var pageHeight = $.data(this, "mousewheel-page-height");
                delta *= pageHeight, deltaY *= pageHeight, deltaX *= pageHeight;
            }
            // Normalise offsetX and offsetY properties
            if (absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX)), (!lowestDelta || lowestDelta > absDelta) && (lowestDelta = absDelta, 
            shouldAdjustOldDeltas(orgEvent, absDelta) && (lowestDelta /= 40)), shouldAdjustOldDeltas(orgEvent, absDelta) && (delta /= 40, 
            deltaX /= 40, deltaY /= 40), delta = Math[delta >= 1 ? "floor" : "ceil"](delta / lowestDelta), 
            deltaX = Math[deltaX >= 1 ? "floor" : "ceil"](deltaX / lowestDelta), deltaY = Math[deltaY >= 1 ? "floor" : "ceil"](deltaY / lowestDelta), 
            special.settings.normalizeOffset && this.getBoundingClientRect) {
                var boundingRect = this.getBoundingClientRect();
                offsetX = event.clientX - boundingRect.left, offsetY = event.clientY - boundingRect.top;
            }
            // Add information to the event object
            // Go ahead and set deltaMode to 0 since we converted to pixels
            // Although this is a little odd since we overwrite the deltaX/Y
            // properties with normalized deltas.
            // Add event and delta to the front of the arguments
            // Clearout lowestDelta after sometime to better
            // handle multiple device types that give different
            // a different lowestDelta
            // Ex: trackpad = 3 and mouse wheel = 120
            return event.deltaX = deltaX, event.deltaY = deltaY, event.deltaFactor = lowestDelta, 
            event.offsetX = offsetX, event.offsetY = offsetY, event.deltaMode = 0, args.unshift(event, delta, deltaX, deltaY), 
            nullLowestDeltaTimeout && clearTimeout(nullLowestDeltaTimeout), nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200), 
            ($.event.dispatch || $.event.handle).apply(this, args);
        }
    }
    function nullLowestDelta() {
        lowestDelta = null;
    }
    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && "mousewheel" === orgEvent.type && absDelta % 120 === 0;
    }
    var nullLowestDeltaTimeout, lowestDelta, toFix = [ "wheel", "mousewheel", "DOMMouseScroll", "MozMousePixelScroll" ], toBind = "onwheel" in document || document.documentMode >= 9 ? [ "wheel" ] : [ "mousewheel", "DomMouseScroll", "MozMousePixelScroll" ], slice = Array.prototype.slice;
    if ($.event.fixHooks) for (var i = toFix.length; i; ) $.event.fixHooks[toFix[--i]] = $.event.mouseHooks;
    var special = $.event.special.mousewheel = {
        version: "3.1.12",
        setup: function() {
            if (this.addEventListener) for (var i = toBind.length; i; ) this.addEventListener(toBind[--i], handler, !1); else this.onmousewheel = handler;
            // Store the line height and page height for this particular element
            $.data(this, "mousewheel-line-height", special.getLineHeight(this)), $.data(this, "mousewheel-page-height", special.getPageHeight(this));
        },
        teardown: function() {
            if (this.removeEventListener) for (var i = toBind.length; i; ) this.removeEventListener(toBind[--i], handler, !1); else this.onmousewheel = null;
            // Clean up the data we added to the element
            $.removeData(this, "mousewheel-line-height"), $.removeData(this, "mousewheel-page-height");
        },
        getLineHeight: function(elem) {
            var $elem = $(elem), $parent = $elem["offsetParent" in $.fn ? "offsetParent" : "parent"]();
            return $parent.length || ($parent = $("body")), parseInt($parent.css("fontSize"), 10) || parseInt($elem.css("fontSize"), 10) || 16;
        },
        getPageHeight: function(elem) {
            return $(elem).height();
        },
        settings: {
            adjustOldDeltas: !0,
            // see shouldAdjustOldDeltas() below
            normalizeOffset: !0
        }
    };
    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel");
        },
        unmousewheel: function(fn) {
            return this.unbind("mousewheel", fn);
        }
    });
}), /* jquery.nicescroll
-- version 3.5.6
-- copyright 2014-10-09 InuYaksa*2014
-- licensed under the MIT
--
-- http://nicescroll.areaaperta.com/
-- https://github.com/inuyaksa/jquery.nicescroll
--
*/
function(factory) {
    "function" == typeof define && define.amd ? // AMD. Register as anonymous module.
    define([ "jquery" ], factory) : // Browser globals.
    factory(jQuery);
}(function(jQuery) {
    // sandbox
    // http://stackoverflow.com/questions/2161159/get-script-path
    function getScriptPath() {
        var scripts = document.getElementsByTagName("script"), path = scripts[scripts.length - 1].src.split("?")[0];
        return path.split("/").length > 0 ? path.split("/").slice(0, -1).join("/") + "/" : "";
    }
    function mplex(el, lst, fn) {
        for (var a = 0; a < lst.length; a++) fn(el, lst[a]);
    }
    // globals
    var domfocus = !1, mousefocus = !1, tabindexcounter = 0, ascrailcounter = 2e3, globalmaxzindex = 0, $ = jQuery, vendors = [ "ms", "moz", "webkit", "o" ], setAnimationFrame = window.requestAnimationFrame || !1, clearAnimationFrame = window.cancelAnimationFrame || !1;
    if (!setAnimationFrame) for (var vx in vendors) {
        var v = vendors[vx];
        setAnimationFrame || (setAnimationFrame = window[v + "RequestAnimationFrame"]), 
        clearAnimationFrame || (clearAnimationFrame = window[v + "CancelAnimationFrame"] || window[v + "CancelRequestAnimationFrame"]);
    }
    var clsMutationObserver = window.MutationObserver || window.WebKitMutationObserver || !1, _globaloptions = {
        zindex: "auto",
        cursoropacitymin: 0,
        cursoropacitymax: 1,
        cursorcolor: "#424242",
        cursorwidth: "5px",
        cursorborder: "1px solid #fff",
        cursorborderradius: "5px",
        scrollspeed: 60,
        mousescrollstep: 24,
        touchbehavior: !1,
        hwacceleration: !0,
        usetransition: !0,
        boxzoom: !1,
        dblclickzoom: !0,
        gesturezoom: !0,
        grabcursorenabled: !0,
        autohidemode: !0,
        background: "",
        iframeautoresize: !0,
        cursorminheight: 32,
        preservenativescrolling: !0,
        railoffset: !1,
        railhoffset: !1,
        bouncescroll: !0,
        spacebarenabled: !0,
        railpadding: {
            top: 0,
            right: 0,
            left: 0,
            bottom: 0
        },
        disableoutline: !0,
        horizrailenabled: !0,
        railalign: "right",
        railvalign: "bottom",
        enabletranslate3d: !0,
        enablemousewheel: !0,
        enablekeyboard: !0,
        smoothscroll: !0,
        sensitiverail: !0,
        enablemouselockapi: !0,
        //      cursormaxheight:false,
        cursorfixedheight: !1,
        directionlockdeadzone: 6,
        hidecursordelay: 400,
        nativeparentscrolling: !0,
        enablescrollonselection: !0,
        overflowx: !0,
        overflowy: !0,
        cursordragspeed: .3,
        rtlmode: "auto",
        cursordragontouch: !1,
        oneaxismousemode: "auto",
        scriptpath: getScriptPath()
    }, browserdetected = !1, getBrowserDetection = function() {
        function detectCursorGrab() {
            var lst = [ "-moz-grab", "-webkit-grab", "grab" ];
            (d.ischrome && !d.ischrome22 || d.isie) && (lst = []);
            // force setting for IE returns false positive and chrome cursor bug
            for (var a = 0; a < lst.length; a++) {
                var p = lst[a];
                if (domtest.style.cursor = p, domtest.style.cursor == p) return p;
            }
            return "url(//mail.google.com/mail/images/2/openhand.cur),n-resize";
        }
        if (browserdetected) return browserdetected;
        var domtest = document.createElement("DIV"), d = {};
        d.haspointerlock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document, 
        d.isopera = "opera" in window, d.isopera12 = d.isopera && "getUserMedia" in navigator, 
        d.isoperamini = "[object OperaMini]" === Object.prototype.toString.call(window.operamini), 
        d.isie = "all" in document && "attachEvent" in domtest && !d.isopera, d.isieold = d.isie && !("msInterpolationMode" in domtest.style), 
        // IE6 and older
        d.isie7 = d.isie && !d.isieold && (!("documentMode" in document) || 7 == document.documentMode), 
        d.isie8 = d.isie && "documentMode" in document && 8 == document.documentMode, d.isie9 = d.isie && "performance" in window && document.documentMode >= 9, 
        d.isie10 = d.isie && "performance" in window && document.documentMode >= 10, d.isie9mobile = /iemobile.9/i.test(navigator.userAgent), 
        //wp 7.1 mango
        d.isie9mobile && (d.isie9 = !1), d.isie7mobile = !d.isie9mobile && d.isie7 && /iemobile/i.test(navigator.userAgent), 
        //wp 7.0
        d.ismozilla = "MozAppearance" in domtest.style, d.iswebkit = "WebkitAppearance" in domtest.style, 
        d.ischrome = "chrome" in window, d.ischrome22 = d.ischrome && d.haspointerlock, 
        d.ischrome26 = d.ischrome && "transition" in domtest.style, // issue with transform detection (maintain prefix)
        d.cantouch = "ontouchstart" in document.documentElement || "ontouchstart" in window, 
        // detection for Chrome Touch Emulation
        d.hasmstouch = window.navigator.msPointerEnabled || !1, // IE10+ pointer events
        d.ismac = /^mac$/i.test(navigator.platform), d.isios = d.cantouch && /iphone|ipad|ipod/i.test(navigator.platform), 
        d.isios4 = d.isios && !("seal" in Object), d.isandroid = /android/i.test(navigator.userAgent), 
        d.trstyle = !1, d.hastransform = !1, d.hastranslate3d = !1, d.transitionstyle = !1, 
        d.hastransition = !1, d.transitionend = !1;
        for (var check = [ "transform", "msTransform", "webkitTransform", "MozTransform", "OTransform" ], a = 0; a < check.length; a++) if ("undefined" != typeof domtest.style[check[a]]) {
            d.trstyle = check[a];
            break;
        }
        d.hastransform = 0 != d.trstyle, d.hastransform && (domtest.style[d.trstyle] = "translate3d(1px,2px,3px)", 
        d.hastranslate3d = /translate3d/.test(domtest.style[d.trstyle])), d.transitionstyle = !1, 
        d.prefixstyle = "", d.transitionend = !1;
        for (var check = [ "transition", "webkitTransition", "MozTransition", "OTransition", "OTransition", "msTransition", "KhtmlTransition" ], prefix = [ "", "-webkit-", "-moz-", "-o-", "-o", "-ms-", "-khtml-" ], evs = [ "transitionend", "webkitTransitionEnd", "transitionend", "otransitionend", "oTransitionEnd", "msTransitionEnd", "KhtmlTransitionEnd" ], a = 0; a < check.length; a++) if (check[a] in domtest.style) {
            d.transitionstyle = check[a], d.prefixstyle = prefix[a], d.transitionend = evs[a];
            break;
        }
        // use always prefix
        //memory released
        return d.ischrome26 && (d.prefixstyle = prefix[1]), d.hastransition = d.transitionstyle, 
        d.cursorgrabvalue = detectCursorGrab(), d.hasmousecapture = "setCapture" in domtest, 
        d.hasMutationObserver = clsMutationObserver !== !1, domtest = null, browserdetected = d, 
        d;
    }, NiceScrollClass = function(myopt, me) {
        // prevent flickering http://stackoverflow.com/questions/3461441/      
        //derived from http://stackoverflow.com/questions/11236090/
        function getMatrixValues() {
            var tr = self.doc.css(cap.trstyle);
            return tr && "matrix" == tr.substr(0, 6) ? tr.replace(/^.*\((.*)\)$/g, "$1").replace(/px/g, "").split(/, +/) : !1;
        }
        function getZIndex() {
            var dom = self.win;
            if ("zIndex" in dom) return dom.zIndex();
            // use jQuery UI method when available
            for (;dom.length > 0; ) {
                if (9 == dom[0].nodeType) return !1;
                var zi = dom.css("zIndex");
                if (!isNaN(zi) && 0 != zi) return parseInt(zi);
                dom = dom.parent();
            }
            return !1;
        }
        function getWidthToPixel(dom, prop, chkheight) {
            var wd = dom.css(prop), px = parseFloat(wd);
            if (isNaN(px)) {
                px = _convertBorderWidth[wd] || 0;
                var brd = 3 == px ? chkheight ? self.win.outerHeight() - self.win.innerHeight() : self.win.outerWidth() - self.win.innerWidth() : 1;
                //DON'T TRUST CSS
                return self.isie8 && px && (px += 1), brd ? px : 0;
            }
            return px;
        }
        // modified by MDN https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/wheel
        function _modernWheelEvent(dom, name, fn, bubble) {
            self._bind(dom, name, function(e) {
                var e = e ? e : window.event, event = {
                    original: e,
                    target: e.target || e.srcElement,
                    type: "wheel",
                    deltaMode: "MozMousePixelScroll" == e.type ? 0 : 1,
                    deltaX: 0,
                    deltaZ: 0,
                    preventDefault: function() {
                        return e.preventDefault ? e.preventDefault() : e.returnValue = !1, !1;
                    },
                    stopImmediatePropagation: function() {
                        e.stopImmediatePropagation ? e.stopImmediatePropagation() : e.cancelBubble = !0;
                    }
                };
                return "mousewheel" == name ? (event.deltaY = -1 / 40 * e.wheelDelta, e.wheelDeltaX && (event.deltaX = -1 / 40 * e.wheelDeltaX)) : event.deltaY = e.detail, 
                fn.call(dom, event);
            }, bubble);
        }
        function execScrollWheel(e, hr, chkscroll) {
            var px, py;
            if (0 == e.deltaMode ? (px = -Math.floor(e.deltaX * (self.opt.mousescrollstep / 54)), 
            py = -Math.floor(e.deltaY * (self.opt.mousescrollstep / 54))) : 1 == e.deltaMode && (px = -Math.floor(e.deltaX * self.opt.mousescrollstep), 
            py = -Math.floor(e.deltaY * self.opt.mousescrollstep)), hr && self.opt.oneaxismousemode && 0 == px && py && (px = py, 
            py = 0), px && (self.scrollmom && self.scrollmom.stop(), self.lastdeltax += px, 
            self.debounced("mousewheelx", function() {
                var dt = self.lastdeltax;
                self.lastdeltax = 0, self.rail.drag || self.doScrollLeftBy(dt);
            }, 15)), py) {
                if (self.opt.nativeparentscrolling && chkscroll && !self.ispage && !self.zoomactive) if (0 > py) {
                    if (self.getScrollTop() >= self.page.maxh) return !0;
                } else if (self.getScrollTop() <= 0) return !0;
                self.scrollmom && self.scrollmom.stop(), self.lastdeltay += py, self.debounced("mousewheely", function() {
                    var dt = self.lastdeltay;
                    self.lastdeltay = 0, self.rail.drag || self.doScrollBy(dt);
                }, 15);
            }
            return e.stopImmediatePropagation(), e.preventDefault();
        }
        var self = this;
        if (this.version = "3.5.6", this.name = "nicescroll", this.me = me, this.opt = {
            doc: $("body"),
            win: !1
        }, $.extend(this.opt, _globaloptions), // Options for internal use
        this.opt.snapbackspeed = 80, myopt) for (var a in self.opt) "undefined" != typeof myopt[a] && (self.opt[a] = myopt[a]);
        this.doc = self.opt.doc, this.iddoc = this.doc && this.doc[0] ? this.doc[0].id || "" : "", 
        this.ispage = /^BODY|HTML/.test(self.opt.win ? self.opt.win[0].nodeName : this.doc[0].nodeName), 
        this.haswrapper = self.opt.win !== !1, this.win = self.opt.win || (this.ispage ? $(window) : this.doc), 
        this.docscroll = this.ispage && !this.haswrapper ? $(window) : this.win, this.body = $("body"), 
        this.viewport = !1, this.isfixed = !1, this.iframe = !1, this.isiframe = "IFRAME" == this.doc[0].nodeName && "IFRAME" == this.win[0].nodeName, 
        this.istextarea = "TEXTAREA" == this.win[0].nodeName, this.forcescreen = !1, //force to use screen position on events
        this.canshowonmouseevent = "scroll" != self.opt.autohidemode, // Events jump table    
        this.onmousedown = !1, this.onmouseup = !1, this.onmousemove = !1, this.onmousewheel = !1, 
        this.onkeypress = !1, this.ongesturezoom = !1, this.onclick = !1, // Nicescroll custom events
        this.onscrollstart = !1, this.onscrollend = !1, this.onscrollcancel = !1, this.onzoomin = !1, 
        this.onzoomout = !1, // Let's start!  
        this.view = !1, this.page = !1, this.scroll = {
            x: 0,
            y: 0
        }, this.scrollratio = {
            x: 0,
            y: 0
        }, this.cursorheight = 20, this.scrollvaluemax = 0, this.isrtlmode = "auto" == this.opt.rtlmode ? "rtl" == (this.win[0] == window ? this.body : this.win).css("direction") : this.opt.rtlmode === !0, 
        //    this.checkrtlmode = false;
        this.scrollrunning = !1, this.scrollmom = !1, this.observer = !1, this.observerremover = !1;
        // observer on parent for remove detection
        do this.id = "ascrail" + ascrailcounter++; while (document.getElementById(this.id));
        this.rail = !1, this.cursor = !1, this.cursorfreezed = !1, this.selectiondrag = !1, 
        this.zoom = !1, this.zoomactive = !1, this.hasfocus = !1, this.hasmousefocus = !1, 
        this.visibility = !0, this.locked = !1, this.hidden = !1, // rails always hidden
        this.cursoractive = !0, // user can interact with cursors
        this.wheelprevented = !1, //prevent mousewheel event
        this.overflowx = self.opt.overflowx, this.overflowy = self.opt.overflowy, this.nativescrollingarea = !1, 
        this.checkarea = 0, this.events = [], // event list for unbind
        this.saved = {}, this.delaylist = {}, this.synclist = {}, this.lastdeltax = 0, this.lastdeltay = 0, 
        this.detected = getBrowserDetection();
        var cap = $.extend({}, this.detected);
        this.canhwscroll = cap.hastransform && self.opt.hwacceleration, this.ishwscroll = this.canhwscroll && self.haswrapper, 
        this.istouchcapable = !1, // desktop devices with touch screen support
        //## Check WebKit-based desktop with touch support
        cap.cantouch && cap.iswebkit && !cap.isios && !cap.isandroid && (this.istouchcapable = !0, 
        cap.cantouch = !1), //## Firefox 18 nightly build (desktop) false positive (or desktop with touch support)
        cap.cantouch && cap.ismozilla && !cap.isios && !cap.isandroid && (this.istouchcapable = !0, 
        cap.cantouch = !1), //## disable MouseLock API on user request
        self.opt.enablemouselockapi || (cap.hasmousecapture = !1, cap.haspointerlock = !1), 
        this.delayed = function(name, fn, tm, lazy) {
            var dd = self.delaylist[name], nw = new Date().getTime();
            return !lazy && dd && dd.tt ? !1 : (dd && dd.tt && clearTimeout(dd.tt), void (dd && dd.last + tm > nw && !dd.tt ? self.delaylist[name] = {
                last: nw + tm,
                tt: setTimeout(function() {
                    self && (self.delaylist[name].tt = 0, fn.call());
                }, tm)
            } : dd && dd.tt || (self.delaylist[name] = {
                last: nw,
                tt: 0
            }, setTimeout(function() {
                fn.call();
            }, 0))));
        }, this.debounced = function(name, fn, tm) {
            var dd = self.delaylist[name];
            new Date().getTime();
            self.delaylist[name] = fn, dd || setTimeout(function() {
                var fn = self.delaylist[name];
                self.delaylist[name] = !1, fn.call();
            }, tm);
        };
        var _onsync = !1;
        if (this.synched = function(name, fn) {
            function requestSync() {
                _onsync || (setAnimationFrame(function() {
                    _onsync = !1;
                    for (name in self.synclist) {
                        var fn = self.synclist[name];
                        fn && fn.call(self), self.synclist[name] = !1;
                    }
                }), _onsync = !0);
            }
            return self.synclist[name] = fn, requestSync(), name;
        }, this.unsynched = function(name) {
            self.synclist[name] && (self.synclist[name] = !1);
        }, this.css = function(el, pars) {
            // save & set
            for (var n in pars) self.saved.css.push([ el, n, el.css(n) ]), el.css(n, pars[n]);
        }, this.scrollTop = function(val) {
            return "undefined" == typeof val ? self.getScrollTop() : self.setScrollTop(val);
        }, this.scrollLeft = function(val) {
            return "undefined" == typeof val ? self.getScrollLeft() : self.setScrollLeft(val);
        }, // derived by by Dan Pupius www.pupius.net
        BezierClass = function(st, ed, spd, p1, p2, p3, p4) {
            this.st = st, this.ed = ed, this.spd = spd, this.p1 = p1 || 0, this.p2 = p2 || 1, 
            this.p3 = p3 || 0, this.p4 = p4 || 1, this.ts = new Date().getTime(), this.df = this.ed - this.st;
        }, BezierClass.prototype = {
            B2: function(t) {
                return 3 * t * t * (1 - t);
            },
            B3: function(t) {
                return 3 * t * (1 - t) * (1 - t);
            },
            B4: function(t) {
                return (1 - t) * (1 - t) * (1 - t);
            },
            getNow: function() {
                var nw = new Date().getTime(), pc = 1 - (nw - this.ts) / this.spd, bz = this.B2(pc) + this.B3(pc) + this.B4(pc);
                return 0 > pc ? this.ed : this.st + Math.round(this.df * bz);
            },
            update: function(ed, spd) {
                return this.st = this.getNow(), this.ed = ed, this.spd = spd, this.ts = new Date().getTime(), 
                this.df = this.ed - this.st, this;
            }
        }, this.ishwscroll) {
            // hw accelerated scroll
            this.doc.translate = {
                x: 0,
                y: 0,
                tx: "0px",
                ty: "0px"
            }, //this one can help to enable hw accel on ios6 http://indiegamr.com/ios6-html-hardware-acceleration-changes-and-how-to-fix-them/
            cap.hastranslate3d && cap.isios && this.doc.css("-webkit-backface-visibility", "hidden"), 
            this.getScrollTop = function(last) {
                if (!last) {
                    var mtx = getMatrixValues();
                    if (mtx) return 16 == mtx.length ? -mtx[13] : -mtx[5];
                    //matrix3d 16 on IE10
                    if (self.timerscroll && self.timerscroll.bz) return self.timerscroll.bz.getNow();
                }
                return self.doc.translate.y;
            }, this.getScrollLeft = function(last) {
                if (!last) {
                    var mtx = getMatrixValues();
                    if (mtx) return 16 == mtx.length ? -mtx[12] : -mtx[4];
                    //matrix3d 16 on IE10
                    if (self.timerscroll && self.timerscroll.bh) return self.timerscroll.bh.getNow();
                }
                return self.doc.translate.x;
            }, document.createEvent ? this.notifyScrollEvent = function(el) {
                var e = document.createEvent("UIEvents");
                e.initUIEvent("scroll", !1, !0, window, 1), el.dispatchEvent(e);
            } : document.fireEvent ? this.notifyScrollEvent = function(el) {
                var e = document.createEventObject();
                el.fireEvent("onscroll"), e.cancelBubble = !0;
            } : this.notifyScrollEvent = function(el, add) {};
            var cxscrollleft = this.isrtlmode ? 1 : -1;
            cap.hastranslate3d && self.opt.enabletranslate3d ? (this.setScrollTop = function(val, silent) {
                self.doc.translate.y = val, self.doc.translate.ty = -1 * val + "px", self.doc.css(cap.trstyle, "translate3d(" + self.doc.translate.tx + "," + self.doc.translate.ty + ",0px)"), 
                silent || self.notifyScrollEvent(self.win[0]);
            }, this.setScrollLeft = function(val, silent) {
                self.doc.translate.x = val, self.doc.translate.tx = val * cxscrollleft + "px", self.doc.css(cap.trstyle, "translate3d(" + self.doc.translate.tx + "," + self.doc.translate.ty + ",0px)"), 
                silent || self.notifyScrollEvent(self.win[0]);
            }) : (this.setScrollTop = function(val, silent) {
                self.doc.translate.y = val, self.doc.translate.ty = -1 * val + "px", self.doc.css(cap.trstyle, "translate(" + self.doc.translate.tx + "," + self.doc.translate.ty + ")"), 
                silent || self.notifyScrollEvent(self.win[0]);
            }, this.setScrollLeft = function(val, silent) {
                self.doc.translate.x = val, self.doc.translate.tx = val * cxscrollleft + "px", self.doc.css(cap.trstyle, "translate(" + self.doc.translate.tx + "," + self.doc.translate.ty + ")"), 
                silent || self.notifyScrollEvent(self.win[0]);
            });
        } else // native scroll
        this.getScrollTop = function() {
            return self.docscroll.scrollTop();
        }, this.setScrollTop = function(val) {
            return self.docscroll.scrollTop(val);
        }, this.getScrollLeft = function() {
            return self.detected.ismozilla && self.isrtlmode ? Math.abs(self.docscroll.scrollLeft()) : self.docscroll.scrollLeft();
        }, this.setScrollLeft = function(val) {
            return self.docscroll.scrollLeft(self.detected.ismozilla && self.isrtlmode ? -val : val);
        };
        this.getTarget = function(e) {
            return e ? e.target ? e.target : e.srcElement ? e.srcElement : !1 : !1;
        }, this.hasParent = function(e, id) {
            if (!e) return !1;
            for (var el = e.target || e.srcElement || e || !1; el && el.id != id; ) el = el.parentNode || !1;
            return el !== !1;
        };
        //inspired by http://forum.jquery.com/topic/width-includes-border-width-when-set-to-thin-medium-thick-in-ie
        var _convertBorderWidth = {
            thin: 1,
            medium: 3,
            thick: 5
        };
        this.getOffset = function() {
            if (self.isfixed) return {
                top: parseFloat(self.win.css("top")),
                left: parseFloat(self.win.css("left"))
            };
            if (!self.viewport) return self.win.offset();
            var ww = self.win.offset(), vp = self.viewport.offset();
            return {
                top: ww.top - vp.top + self.viewport.scrollTop(),
                left: ww.left - vp.left + self.viewport.scrollLeft()
            };
        }, this.updateScrollBar = function(len) {
            if (self.ishwscroll) self.rail.css({
                height: self.win.innerHeight()
            }), self.railh && self.railh.css({
                width: self.win.innerWidth()
            }); else {
                var wpos = self.getOffset(), pos = {
                    top: wpos.top,
                    left: wpos.left
                };
                pos.top += getWidthToPixel(self.win, "border-top-width", !0);
                (self.win.outerWidth() - self.win.innerWidth()) / 2;
                pos.left += self.rail.align ? self.win.outerWidth() - getWidthToPixel(self.win, "border-right-width") - self.rail.width : getWidthToPixel(self.win, "border-left-width");
                var off = self.opt.railoffset;
                if (off && (off.top && (pos.top += off.top), self.rail.align && off.left && (pos.left += off.left)), 
                self.locked || self.rail.css({
                    top: pos.top,
                    left: pos.left,
                    height: len ? len.h : self.win.innerHeight()
                }), self.zoom && self.zoom.css({
                    top: pos.top + 1,
                    left: 1 == self.rail.align ? pos.left - 20 : pos.left + self.rail.width + 4
                }), self.railh && !self.locked) {
                    var pos = {
                        top: wpos.top,
                        left: wpos.left
                    }, off = self.opt.railhoffset;
                    off && (off.top && (pos.top += off.top), off.left && (pos.left += off.left));
                    var y = self.railh.align ? pos.top + getWidthToPixel(self.win, "border-top-width", !0) + self.win.innerHeight() - self.railh.height : pos.top + getWidthToPixel(self.win, "border-top-width", !0), x = pos.left + getWidthToPixel(self.win, "border-left-width");
                    self.railh.css({
                        top: y,
                        left: x,
                        width: self.railh.width
                    });
                }
            }
        }, this.doRailClick = function(e, dbl, hr) {
            var fn, pg, cur, pos;
            //      if (self.rail.drag&&self.rail.drag.pt!=1) return;
            self.locked || (//      if (self.rail.drag) return;
            //      self.cancelScroll();       
            self.cancelEvent(e), dbl ? (fn = hr ? self.doScrollLeft : self.doScrollTop, cur = hr ? (e.pageX - self.railh.offset().left - self.cursorwidth / 2) * self.scrollratio.x : (e.pageY - self.rail.offset().top - self.cursorheight / 2) * self.scrollratio.y, 
            fn(cur)) : (fn = hr ? self.doScrollLeftBy : self.doScrollBy, cur = hr ? self.scroll.x : self.scroll.y, 
            pos = hr ? e.pageX - self.railh.offset().left : e.pageY - self.rail.offset().top, 
            pg = hr ? self.view.w : self.view.h, fn(cur >= pos ? pg : -pg)));
        }, self.hasanimationframe = setAnimationFrame, self.hascancelanimationframe = clearAnimationFrame, 
        self.hasanimationframe ? self.hascancelanimationframe || (clearAnimationFrame = function() {
            self.cancelAnimationFrame = !0;
        }) : (setAnimationFrame = function(fn) {
            return setTimeout(fn, 15 - Math.floor(+new Date() / 1e3) % 16);
        }, clearAnimationFrame = clearInterval), this.init = function() {
            function checkSelectionScroll(e) {
                if (self.selectiondrag) {
                    if (e) {
                        var ww = self.win.outerHeight(), df = e.pageY - self.selectiondrag.top;
                        df > 0 && ww > df && (df = 0), df >= ww && (df -= ww), self.selectiondrag.df = df;
                    }
                    if (0 != self.selectiondrag.df) {
                        var rt = 2 * -Math.floor(self.selectiondrag.df / 6);
                        //              self.doScrollTop(self.getScrollTop(true)+rt);
                        self.doScrollBy(rt), self.debounced("doselectionscroll", function() {
                            checkSelectionScroll();
                        }, 50);
                    }
                }
            }
            function oniframeload(e) {
                self.iframexd = !1;
                try {
                    var doc = "contentDocument" in this ? this.contentDocument : this.contentWindow.document;
                    doc.domain;
                } catch (e) {
                    self.iframexd = !0, doc = !1;
                }
                if (self.iframexd) return "console" in window && console.log("NiceScroll error: policy restriced iframe"), 
                !0;
                if (self.forcescreen = !0, self.isiframe && (self.iframe = {
                    doc: $(doc),
                    html: self.doc.contents().find("html")[0],
                    body: self.doc.contents().find("body")[0]
                }, self.getContentSize = function() {
                    return {
                        w: Math.max(self.iframe.html.scrollWidth, self.iframe.body.scrollWidth),
                        h: Math.max(self.iframe.html.scrollHeight, self.iframe.body.scrollHeight)
                    };
                }, self.docscroll = $(self.iframe.body)), !cap.isios && self.opt.iframeautoresize && !self.isiframe) {
                    self.win.scrollTop(0), // reset position
                    self.doc.height("");
                    //reset height to fix browser bug
                    var hh = Math.max(doc.getElementsByTagName("html")[0].scrollHeight, doc.body.scrollHeight);
                    self.doc.height(hh);
                }
                self.lazyResize(30), cap.isie7 && self.css($(self.iframe.html), {
                    "overflow-y": "hidden"
                }), //self.css($(doc.body),{'overflow-y':'hidden'});
                self.css($(self.iframe.body), {
                    "overflow-y": "hidden"
                }), cap.isios && self.haswrapper && self.css($(doc.body), {
                    "-webkit-transform": "translate3d(0,0,0)"
                }), "contentWindow" in this ? self.bind(this.contentWindow, "scroll", self.onscroll) : self.bind(doc, "scroll", self.onscroll), 
                self.opt.enablemousewheel && self.bind(doc, "mousewheel", self.onmousewheel), self.opt.enablekeyboard && self.bind(doc, cap.isopera ? "keypress" : "keydown", self.onkeypress), 
                (cap.cantouch || self.opt.touchbehavior) && (self.bind(doc, "mousedown", self.ontouchstart), 
                self.bind(doc, "mousemove", function(e) {
                    self.ontouchmove(e, !0);
                }), self.opt.grabcursorenabled && cap.cursorgrabvalue && self.css($(doc.body), {
                    cursor: cap.cursorgrabvalue
                })), self.bind(doc, "mouseup", self.ontouchend), self.zoom && (self.opt.dblclickzoom && self.bind(doc, "dblclick", self.doZoom), 
                self.ongesturezoom && self.bind(doc, "gestureend", self.ongesturezoom));
            }
            if (self.saved.css = [], cap.isie7mobile) return !0;
            // SORRY, DO NOT WORK!
            if (cap.isoperamini) return !0;
            /*      
      self.ispage = true;
      self.haswrapper = true;
//      self.win = $(window);
      self.docscroll = $("body");
//      self.doc = $("body");
*/
            if (// SORRY, DO NOT WORK!
            cap.hasmstouch && self.css(self.ispage ? $("html") : self.win, {
                "-ms-touch-action": "none"
            }), self.zindex = "auto", self.ispage || "auto" != self.opt.zindex ? self.zindex = self.opt.zindex : self.zindex = getZIndex() || "auto", 
            self.ispage || "auto" == self.zindex || self.zindex > globalmaxzindex && (globalmaxzindex = self.zindex), 
            self.isie && 0 == self.zindex && "auto" == self.opt.zindex && (// fix IE auto == 0
            self.zindex = "auto"), !self.ispage || !cap.cantouch && !cap.isieold && !cap.isie9mobile) {
                var cont = self.docscroll;
                self.ispage && (cont = self.haswrapper ? self.win : self.doc), cap.isie9mobile || self.css(cont, {
                    "overflow-y": "hidden"
                }), self.ispage && cap.isie7 && ("BODY" == self.doc[0].nodeName ? self.css($("html"), {
                    "overflow-y": "hidden"
                }) : "HTML" == self.doc[0].nodeName && self.css($("body"), {
                    "overflow-y": "hidden"
                })), !cap.isios || self.ispage || self.haswrapper || self.css($("body"), {
                    "-webkit-overflow-scrolling": "touch"
                });
                //force hw acceleration
                var cursor = $(document.createElement("div"));
                cursor.css({
                    position: "relative",
                    top: 0,
                    "float": "right",
                    width: self.opt.cursorwidth,
                    height: "0px",
                    "background-color": self.opt.cursorcolor,
                    border: self.opt.cursorborder,
                    "background-clip": "padding-box",
                    "-webkit-border-radius": self.opt.cursorborderradius,
                    "-moz-border-radius": self.opt.cursorborderradius,
                    "border-radius": self.opt.cursorborderradius
                }), cursor.hborder = parseFloat(cursor.outerHeight() - cursor.innerHeight()), self.cursor = cursor;
                var rail = $(document.createElement("div"));
                rail.attr("id", self.id), rail.addClass("nicescroll-rails");
                var v, a, kp = [ "left", "right" ];
                //"top","bottom"
                for (var n in kp) a = kp[n], v = self.opt.railpadding[a], v ? rail.css("padding-" + a, v + "px") : self.opt.railpadding[a] = 0;
                rail.append(cursor), rail.width = Math.max(parseFloat(self.opt.cursorwidth), cursor.outerWidth()) + self.opt.railpadding.left + self.opt.railpadding.right, 
                rail.css({
                    width: rail.width + "px",
                    zIndex: self.zindex,
                    background: self.opt.background,
                    cursor: "default"
                }), rail.visibility = !0, rail.scrollable = !0, rail.align = "left" == self.opt.railalign ? 0 : 1, 
                self.rail = rail, self.rail.drag = !1;
                var zoom = !1;
                if (!self.opt.boxzoom || self.ispage || cap.isieold || (zoom = document.createElement("div"), 
                self.bind(zoom, "click", self.doZoom), self.zoom = $(zoom), self.zoom.css({
                    cursor: "pointer",
                    "z-index": self.zindex,
                    backgroundImage: "url(" + self.opt.scriptpath + "zoomico.png)",
                    height: 18,
                    width: 18,
                    backgroundPosition: "0px 0px"
                }), self.opt.dblclickzoom && self.bind(self.win, "dblclick", self.doZoom), cap.cantouch && self.opt.gesturezoom && (self.ongesturezoom = function(e) {
                    return e.scale > 1.5 && self.doZoomIn(e), e.scale < .8 && self.doZoomOut(e), self.cancelEvent(e);
                }, self.bind(self.win, "gestureend", self.ongesturezoom))), // init HORIZ
                self.railh = !1, self.opt.horizrailenabled) {
                    self.css(cont, {
                        "overflow-x": "hidden"
                    });
                    var cursor = $(document.createElement("div"));
                    cursor.css({
                        position: "absolute",
                        top: 0,
                        height: self.opt.cursorwidth,
                        width: "0px",
                        "background-color": self.opt.cursorcolor,
                        border: self.opt.cursorborder,
                        "background-clip": "padding-box",
                        "-webkit-border-radius": self.opt.cursorborderradius,
                        "-moz-border-radius": self.opt.cursorborderradius,
                        "border-radius": self.opt.cursorborderradius
                    }), cursor.wborder = parseFloat(cursor.outerWidth() - cursor.innerWidth()), self.cursorh = cursor;
                    var railh = $(document.createElement("div"));
                    railh.attr("id", self.id + "-hr"), railh.addClass("nicescroll-rails"), railh.height = Math.max(parseFloat(self.opt.cursorwidth), cursor.outerHeight()), 
                    railh.css({
                        height: railh.height + "px",
                        zIndex: self.zindex,
                        background: self.opt.background
                    }), railh.append(cursor), railh.visibility = !0, railh.scrollable = !0, railh.align = "top" == self.opt.railvalign ? 0 : 1, 
                    self.railh = railh, self.railh.drag = !1;
                }
                //        
                if (self.ispage) rail.css({
                    position: "fixed",
                    top: "0px",
                    height: "100%"
                }), rail.align ? rail.css({
                    right: "0px"
                }) : rail.css({
                    left: "0px"
                }), self.body.append(rail), self.railh && (railh.css({
                    position: "fixed",
                    left: "0px",
                    width: "100%"
                }), railh.align ? railh.css({
                    bottom: "0px"
                }) : railh.css({
                    top: "0px"
                }), self.body.append(railh)); else {
                    if (self.ishwscroll) {
                        "static" == self.win.css("position") && self.css(self.win, {
                            position: "relative"
                        });
                        var bd = "HTML" == self.win[0].nodeName ? self.body : self.win;
                        self.zoom && (self.zoom.css({
                            position: "absolute",
                            top: 1,
                            right: 0,
                            "margin-right": rail.width + 4
                        }), bd.append(self.zoom)), rail.css({
                            position: "absolute",
                            top: 0
                        }), rail.align ? rail.css({
                            right: 0
                        }) : rail.css({
                            left: 0
                        }), bd.append(rail), railh && (railh.css({
                            position: "absolute",
                            left: 0,
                            bottom: 0
                        }), railh.align ? railh.css({
                            bottom: 0
                        }) : railh.css({
                            top: 0
                        }), bd.append(railh));
                    } else {
                        self.isfixed = "fixed" == self.win.css("position");
                        var rlpos = self.isfixed ? "fixed" : "absolute";
                        self.isfixed || (self.viewport = self.getViewport(self.win[0])), self.viewport && (self.body = self.viewport, 
                        0 == /fixed|relative|absolute/.test(self.viewport.css("position")) && self.css(self.viewport, {
                            position: "relative"
                        })), rail.css({
                            position: rlpos
                        }), self.zoom && self.zoom.css({
                            position: rlpos
                        }), self.updateScrollBar(), self.body.append(rail), self.zoom && self.body.append(self.zoom), 
                        self.railh && (railh.css({
                            position: rlpos
                        }), self.body.append(railh));
                    }
                    cap.isios && self.css(self.win, {
                        "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
                        "-webkit-touch-callout": "none"
                    }), // prevent grey layer on click
                    cap.isie && self.opt.disableoutline && self.win.attr("hideFocus", "true"), // IE, prevent dotted rectangle on focused div
                    cap.iswebkit && self.opt.disableoutline && self.win.css({
                        outline: "none"
                    });
                }
                if (self.opt.autohidemode === !1 ? (self.autohidedom = !1, self.rail.css({
                    opacity: self.opt.cursoropacitymax
                }), self.railh && self.railh.css({
                    opacity: self.opt.cursoropacitymax
                })) : self.opt.autohidemode === !0 || "leave" === self.opt.autohidemode ? (self.autohidedom = $().add(self.rail), 
                cap.isie8 && (self.autohidedom = self.autohidedom.add(self.cursor)), self.railh && (self.autohidedom = self.autohidedom.add(self.railh)), 
                self.railh && cap.isie8 && (self.autohidedom = self.autohidedom.add(self.cursorh))) : "scroll" == self.opt.autohidemode ? (self.autohidedom = $().add(self.rail), 
                self.railh && (self.autohidedom = self.autohidedom.add(self.railh))) : "cursor" == self.opt.autohidemode ? (self.autohidedom = $().add(self.cursor), 
                self.railh && (self.autohidedom = self.autohidedom.add(self.cursorh))) : "hidden" == self.opt.autohidemode && (self.autohidedom = !1, 
                self.hide(), self.locked = !1), cap.isie9mobile) {
                    self.scrollmom = new ScrollMomentumClass2D(self), /*
          var trace = function(msg) {
            var db = $("#debug");
            if (isNaN(msg)&&(typeof msg != "string")) {
              var x = [];
              for(var a in msg) {
                x.push(a+":"+msg[a]);
              }
              msg ="{"+x.join(",")+"}";
            }
            if (db.children().length>0) {
              db.children().eq(0).before("<div>"+msg+"</div>");
            } else {
              db.append("<div>"+msg+"</div>");
            }
          }
          window.onerror = function(msg,url,ln) {
            trace("ERR: "+msg+" at "+ln);
          }
*/
                    self.onmangotouch = function(e) {
                        var py = self.getScrollTop(), px = self.getScrollLeft();
                        if (py == self.scrollmom.lastscrolly && px == self.scrollmom.lastscrollx) return !0;
                        //            $("#debug").html('DRAG:'+py);
                        var dfy = py - self.mangotouch.sy, dfx = px - self.mangotouch.sx, df = Math.round(Math.sqrt(Math.pow(dfx, 2) + Math.pow(dfy, 2)));
                        if (0 != df) {
                            var dry = 0 > dfy ? -1 : 1, drx = 0 > dfx ? -1 : 1, tm = +new Date();
                            if (self.mangotouch.lazy && clearTimeout(self.mangotouch.lazy), tm - self.mangotouch.tm > 80 || self.mangotouch.dry != dry || self.mangotouch.drx != drx) //              trace('RESET+'+(tm-self.mangotouch.tm));
                            self.scrollmom.stop(), self.scrollmom.reset(px, py), self.mangotouch.sy = py, self.mangotouch.ly = py, 
                            self.mangotouch.sx = px, self.mangotouch.lx = px, self.mangotouch.dry = dry, self.mangotouch.drx = drx, 
                            self.mangotouch.tm = tm; else {
                                self.scrollmom.stop(), self.scrollmom.update(self.mangotouch.sx - dfx, self.mangotouch.sy - dfy);
                                tm - self.mangotouch.tm;
                                self.mangotouch.tm = tm;
                                //              trace('MOVE:'+df+" - "+gap);
                                var ds = Math.max(Math.abs(self.mangotouch.ly - py), Math.abs(self.mangotouch.lx - px));
                                self.mangotouch.ly = py, self.mangotouch.lx = px, ds > 2 && (self.mangotouch.lazy = setTimeout(function() {
                                    //                  trace('END:'+ds+'+'+gap);                  
                                    self.mangotouch.lazy = !1, self.mangotouch.dry = 0, self.mangotouch.drx = 0, self.mangotouch.tm = 0, 
                                    self.scrollmom.doMomentum(30);
                                }, 100));
                            }
                        }
                    };
                    var top = self.getScrollTop(), lef = self.getScrollLeft();
                    self.mangotouch = {
                        sy: top,
                        ly: top,
                        dry: 0,
                        sx: lef,
                        lx: lef,
                        drx: 0,
                        lazy: !1,
                        tm: 0
                    }, self.bind(self.docscroll, "scroll", self.onmangotouch);
                } else {
                    if (cap.cantouch || self.istouchcapable || self.opt.touchbehavior || cap.hasmstouch) {
                        self.scrollmom = new ScrollMomentumClass2D(self), self.ontouchstart = function(e) {
                            if (e.pointerType && 2 != e.pointerType && "touch" != e.pointerType) return !1;
                            if (self.hasmoving = !1, !self.locked) {
                                if (cap.hasmstouch) for (var tg = e.target ? e.target : !1; tg; ) {
                                    var nc = $(tg).getNiceScroll();
                                    if (nc.length > 0 && nc[0].me == self.me) break;
                                    if (nc.length > 0) return !1;
                                    if ("DIV" == tg.nodeName && tg.id == self.id) break;
                                    tg = tg.parentNode ? tg.parentNode : !1;
                                }
                                self.cancelScroll();
                                var tg = self.getTarget(e);
                                if (tg) {
                                    var skp = /INPUT/i.test(tg.nodeName) && /range/i.test(tg.type);
                                    if (skp) return self.stopPropagation(e);
                                }
                                if (!("clientX" in e) && "changedTouches" in e && (e.clientX = e.changedTouches[0].clientX, 
                                e.clientY = e.changedTouches[0].clientY), self.forcescreen) {
                                    var le = e, e = {
                                        original: e.original ? e.original : e
                                    };
                                    e.clientX = le.screenX, e.clientY = le.screenY;
                                }
                                if (self.rail.drag = {
                                    x: e.clientX,
                                    y: e.clientY,
                                    sx: self.scroll.x,
                                    sy: self.scroll.y,
                                    st: self.getScrollTop(),
                                    sl: self.getScrollLeft(),
                                    pt: 2,
                                    dl: !1
                                }, self.ispage || !self.opt.directionlockdeadzone) self.rail.drag.dl = "f"; else {
                                    var view = {
                                        w: $(window).width(),
                                        h: $(window).height()
                                    }, page = {
                                        w: Math.max(document.body.scrollWidth, document.documentElement.scrollWidth),
                                        h: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
                                    }, maxh = Math.max(0, page.h - view.h), maxw = Math.max(0, page.w - view.w);
                                    !self.rail.scrollable && self.railh.scrollable ? self.rail.drag.ck = maxh > 0 ? "v" : !1 : self.rail.scrollable && !self.railh.scrollable ? self.rail.drag.ck = maxw > 0 ? "h" : !1 : self.rail.drag.ck = !1, 
                                    self.rail.drag.ck || (self.rail.drag.dl = "f");
                                }
                                if (self.opt.touchbehavior && self.isiframe && cap.isie) {
                                    var wp = self.win.position();
                                    self.rail.drag.x += wp.left, self.rail.drag.y += wp.top;
                                }
                                if (self.hasmoving = !1, self.lastmouseup = !1, self.scrollmom.reset(e.clientX, e.clientY), 
                                !cap.cantouch && !this.istouchcapable && !cap.hasmstouch) {
                                    var ip = tg ? /INPUT|SELECT|TEXTAREA/i.test(tg.nodeName) : !1;
                                    if (!ip) // intercept DOM0 onclick event
                                    return !self.ispage && cap.hasmousecapture && tg.setCapture(), self.opt.touchbehavior ? (tg.onclick && !tg._onclick && (tg._onclick = tg.onclick, 
                                    tg.onclick = function(e) {
                                        return self.hasmoving ? !1 : void tg._onclick.call(this, e);
                                    }), self.cancelEvent(e)) : self.stopPropagation(e);
                                    /SUBMIT|CANCEL|BUTTON/i.test($(tg).attr("type")) && (pc = {
                                        tg: tg,
                                        click: !1
                                    }, self.preventclick = pc);
                                }
                            }
                        }, self.ontouchend = function(e) {
                            return e.pointerType && 2 != e.pointerType && "touch" != e.pointerType ? !1 : self.rail.drag && 2 == self.rail.drag.pt && (self.scrollmom.doMomentum(), 
                            self.rail.drag = !1, self.hasmoving && (self.lastmouseup = !0, self.hideCursor(), 
                            cap.hasmousecapture && document.releaseCapture(), !cap.cantouch)) ? self.cancelEvent(e) : void 0;
                        };
                        var moveneedoffset = self.opt.touchbehavior && self.isiframe && !cap.hasmousecapture;
                        self.ontouchmove = function(e, byiframe) {
                            if (e.pointerType && 2 != e.pointerType && "touch" != e.pointerType) return !1;
                            if (self.rail.drag && 2 == self.rail.drag.pt) {
                                if (cap.cantouch && "undefined" == typeof e.original) return !0;
                                // prevent ios "ghost" events by clickable elements
                                self.hasmoving = !0, self.preventclick && !self.preventclick.click && (self.preventclick.click = self.preventclick.tg.onclick || !1, 
                                self.preventclick.tg.onclick = self.onpreventclick);
                                var ev = $.extend({
                                    original: e
                                }, e);
                                if (e = ev, "changedTouches" in e && (e.clientX = e.changedTouches[0].clientX, e.clientY = e.changedTouches[0].clientY), 
                                self.forcescreen) {
                                    var le = e, e = {
                                        original: e.original ? e.original : e
                                    };
                                    e.clientX = le.screenX, e.clientY = le.screenY;
                                }
                                var ofx = ofy = 0;
                                if (moveneedoffset && !byiframe) {
                                    var wp = self.win.position();
                                    ofx = -wp.left, ofy = -wp.top;
                                }
                                var fy = e.clientY + ofy, my = fy - self.rail.drag.y, fx = e.clientX + ofx, mx = fx - self.rail.drag.x, ny = self.rail.drag.st - my;
                                if (self.ishwscroll && self.opt.bouncescroll ? 0 > ny ? ny = Math.round(ny / 2) : ny > self.page.maxh && (ny = self.page.maxh + Math.round((ny - self.page.maxh) / 2)) : (0 > ny && (ny = 0, 
                                fy = 0), ny > self.page.maxh && (ny = self.page.maxh, fy = 0)), self.railh && self.railh.scrollable) {
                                    var nx = self.isrtlmode ? mx - self.rail.drag.sl : self.rail.drag.sl - mx;
                                    self.ishwscroll && self.opt.bouncescroll ? 0 > nx ? nx = Math.round(nx / 2) : nx > self.page.maxw && (nx = self.page.maxw + Math.round((nx - self.page.maxw) / 2)) : (0 > nx && (nx = 0, 
                                    fx = 0), nx > self.page.maxw && (nx = self.page.maxw, fx = 0));
                                }
                                var grabbed = !1;
                                if (self.rail.drag.dl) grabbed = !0, "v" == self.rail.drag.dl ? nx = self.rail.drag.sl : "h" == self.rail.drag.dl && (ny = self.rail.drag.st); else {
                                    var ay = Math.abs(my), ax = Math.abs(mx), dz = self.opt.directionlockdeadzone;
                                    if ("v" == self.rail.drag.ck) {
                                        if (ay > dz && .3 * ay >= ax) return self.rail.drag = !1, !0;
                                        ax > dz && (self.rail.drag.dl = "f", $("body").scrollTop($("body").scrollTop()));
                                    } else if ("h" == self.rail.drag.ck) {
                                        if (ax > dz && .3 * ax >= ay) return self.rail.drag = !1, !0;
                                        ay > dz && (self.rail.drag.dl = "f", $("body").scrollLeft($("body").scrollLeft()));
                                    }
                                }
                                //chrome touch emulation doesn't like!
                                if (self.synched("touchmove", function() {
                                    self.rail.drag && 2 == self.rail.drag.pt && (self.prepareTransition && self.prepareTransition(0), 
                                    self.rail.scrollable && self.setScrollTop(ny), self.scrollmom.update(fx, fy), self.railh && self.railh.scrollable ? (self.setScrollLeft(nx), 
                                    self.showCursor(ny, nx)) : self.showCursor(ny), cap.isie10 && document.selection.clear());
                                }), cap.ischrome && self.istouchcapable && (grabbed = !1), grabbed) return self.cancelEvent(e);
                            }
                        };
                    }
                    self.onmousedown = function(e, hronly) {
                        if (!self.rail.drag || 1 == self.rail.drag.pt) {
                            if (self.locked) return self.cancelEvent(e);
                            self.cancelScroll(), self.rail.drag = {
                                x: e.clientX,
                                y: e.clientY,
                                sx: self.scroll.x,
                                sy: self.scroll.y,
                                pt: 1,
                                hr: !!hronly
                            };
                            var tg = self.getTarget(e);
                            return !self.ispage && cap.hasmousecapture && tg.setCapture(), self.isiframe && !cap.hasmousecapture && (self.saved.csspointerevents = self.doc.css("pointer-events"), 
                            self.css(self.doc, {
                                "pointer-events": "none"
                            })), self.hasmoving = !1, self.cancelEvent(e);
                        }
                    }, self.onmouseup = function(e) {
                        if (self.rail.drag) {
                            if (cap.hasmousecapture && document.releaseCapture(), self.isiframe && !cap.hasmousecapture && self.doc.css("pointer-events", self.saved.csspointerevents), 
                            1 != self.rail.drag.pt) return;
                            // TODO - check &&!self.scrollrunning
                            //if (!self.rail.active) self.hideCursor();
                            return self.rail.drag = !1, self.hasmoving && self.triggerScrollEnd(), self.cancelEvent(e);
                        }
                    }, self.onmousemove = function(e) {
                        if (self.rail.drag) {
                            if (1 != self.rail.drag.pt) return;
                            if (cap.ischrome && 0 == e.which) return self.onmouseup(e);
                            if (self.cursorfreezed = !0, self.hasmoving = !0, self.rail.drag.hr) {
                                self.scroll.x = self.rail.drag.sx + (e.clientX - self.rail.drag.x), self.scroll.x < 0 && (self.scroll.x = 0);
                                var mw = self.scrollvaluemaxw;
                                self.scroll.x > mw && (self.scroll.x = mw);
                            } else {
                                self.scroll.y = self.rail.drag.sy + (e.clientY - self.rail.drag.y), self.scroll.y < 0 && (self.scroll.y = 0);
                                var my = self.scrollvaluemax;
                                self.scroll.y > my && (self.scroll.y = my);
                            }
                            return self.synched("mousemove", function() {
                                self.rail.drag && 1 == self.rail.drag.pt && (self.showCursor(), self.rail.drag.hr ? self.doScrollLeft(Math.round(self.scroll.x * self.scrollratio.x), self.opt.cursordragspeed) : self.doScrollTop(Math.round(self.scroll.y * self.scrollratio.y), self.opt.cursordragspeed));
                            }), self.cancelEvent(e);
                        }
                    }, cap.cantouch || self.opt.touchbehavior ? (self.onpreventclick = function(e) {
                        return self.preventclick ? (self.preventclick.tg.onclick = self.preventclick.click, 
                        self.preventclick = !1, self.cancelEvent(e)) : void 0;
                    }, //            self.onmousedown = self.ontouchstart;            
                    //            self.onmouseup = self.ontouchend;
                    //            self.onmousemove = self.ontouchmove;
                    self.bind(self.win, "mousedown", self.ontouchstart), // control content dragging
                    self.onclick = cap.isios ? !1 : function(e) {
                        return self.lastmouseup ? (self.lastmouseup = !1, self.cancelEvent(e)) : !0;
                    }, self.opt.grabcursorenabled && cap.cursorgrabvalue && (self.css(self.ispage ? self.doc : self.win, {
                        cursor: cap.cursorgrabvalue
                    }), self.css(self.rail, {
                        cursor: cap.cursorgrabvalue
                    }))) : ("getSelection" in document ? // A grade - Major browsers
                    self.hasTextSelected = function() {
                        return document.getSelection().rangeCount > 0;
                    } : "selection" in document ? self.hasTextSelected = function() {
                        return "None" != document.selection.type;
                    } : self.hasTextSelected = function() {
                        // no support
                        return !1;
                    }, self.onselectionstart = function(e) {
                        self.ispage || (self.selectiondrag = self.win.offset());
                    }, self.onselectionend = function(e) {
                        self.selectiondrag = !1;
                    }, self.onselectiondrag = function(e) {
                        self.selectiondrag && self.hasTextSelected() && self.debounced("selectionscroll", function() {
                            checkSelectionScroll(e);
                        }, 250);
                    }), cap.hasmstouch && (self.css(self.rail, {
                        "-ms-touch-action": "none"
                    }), self.css(self.cursor, {
                        "-ms-touch-action": "none"
                    }), self.bind(self.win, "MSPointerDown", self.ontouchstart), self.bind(document, "MSPointerUp", self.ontouchend), 
                    self.bind(document, "MSPointerMove", self.ontouchmove), self.bind(self.cursor, "MSGestureHold", function(e) {
                        e.preventDefault();
                    }), self.bind(self.cursor, "contextmenu", function(e) {
                        e.preventDefault();
                    })), this.istouchcapable && (//desktop with screen touch enabled
                    self.bind(self.win, "touchstart", self.ontouchstart), self.bind(document, "touchend", self.ontouchend), 
                    self.bind(document, "touchcancel", self.ontouchend), self.bind(document, "touchmove", self.ontouchmove)), 
                    self.bind(self.cursor, "mousedown", self.onmousedown), self.bind(self.cursor, "mouseup", self.onmouseup), 
                    self.railh && (self.bind(self.cursorh, "mousedown", function(e) {
                        self.onmousedown(e, !0);
                    }), self.bind(self.cursorh, "mouseup", self.onmouseup)), (self.opt.cursordragontouch || !cap.cantouch && !self.opt.touchbehavior) && (self.rail.css({
                        cursor: "default"
                    }), self.railh && self.railh.css({
                        cursor: "default"
                    }), self.jqbind(self.rail, "mouseenter", function() {
                        return self.win.is(":visible") ? (self.canshowonmouseevent && self.showCursor(), 
                        void (self.rail.active = !0)) : !1;
                    }), self.jqbind(self.rail, "mouseleave", function() {
                        self.rail.active = !1, self.rail.drag || self.hideCursor();
                    }), self.opt.sensitiverail && (self.bind(self.rail, "click", function(e) {
                        self.doRailClick(e, !1, !1);
                    }), self.bind(self.rail, "dblclick", function(e) {
                        self.doRailClick(e, !0, !1);
                    }), self.bind(self.cursor, "click", function(e) {
                        self.cancelEvent(e);
                    }), self.bind(self.cursor, "dblclick", function(e) {
                        self.cancelEvent(e);
                    })), self.railh && (self.jqbind(self.railh, "mouseenter", function() {
                        return self.win.is(":visible") ? (self.canshowonmouseevent && self.showCursor(), 
                        void (self.rail.active = !0)) : !1;
                    }), self.jqbind(self.railh, "mouseleave", function() {
                        self.rail.active = !1, self.rail.drag || self.hideCursor();
                    }), self.opt.sensitiverail && (self.bind(self.railh, "click", function(e) {
                        self.doRailClick(e, !1, !0);
                    }), self.bind(self.railh, "dblclick", function(e) {
                        self.doRailClick(e, !0, !0);
                    }), self.bind(self.cursorh, "click", function(e) {
                        self.cancelEvent(e);
                    }), self.bind(self.cursorh, "dblclick", function(e) {
                        self.cancelEvent(e);
                    })))), cap.cantouch || self.opt.touchbehavior ? (self.bind(cap.hasmousecapture ? self.win : document, "mouseup", self.ontouchend), 
                    self.bind(document, "mousemove", self.ontouchmove), self.onclick && self.bind(document, "click", self.onclick), 
                    self.opt.cursordragontouch && (self.bind(self.cursor, "mousedown", self.onmousedown), 
                    self.bind(self.cursor, "mousemove", self.onmousemove), self.cursorh && self.bind(self.cursorh, "mousedown", function(e) {
                        self.onmousedown(e, !0);
                    }), self.cursorh && self.bind(self.cursorh, "mousemove", self.onmousemove))) : (self.bind(cap.hasmousecapture ? self.win : document, "mouseup", self.onmouseup), 
                    self.bind(document, "mousemove", self.onmousemove), self.onclick && self.bind(document, "click", self.onclick), 
                    !self.ispage && self.opt.enablescrollonselection && (self.bind(self.win[0], "mousedown", self.onselectionstart), 
                    self.bind(document, "mouseup", self.onselectionend), self.bind(self.cursor, "mouseup", self.onselectionend), 
                    self.cursorh && self.bind(self.cursorh, "mouseup", self.onselectionend), self.bind(document, "mousemove", self.onselectiondrag)), 
                    self.zoom && (self.jqbind(self.zoom, "mouseenter", function() {
                        self.canshowonmouseevent && self.showCursor(), self.rail.active = !0;
                    }), self.jqbind(self.zoom, "mouseleave", function() {
                        self.rail.active = !1, self.rail.drag || self.hideCursor();
                    }))), self.opt.enablemousewheel && (self.isiframe || self.bind(cap.isie && self.ispage ? document : self.win, "mousewheel", self.onmousewheel), 
                    self.bind(self.rail, "mousewheel", self.onmousewheel), self.railh && self.bind(self.railh, "mousewheel", self.onmousewheelhr)), 
                    self.ispage || cap.cantouch || /HTML|^BODY/.test(self.win[0].nodeName) || (self.win.attr("tabindex") || self.win.attr({
                        tabindex: tabindexcounter++
                    }), self.jqbind(self.win, "focus", function(e) {
                        domfocus = self.getTarget(e).id || !0, self.hasfocus = !0, self.canshowonmouseevent && self.noticeCursor();
                    }), self.jqbind(self.win, "blur", function(e) {
                        domfocus = !1, self.hasfocus = !1;
                    }), self.jqbind(self.win, "mouseenter", function(e) {
                        mousefocus = self.getTarget(e).id || !0, self.hasmousefocus = !0, self.canshowonmouseevent && self.noticeCursor();
                    }), self.jqbind(self.win, "mouseleave", function() {
                        mousefocus = !1, self.hasmousefocus = !1, self.rail.drag || self.hideCursor();
                    }));
                }
                if (// !ie9mobile
                //Thanks to http://www.quirksmode.org !!
                self.onkeypress = function(e) {
                    if (self.locked && 0 == self.page.maxh) return !0;
                    e = e ? e : window.e;
                    var tg = self.getTarget(e);
                    if (tg && /INPUT|TEXTAREA|SELECT|OPTION/.test(tg.nodeName)) {
                        var tp = tg.getAttribute("type") || tg.type || !1;
                        if (!tp || !/submit|button|cancel/i.tp) return !0;
                    }
                    if ($(tg).attr("contenteditable")) return !0;
                    if (self.hasfocus || self.hasmousefocus && !domfocus || self.ispage && !domfocus && !mousefocus) {
                        var key = e.keyCode;
                        if (self.locked && 27 != key) return self.cancelEvent(e);
                        var ctrl = e.ctrlKey || !1, shift = e.shiftKey || !1, ret = !1;
                        switch (key) {
                          case 38:
                          case 63233:
                            //safari
                            self.doScrollBy(72), ret = !0;
                            break;

                          case 40:
                          case 63235:
                            //safari
                            self.doScrollBy(-72), ret = !0;
                            break;

                          case 37:
                          case 63232:
                            //safari
                            self.railh && (ctrl ? self.doScrollLeft(0) : self.doScrollLeftBy(72), ret = !0);
                            break;

                          case 39:
                          case 63234:
                            //safari
                            self.railh && (ctrl ? self.doScrollLeft(self.page.maxw) : self.doScrollLeftBy(-72), 
                            ret = !0);
                            break;

                          case 33:
                          case 63276:
                            // safari
                            self.doScrollBy(self.view.h), ret = !0;
                            break;

                          case 34:
                          case 63277:
                            // safari
                            self.doScrollBy(-self.view.h), ret = !0;
                            break;

                          case 36:
                          case 63273:
                            self.railh && ctrl ? self.doScrollPos(0, 0) : self.doScrollTo(0), ret = !0;
                            break;

                          case 35:
                          case 63275:
                            self.railh && ctrl ? self.doScrollPos(self.page.maxw, self.page.maxh) : self.doScrollTo(self.page.maxh), 
                            ret = !0;
                            break;

                          case 32:
                            self.opt.spacebarenabled && (shift ? self.doScrollBy(self.view.h) : self.doScrollBy(-self.view.h), 
                            ret = !0);
                            break;

                          case 27:
                            // ESC
                            self.zoomactive && (self.doZoom(), ret = !0);
                        }
                        if (ret) return self.cancelEvent(e);
                    }
                }, self.opt.enablekeyboard && self.bind(document, cap.isopera && !cap.isopera12 ? "keypress" : "keydown", self.onkeypress), 
                self.bind(document, "keydown", function(e) {
                    var ctrl = e.ctrlKey || !1;
                    ctrl && (self.wheelprevented = !0);
                }), self.bind(document, "keyup", function(e) {
                    var ctrl = e.ctrlKey || !1;
                    ctrl || (self.wheelprevented = !1);
                }), self.bind(window, "resize", self.lazyResize), self.bind(window, "orientationchange", self.lazyResize), 
                self.bind(window, "load", self.lazyResize), cap.ischrome && !self.ispage && !self.haswrapper) {
                    //chrome void scrollbar bug - it persists in version 26
                    var tmp = self.win.attr("style"), ww = parseFloat(self.win.css("width")) + 1;
                    self.win.css("width", ww), self.synched("chromefix", function() {
                        self.win.attr("style", tmp);
                    });
                }
                // Trying a cross-browser implementation - good luck!
                self.onAttributeChange = function(e) {
                    self.lazyResize(250);
                }, self.ispage || self.haswrapper || (// redesigned MutationObserver for Chrome18+/Firefox14+/iOS6+ with support for: remove div, add/remove content
                clsMutationObserver !== !1 ? (self.observer = new clsMutationObserver(function(mutations) {
                    mutations.forEach(self.onAttributeChange);
                }), self.observer.observe(self.win[0], {
                    childList: !0,
                    characterData: !1,
                    attributes: !0,
                    subtree: !1
                }), self.observerremover = new clsMutationObserver(function(mutations) {
                    mutations.forEach(function(mo) {
                        if (mo.removedNodes.length > 0) for (var dd in mo.removedNodes) if (mo.removedNodes[dd] == self.win[0]) return self.remove();
                    });
                }), self.observerremover.observe(self.win[0].parentNode, {
                    childList: !0,
                    characterData: !1,
                    attributes: !1,
                    subtree: !1
                })) : (self.bind(self.win, cap.isie && !cap.isie9 ? "propertychange" : "DOMAttrModified", self.onAttributeChange), 
                cap.isie9 && self.win[0].attachEvent("onpropertychange", self.onAttributeChange), 
                //IE9 DOMAttrModified bug
                self.bind(self.win, "DOMNodeRemoved", function(e) {
                    e.target == self.win[0] && self.remove();
                }))), //
                !self.ispage && self.opt.boxzoom && self.bind(window, "resize", self.resizeZoom), 
                self.istextarea && self.bind(self.win, "mouseup", self.lazyResize), //        self.checkrtlmode = true;
                self.lazyResize(30);
            }
            "IFRAME" == this.doc[0].nodeName && (this.doc[0].readyState && "complete" == this.doc[0].readyState && setTimeout(function() {
                oniframeload.call(self.doc[0], !1);
            }, 500), self.bind(this.doc, "load", oniframeload));
        }, this.showCursor = function(py, px) {
            self.cursortimeout && (clearTimeout(self.cursortimeout), self.cursortimeout = 0), 
            self.rail && (self.autohidedom && (self.autohidedom.stop().css({
                opacity: self.opt.cursoropacitymax
            }), self.cursoractive = !0), self.rail.drag && 1 == self.rail.drag.pt || ("undefined" != typeof py && py !== !1 && (self.scroll.y = Math.round(1 * py / self.scrollratio.y)), 
            "undefined" != typeof px && (self.scroll.x = Math.round(1 * px / self.scrollratio.x))), 
            self.cursor.css({
                height: self.cursorheight,
                top: self.scroll.y
            }), self.cursorh && (!self.rail.align && self.rail.visibility ? self.cursorh.css({
                width: self.cursorwidth,
                left: self.scroll.x + self.rail.width
            }) : self.cursorh.css({
                width: self.cursorwidth,
                left: self.scroll.x
            }), self.cursoractive = !0), self.zoom && self.zoom.stop().css({
                opacity: self.opt.cursoropacitymax
            }));
        }, this.hideCursor = function(tm) {
            self.cursortimeout || self.rail && self.autohidedom && (self.hasmousefocus && "leave" == self.opt.autohidemode || (self.cursortimeout = setTimeout(function() {
                self.rail.active && self.showonmouseevent || (self.autohidedom.stop().animate({
                    opacity: self.opt.cursoropacitymin
                }), self.zoom && self.zoom.stop().animate({
                    opacity: self.opt.cursoropacitymin
                }), self.cursoractive = !1), self.cursortimeout = 0;
            }, tm || self.opt.hidecursordelay)));
        }, this.noticeCursor = function(tm, py, px) {
            self.showCursor(py, px), self.rail.active || self.hideCursor(tm);
        }, this.getContentSize = self.ispage ? function() {
            return {
                w: Math.max(document.body.scrollWidth, document.documentElement.scrollWidth),
                h: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
            };
        } : self.haswrapper ? function() {
            return {
                w: self.doc.outerWidth() + parseInt(self.win.css("paddingLeft")) + parseInt(self.win.css("paddingRight")),
                h: self.doc.outerHeight() + parseInt(self.win.css("paddingTop")) + parseInt(self.win.css("paddingBottom"))
            };
        } : function() {
            return {
                w: self.docscroll[0].scrollWidth,
                h: self.docscroll[0].scrollHeight
            };
        }, this.onResize = function(e, page) {
            if (!self || !self.win) return !1;
            if (!self.haswrapper && !self.ispage) {
                if ("none" == self.win.css("display")) return self.visibility && self.hideRail().hideRailHr(), 
                !1;
                self.hidden || self.visibility || self.showRail().showRailHr();
            }
            var premaxh = self.page.maxh, premaxw = self.page.maxw, preview = {
                h: self.view.h,
                w: self.view.w
            };
            if (self.view = {
                w: self.ispage ? self.win.width() : parseInt(self.win[0].clientWidth),
                h: self.ispage ? self.win.height() : parseInt(self.win[0].clientHeight)
            }, self.page = page ? page : self.getContentSize(), self.page.maxh = Math.max(0, self.page.h - self.view.h), 
            self.page.maxw = Math.max(0, self.page.w - self.view.w), self.page.maxh == premaxh && self.page.maxw == premaxw && self.view.w == preview.w) {
                // test position        
                if (self.ispage) return self;
                var pos = self.win.offset();
                if (self.lastposition) {
                    var lst = self.lastposition;
                    if (lst.top == pos.top && lst.left == pos.left) return self;
                }
                self.lastposition = pos;
            }
            if (0 == self.page.maxh ? (self.hideRail(), self.scrollvaluemax = 0, self.scroll.y = 0, 
            self.scrollratio.y = 0, self.cursorheight = 0, self.setScrollTop(0), self.rail.scrollable = !1) : self.rail.scrollable = !0, 
            0 == self.page.maxw ? (self.hideRailHr(), self.scrollvaluemaxw = 0, self.scroll.x = 0, 
            self.scrollratio.x = 0, self.cursorwidth = 0, self.setScrollLeft(0), self.railh.scrollable = !1) : self.railh.scrollable = !0, 
            self.locked = 0 == self.page.maxh && 0 == self.page.maxw, self.locked) return self.ispage || self.updateScrollBar(self.view), 
            !1;
            self.hidden || self.visibility ? self.hidden || self.railh.visibility || self.showRailHr() : self.showRail().showRailHr(), 
            self.istextarea && self.win.css("resize") && "none" != self.win.css("resize") && (self.view.h -= 20), 
            self.cursorheight = Math.min(self.view.h, Math.round(self.view.h * (self.view.h / self.page.h))), 
            self.cursorheight = self.opt.cursorfixedheight ? self.opt.cursorfixedheight : Math.max(self.opt.cursorminheight, self.cursorheight), 
            self.cursorwidth = Math.min(self.view.w, Math.round(self.view.w * (self.view.w / self.page.w))), 
            self.cursorwidth = self.opt.cursorfixedheight ? self.opt.cursorfixedheight : Math.max(self.opt.cursorminheight, self.cursorwidth), 
            self.scrollvaluemax = self.view.h - self.cursorheight - self.cursor.hborder, self.railh && (self.railh.width = self.page.maxh > 0 ? self.view.w - self.rail.width : self.view.w, 
            self.scrollvaluemaxw = self.railh.width - self.cursorwidth - self.cursorh.wborder), 
            /*
      if (self.checkrtlmode&&self.railh) {
        self.checkrtlmode = false;
        if (self.opt.rtlmode&&self.scroll.x==0) self.setScrollLeft(self.page.maxw);
      }
*/
            self.ispage || self.updateScrollBar(self.view), self.scrollratio = {
                x: self.page.maxw / self.scrollvaluemaxw,
                y: self.page.maxh / self.scrollvaluemax
            };
            var sy = self.getScrollTop();
            return sy > self.page.maxh ? self.doScrollTop(self.page.maxh) : (self.scroll.y = Math.round(self.getScrollTop() * (1 / self.scrollratio.y)), 
            self.scroll.x = Math.round(self.getScrollLeft() * (1 / self.scrollratio.x)), self.cursoractive && self.noticeCursor()), 
            self.scroll.y && 0 == self.getScrollTop() && self.doScrollTo(Math.floor(self.scroll.y * self.scrollratio.y)), 
            self;
        }, this.resize = self.onResize, this.lazyResize = function(tm) {
            // event debounce
            return tm = isNaN(tm) ? 30 : tm, self.delayed("resize", self.resize, tm), self;
        }, this._bind = function(el, name, fn, bubble) {
            // primitive bind
            self.events.push({
                e: el,
                n: name,
                f: fn,
                b: bubble,
                q: !1
            }), el.addEventListener ? el.addEventListener(name, fn, bubble || !1) : el.attachEvent ? el.attachEvent("on" + name, fn) : el["on" + name] = fn;
        }, this.jqbind = function(dom, name, fn) {
            // use jquery bind for non-native events (mouseenter/mouseleave)
            self.events.push({
                e: dom,
                n: name,
                f: fn,
                q: !0
            }), $(dom).bind(name, fn);
        }, this.bind = function(dom, name, fn, bubble) {
            // touch-oriented & fixing jquery bind
            var el = "jquery" in dom ? dom[0] : dom;
            if ("mousewheel" == name) if ("onwheel" in document || document.documentMode >= 9) self._bind(el, "wheel", fn, bubble || !1); else {
                var wname = "undefined" != typeof document.onmousewheel ? "mousewheel" : "DOMMouseScroll";
                // older IE/Firefox
                _modernWheelEvent(el, wname, fn, bubble || !1), "DOMMouseScroll" == wname && _modernWheelEvent(el, "MozMousePixelScroll", fn, bubble || !1);
            } else if (el.addEventListener) {
                if (cap.cantouch && /mouseup|mousedown|mousemove/.test(name)) {
                    // touch device support
                    var tt = "mousedown" == name ? "touchstart" : "mouseup" == name ? "touchend" : "touchmove";
                    self._bind(el, tt, function(e) {
                        if (e.touches) {
                            if (e.touches.length < 2) {
                                var ev = e.touches.length ? e.touches[0] : e;
                                ev.original = e, fn.call(this, ev);
                            }
                        } else if (e.changedTouches) {
                            var ev = e.changedTouches[0];
                            ev.original = e, fn.call(this, ev);
                        }
                    }, bubble || !1);
                }
                self._bind(el, name, fn, bubble || !1), cap.cantouch && "mouseup" == name && self._bind(el, "touchcancel", fn, bubble || !1);
            } else self._bind(el, name, function(e) {
                return e = e || window.event || !1, e && e.srcElement && (e.target = e.srcElement), 
                "pageY" in e || (e.pageX = e.clientX + document.documentElement.scrollLeft, e.pageY = e.clientY + document.documentElement.scrollTop), 
                fn.call(el, e) === !1 || bubble === !1 ? self.cancelEvent(e) : !0;
            });
        }, this._unbind = function(el, name, fn, bub) {
            // primitive unbind
            el.removeEventListener ? el.removeEventListener(name, fn, bub) : el.detachEvent ? el.detachEvent("on" + name, fn) : el["on" + name] = !1;
        }, this.unbindAll = function() {
            for (var a = 0; a < self.events.length; a++) {
                var r = self.events[a];
                r.q ? r.e.unbind(r.n, r.f) : self._unbind(r.e, r.n, r.f, r.b);
            }
        }, // Thanks to http://www.switchonthecode.com !!
        this.cancelEvent = function(e) {
            var e = e.original ? e.original : e ? e : window.event || !1;
            //IE10
            return e ? (e.preventDefault && e.preventDefault(), e.stopPropagation && e.stopPropagation(), 
            e.preventManipulation && e.preventManipulation(), e.cancelBubble = !0, e.cancel = !0, 
            e.returnValue = !1, !1) : !1;
        }, this.stopPropagation = function(e) {
            var e = e.original ? e.original : e ? e : window.event || !1;
            return e ? e.stopPropagation ? e.stopPropagation() : (e.cancelBubble && (e.cancelBubble = !0), 
            !1) : !1;
        }, this.showRail = function() {
            return 0 == self.page.maxh || !self.ispage && "none" == self.win.css("display") || (self.visibility = !0, 
            self.rail.visibility = !0, self.rail.css("display", "block")), self;
        }, this.showRailHr = function() {
            return self.railh ? (0 == self.page.maxw || !self.ispage && "none" == self.win.css("display") || (self.railh.visibility = !0, 
            self.railh.css("display", "block")), self) : self;
        }, this.hideRail = function() {
            return self.visibility = !1, self.rail.visibility = !1, self.rail.css("display", "none"), 
            self;
        }, this.hideRailHr = function() {
            return self.railh ? (self.railh.visibility = !1, self.railh.css("display", "none"), 
            self) : self;
        }, this.show = function() {
            return self.hidden = !1, self.locked = !1, self.showRail().showRailHr();
        }, this.hide = function() {
            return self.hidden = !0, self.locked = !0, self.hideRail().hideRailHr();
        }, this.toggle = function() {
            return self.hidden ? self.show() : self.hide();
        }, this.remove = function() {
            self.stop(), self.cursortimeout && clearTimeout(self.cursortimeout), self.doZoomOut(), 
            self.unbindAll(), cap.isie9 && self.win[0].detachEvent("onpropertychange", self.onAttributeChange), 
            //IE9 DOMAttrModified bug
            self.observer !== !1 && self.observer.disconnect(), self.observerremover !== !1 && self.observerremover.disconnect(), 
            self.events = null, self.cursor && self.cursor.remove(), self.cursorh && self.cursorh.remove(), 
            self.rail && self.rail.remove(), self.railh && self.railh.remove(), self.zoom && self.zoom.remove();
            for (var a = 0; a < self.saved.css.length; a++) {
                var d = self.saved.css[a];
                d[0].css(d[1], "undefined" == typeof d[2] ? "" : d[2]);
            }
            self.saved = !1, self.me.data("__nicescroll", "");
            //erase all traces
            // memory leak fixed by GianlucaGuarini - thanks a lot!
            // remove the current nicescroll from the $.nicescroll array & normalize array
            var lst = $.nicescroll;
            lst.each(function(i) {
                if (this && this.id === self.id) {
                    delete lst[i];
                    for (var b = ++i; b < lst.length; b++, i++) lst[i] = lst[b];
                    lst.length--, lst.length && delete lst[lst.length];
                }
            });
            for (var i in self) self[i] = null, delete self[i];
            self = null;
        }, this.scrollstart = function(fn) {
            return this.onscrollstart = fn, self;
        }, this.scrollend = function(fn) {
            return this.onscrollend = fn, self;
        }, this.scrollcancel = function(fn) {
            return this.onscrollcancel = fn, self;
        }, this.zoomin = function(fn) {
            return this.onzoomin = fn, self;
        }, this.zoomout = function(fn) {
            return this.onzoomout = fn, self;
        }, this.isScrollable = function(e) {
            var dom = e.target ? e.target : e;
            if ("OPTION" == dom.nodeName) return !0;
            for (;dom && 1 == dom.nodeType && !/^BODY|HTML/.test(dom.nodeName); ) {
                var dd = $(dom), ov = dd.css("overflowY") || dd.css("overflowX") || dd.css("overflow") || "";
                if (/scroll|auto/.test(ov)) return dom.clientHeight != dom.scrollHeight;
                dom = dom.parentNode ? dom.parentNode : !1;
            }
            return !1;
        }, this.getViewport = function(me) {
            for (var dom = me && me.parentNode ? me.parentNode : !1; dom && 1 == dom.nodeType && !/^BODY|HTML/.test(dom.nodeName); ) {
                var dd = $(dom);
                if (/fixed|absolute/.test(dd.css("position"))) return dd;
                var ov = dd.css("overflowY") || dd.css("overflowX") || dd.css("overflow") || "";
                if (/scroll|auto/.test(ov) && dom.clientHeight != dom.scrollHeight) return dd;
                if (dd.getNiceScroll().length > 0) return dd;
                dom = dom.parentNode ? dom.parentNode : !1;
            }
            return dom ? $(dom) : !1;
        }, this.triggerScrollEnd = function() {
            if (self.onscrollend) {
                var px = self.getScrollLeft(), py = self.getScrollTop(), info = {
                    type: "scrollend",
                    current: {
                        x: px,
                        y: py
                    },
                    end: {
                        x: px,
                        y: py
                    }
                };
                self.onscrollend.call(self, info);
            }
        }, this.onmousewheel = function(e) {
            if (!self.wheelprevented) {
                if (self.locked) return self.debounced("checkunlock", self.resize, 250), !0;
                if (self.rail.drag) return self.cancelEvent(e);
                // check two-axis mouse support (not very elegant)
                if ("auto" == self.opt.oneaxismousemode && 0 != e.deltaX && (self.opt.oneaxismousemode = !1), 
                self.opt.oneaxismousemode && 0 == e.deltaX && !self.rail.scrollable) return self.railh && self.railh.scrollable ? self.onmousewheelhr(e) : !0;
                var nw = +new Date(), chk = !1;
                if (self.opt.preservenativescrolling && self.checkarea + 600 < nw && (//        self.checkarea = false;
                self.nativescrollingarea = self.isScrollable(e), chk = !0), self.checkarea = nw, 
                self.nativescrollingarea) return !0;
                // this isn't my business
                //      if (self.locked) return self.cancelEvent(e);
                var ret = execScrollWheel(e, !1, chk);
                return ret && (self.checkarea = 0), ret;
            }
        }, this.onmousewheelhr = function(e) {
            if (!self.wheelprevented) {
                if (self.locked || !self.railh.scrollable) return !0;
                if (self.rail.drag) return self.cancelEvent(e);
                var nw = +new Date(), chk = !1;
                //        self.checkarea = false;
                // this isn't my business
                return self.opt.preservenativescrolling && self.checkarea + 600 < nw && (self.nativescrollingarea = self.isScrollable(e), 
                chk = !0), self.checkarea = nw, self.nativescrollingarea ? !0 : self.locked ? self.cancelEvent(e) : execScrollWheel(e, !0, chk);
            }
        }, this.stop = function() {
            return self.cancelScroll(), self.scrollmon && self.scrollmon.stop(), self.cursorfreezed = !1, 
            self.scroll.y = Math.round(self.getScrollTop() * (1 / self.scrollratio.y)), self.noticeCursor(), 
            self;
        }, this.getTransitionSpeed = function(dif) {
            var sp = Math.round(10 * self.opt.scrollspeed), ex = Math.min(sp, Math.round(dif / 20 * self.opt.scrollspeed));
            return ex > 20 ? ex : 0;
        }, self.opt.smoothscroll ? self.ishwscroll && cap.hastransition && self.opt.usetransition ? (this.prepareTransition = function(dif, istime) {
            var ex = istime ? dif > 20 ? dif : 0 : self.getTransitionSpeed(dif), trans = ex ? cap.prefixstyle + "transform " + ex + "ms ease-out" : "";
            return self.lasttransitionstyle && self.lasttransitionstyle == trans || (self.lasttransitionstyle = trans, 
            self.doc.css(cap.transitionstyle, trans)), ex;
        }, this.doScrollLeft = function(x, spd) {
            //trans
            var y = self.scrollrunning ? self.newscrolly : self.getScrollTop();
            self.doScrollPos(x, y, spd);
        }, this.doScrollTop = function(y, spd) {
            //trans
            var x = self.scrollrunning ? self.newscrollx : self.getScrollLeft();
            self.doScrollPos(x, y, spd);
        }, this.doScrollPos = function(x, y, spd) {
            //trans
            var py = self.getScrollTop(), px = self.getScrollLeft();
            //inverted movement detection      
            return ((self.newscrolly - py) * (y - py) < 0 || (self.newscrollx - px) * (x - px) < 0) && self.cancelScroll(), 
            0 == self.opt.bouncescroll && (0 > y ? y = 0 : y > self.page.maxh && (y = self.page.maxh), 
            0 > x ? x = 0 : x > self.page.maxw && (x = self.page.maxw)), self.scrollrunning && x == self.newscrollx && y == self.newscrolly ? !1 : (self.newscrolly = y, 
            self.newscrollx = x, self.newscrollspeed = spd || !1, self.timer ? !1 : void (self.timer = setTimeout(function() {
                var top = self.getScrollTop(), lft = self.getScrollLeft(), dst = {};
                dst.x = x - lft, dst.y = y - top, dst.px = lft, dst.py = top;
                var dd = Math.round(Math.sqrt(Math.pow(dst.x, 2) + Math.pow(dst.y, 2))), ms = self.newscrollspeed && self.newscrollspeed > 1 ? self.newscrollspeed : self.getTransitionSpeed(dd);
                if (self.newscrollspeed && self.newscrollspeed <= 1 && (ms *= self.newscrollspeed), 
                self.prepareTransition(ms, !0), self.timerscroll && self.timerscroll.tm && clearInterval(self.timerscroll.tm), 
                ms > 0) {
                    if (!self.scrollrunning && self.onscrollstart) {
                        var info = {
                            type: "scrollstart",
                            current: {
                                x: lft,
                                y: top
                            },
                            request: {
                                x: x,
                                y: y
                            },
                            end: {
                                x: self.newscrollx,
                                y: self.newscrolly
                            },
                            speed: ms
                        };
                        self.onscrollstart.call(self, info);
                    }
                    cap.transitionend ? self.scrollendtrapped || (self.scrollendtrapped = !0, self.bind(self.doc, cap.transitionend, self.onScrollTransitionEnd, !1)) : (self.scrollendtrapped && clearTimeout(self.scrollendtrapped), 
                    self.scrollendtrapped = setTimeout(self.onScrollTransitionEnd, ms));
                    var py = top, px = lft;
                    self.timerscroll = {
                        bz: new BezierClass(py, self.newscrolly, ms, 0, 0, .58, 1),
                        bh: new BezierClass(px, self.newscrollx, ms, 0, 0, .58, 1)
                    }, self.cursorfreezed || (self.timerscroll.tm = setInterval(function() {
                        self.showCursor(self.getScrollTop(), self.getScrollLeft());
                    }, 60));
                }
                self.synched("doScroll-set", function() {
                    self.timer = 0, self.scrollendtrapped && (self.scrollrunning = !0), self.setScrollTop(self.newscrolly), 
                    self.setScrollLeft(self.newscrollx), self.scrollendtrapped || self.onScrollTransitionEnd();
                });
            }, 50)));
        }, this.cancelScroll = function() {
            if (!self.scrollendtrapped) return !0;
            var py = self.getScrollTop(), px = self.getScrollLeft();
            // fire event onscroll
            //self.noticeCursor(false,py,px);
            return self.scrollrunning = !1, cap.transitionend || clearTimeout(cap.transitionend), 
            self.scrollendtrapped = !1, self._unbind(self.doc, cap.transitionend, self.onScrollTransitionEnd), 
            self.prepareTransition(0), self.setScrollTop(py), self.railh && self.setScrollLeft(px), 
            self.timerscroll && self.timerscroll.tm && clearInterval(self.timerscroll.tm), self.timerscroll = !1, 
            self.cursorfreezed = !1, self.showCursor(py, px), self;
        }, this.onScrollTransitionEnd = function() {
            self.scrollendtrapped && self._unbind(self.doc, cap.transitionend, self.onScrollTransitionEnd), 
            self.scrollendtrapped = !1, self.prepareTransition(0), self.timerscroll && self.timerscroll.tm && clearInterval(self.timerscroll.tm), 
            self.timerscroll = !1;
            var py = self.getScrollTop(), px = self.getScrollLeft();
            // fire event onscroll        
            // fire event onscroll left
            //          var info = {"type":"scrollend","current":{"x":px,"y":py},"end":{"x":self.newscrollx,"y":self.newscrolly}};
            //          self.onscrollend.call(self,info);
            return self.setScrollTop(py), self.railh && self.setScrollLeft(px), self.noticeCursor(!1, py, px), 
            self.cursorfreezed = !1, 0 > py ? py = 0 : py > self.page.maxh && (py = self.page.maxh), 
            0 > px ? px = 0 : px > self.page.maxw && (px = self.page.maxw), py != self.newscrolly || px != self.newscrollx ? self.doScrollPos(px, py, self.opt.snapbackspeed) : (self.onscrollend && self.scrollrunning && self.triggerScrollEnd(), 
            void (self.scrollrunning = !1));
        }) : (this.doScrollLeft = function(x, spd) {
            var y = self.scrollrunning ? self.newscrolly : self.getScrollTop();
            self.doScrollPos(x, y, spd);
        }, this.doScrollTop = function(y, spd) {
            var x = self.scrollrunning ? self.newscrollx : self.getScrollLeft();
            self.doScrollPos(x, y, spd);
        }, this.doScrollPos = function(x, y, spd) {
            function scrolling() {
                if (self.cancelAnimationFrame) return !0;
                if (self.scrollrunning = !0, sync = 1 - sync) return self.timer = setAnimationFrame(scrolling) || 1;
                var done = 0, sc = sy = self.getScrollTop();
                if (self.dst.ay) {
                    sc = self.bzscroll ? self.dst.py + self.bzscroll.getNow() * self.dst.ay : self.newscrolly;
                    var dr = sc - sy;
                    (0 > dr && sc < self.newscrolly || dr > 0 && sc > self.newscrolly) && (sc = self.newscrolly), 
                    self.setScrollTop(sc), sc == self.newscrolly && (done = 1);
                } else done = 1;
                var scx = sx = self.getScrollLeft();
                if (self.dst.ax) {
                    scx = self.bzscroll ? self.dst.px + self.bzscroll.getNow() * self.dst.ax : self.newscrollx;
                    var dr = scx - sx;
                    (0 > dr && scx < self.newscrollx || dr > 0 && scx > self.newscrollx) && (scx = self.newscrollx), 
                    self.setScrollLeft(scx), scx == self.newscrollx && (done += 1);
                } else done += 1;
                2 == done ? (self.timer = 0, self.cursorfreezed = !1, self.bzscroll = !1, self.scrollrunning = !1, 
                0 > sc ? sc = 0 : sc > self.page.maxh && (sc = self.page.maxh), 0 > scx ? scx = 0 : scx > self.page.maxw && (scx = self.page.maxw), 
                scx != self.newscrollx || sc != self.newscrolly ? self.doScrollPos(scx, sc) : self.onscrollend && self.triggerScrollEnd()) : self.timer = setAnimationFrame(scrolling) || 1;
            }
            var y = "undefined" == typeof y || y === !1 ? self.getScrollTop(!0) : y;
            if (self.timer && self.newscrolly == y && self.newscrollx == x) return !0;
            self.timer && clearAnimationFrame(self.timer), self.timer = 0;
            var py = self.getScrollTop(), px = self.getScrollLeft();
            ((self.newscrolly - py) * (y - py) < 0 || (self.newscrollx - px) * (x - px) < 0) && self.cancelScroll(), 
            self.newscrolly = y, self.newscrollx = x, self.bouncescroll && self.rail.visibility || (self.newscrolly < 0 ? self.newscrolly = 0 : self.newscrolly > self.page.maxh && (self.newscrolly = self.page.maxh)), 
            self.bouncescroll && self.railh.visibility || (self.newscrollx < 0 ? self.newscrollx = 0 : self.newscrollx > self.page.maxw && (self.newscrollx = self.page.maxw)), 
            self.dst = {}, self.dst.x = x - px, self.dst.y = y - py, self.dst.px = px, self.dst.py = py;
            var dst = Math.round(Math.sqrt(Math.pow(self.dst.x, 2) + Math.pow(self.dst.y, 2)));
            self.dst.ax = self.dst.x / dst, self.dst.ay = self.dst.y / dst;
            var pa = 0, pe = dst;
            0 == self.dst.x ? (pa = py, pe = y, self.dst.ay = 1, self.dst.py = 0) : 0 == self.dst.y && (pa = px, 
            pe = x, self.dst.ax = 1, self.dst.px = 0);
            var ms = self.getTransitionSpeed(dst);
            if (spd && 1 >= spd && (ms *= spd), ms > 0 ? self.bzscroll = self.bzscroll ? self.bzscroll.update(pe, ms) : new BezierClass(pa, pe, ms, 0, 1, 0, 1) : self.bzscroll = !1, 
            !self.timer) {
                (py == self.page.maxh && y >= self.page.maxh || px == self.page.maxw && x >= self.page.maxw) && self.checkContentSize();
                var sync = 1;
                if (self.cancelAnimationFrame = !1, self.timer = 1, self.onscrollstart && !self.scrollrunning) {
                    var info = {
                        type: "scrollstart",
                        current: {
                            x: px,
                            y: py
                        },
                        request: {
                            x: x,
                            y: y
                        },
                        end: {
                            x: self.newscrollx,
                            y: self.newscrolly
                        },
                        speed: ms
                    };
                    self.onscrollstart.call(self, info);
                }
                scrolling(), (py == self.page.maxh && y >= py || px == self.page.maxw && x >= px) && self.checkContentSize(), 
                self.noticeCursor();
            }
        }, this.cancelScroll = function() {
            return self.timer && clearAnimationFrame(self.timer), self.timer = 0, self.bzscroll = !1, 
            self.scrollrunning = !1, self;
        }) : (this.doScrollLeft = function(x, spd) {
            var y = self.getScrollTop();
            self.doScrollPos(x, y, spd);
        }, this.doScrollTop = function(y, spd) {
            var x = self.getScrollLeft();
            self.doScrollPos(x, y, spd);
        }, this.doScrollPos = function(x, y, spd) {
            var nx = x > self.page.maxw ? self.page.maxw : x;
            0 > nx && (nx = 0);
            var ny = y > self.page.maxh ? self.page.maxh : y;
            0 > ny && (ny = 0), self.synched("scroll", function() {
                self.setScrollTop(ny), self.setScrollLeft(nx);
            });
        }, this.cancelScroll = function() {}), this.doScrollBy = function(stp, relative) {
            var ny = 0;
            if (relative) ny = Math.floor((self.scroll.y - stp) * self.scrollratio.y); else {
                var sy = self.timer ? self.newscrolly : self.getScrollTop(!0);
                ny = sy - stp;
            }
            if (self.bouncescroll) {
                var haf = Math.round(self.view.h / 2);
                -haf > ny ? ny = -haf : ny > self.page.maxh + haf && (ny = self.page.maxh + haf);
            }
            return self.cursorfreezed = !1, py = self.getScrollTop(!0), 0 > ny && py <= 0 ? self.noticeCursor() : ny > self.page.maxh && py >= self.page.maxh ? (self.checkContentSize(), 
            self.noticeCursor()) : void self.doScrollTop(ny);
        }, this.doScrollLeftBy = function(stp, relative) {
            var nx = 0;
            if (relative) nx = Math.floor((self.scroll.x - stp) * self.scrollratio.x); else {
                var sx = self.timer ? self.newscrollx : self.getScrollLeft(!0);
                nx = sx - stp;
            }
            if (self.bouncescroll) {
                var haf = Math.round(self.view.w / 2);
                -haf > nx ? nx = -haf : nx > self.page.maxw + haf && (nx = self.page.maxw + haf);
            }
            return self.cursorfreezed = !1, px = self.getScrollLeft(!0), 0 > nx && px <= 0 ? self.noticeCursor() : nx > self.page.maxw && px >= self.page.maxw ? self.noticeCursor() : void self.doScrollLeft(nx);
        }, this.doScrollTo = function(pos, relative) {
            var ny = relative ? Math.round(pos * self.scrollratio.y) : pos;
            0 > ny ? ny = 0 : ny > self.page.maxh && (ny = self.page.maxh), self.cursorfreezed = !1, 
            self.doScrollTop(pos);
        }, this.checkContentSize = function() {
            var pg = self.getContentSize();
            (pg.h != self.page.h || pg.w != self.page.w) && self.resize(!1, pg);
        }, self.onscroll = function(e) {
            self.rail.drag || self.cursorfreezed || self.synched("scroll", function() {
                self.scroll.y = Math.round(self.getScrollTop() * (1 / self.scrollratio.y)), self.railh && (self.scroll.x = Math.round(self.getScrollLeft() * (1 / self.scrollratio.x))), 
                self.noticeCursor();
            });
        }, self.bind(self.docscroll, "scroll", self.onscroll), this.doZoomIn = function(e) {
            if (!self.zoomactive) {
                self.zoomactive = !0, self.zoomrestore = {
                    style: {}
                };
                var lst = [ "position", "top", "left", "zIndex", "backgroundColor", "marginTop", "marginBottom", "marginLeft", "marginRight" ], win = self.win[0].style;
                for (var a in lst) {
                    var pp = lst[a];
                    self.zoomrestore.style[pp] = "undefined" != typeof win[pp] ? win[pp] : "";
                }
                self.zoomrestore.style.width = self.win.css("width"), self.zoomrestore.style.height = self.win.css("height"), 
                self.zoomrestore.padding = {
                    w: self.win.outerWidth() - self.win.width(),
                    h: self.win.outerHeight() - self.win.height()
                }, cap.isios4 && (self.zoomrestore.scrollTop = $(window).scrollTop(), $(window).scrollTop(0)), 
                self.win.css({
                    position: cap.isios4 ? "absolute" : "fixed",
                    top: 0,
                    left: 0,
                    "z-index": globalmaxzindex + 100,
                    margin: "0px"
                });
                var bkg = self.win.css("backgroundColor");
                return ("" == bkg || /transparent|rgba\(0, 0, 0, 0\)|rgba\(0,0,0,0\)/.test(bkg)) && self.win.css("backgroundColor", "#fff"), 
                self.rail.css({
                    "z-index": globalmaxzindex + 101
                }), self.zoom.css({
                    "z-index": globalmaxzindex + 102
                }), self.zoom.css("backgroundPosition", "0px -18px"), self.resizeZoom(), self.onzoomin && self.onzoomin.call(self), 
                self.cancelEvent(e);
            }
        }, this.doZoomOut = function(e) {
            return self.zoomactive ? (self.zoomactive = !1, self.win.css("margin", ""), self.win.css(self.zoomrestore.style), 
            cap.isios4 && $(window).scrollTop(self.zoomrestore.scrollTop), self.rail.css({
                "z-index": self.zindex
            }), self.zoom.css({
                "z-index": self.zindex
            }), self.zoomrestore = !1, self.zoom.css("backgroundPosition", "0px 0px"), self.onResize(), 
            self.onzoomout && self.onzoomout.call(self), self.cancelEvent(e)) : void 0;
        }, this.doZoom = function(e) {
            return self.zoomactive ? self.doZoomOut(e) : self.doZoomIn(e);
        }, this.resizeZoom = function() {
            if (self.zoomactive) {
                var py = self.getScrollTop();
                //preserve scrolling position
                self.win.css({
                    width: $(window).width() - self.zoomrestore.padding.w + "px",
                    height: $(window).height() - self.zoomrestore.padding.h + "px"
                }), self.onResize(), self.setScrollTop(Math.min(self.page.maxh, py));
            }
        }, this.init(), $.nicescroll.push(this);
    }, ScrollMomentumClass2D = function(nc) {
        var self = this;
        this.nc = nc, this.lastx = 0, this.lasty = 0, this.speedx = 0, this.speedy = 0, 
        this.lasttime = 0, this.steptime = 0, this.snapx = !1, this.snapy = !1, this.demulx = 0, 
        this.demuly = 0, this.lastscrollx = -1, this.lastscrolly = -1, this.chkx = 0, this.chky = 0, 
        this.timer = 0, this.time = function() {
            return +new Date();
        }, this.reset = function(px, py) {
            self.stop();
            var now = self.time();
            self.steptime = 0, self.lasttime = now, self.speedx = 0, self.speedy = 0, self.lastx = px, 
            self.lasty = py, self.lastscrollx = -1, self.lastscrolly = -1;
        }, this.update = function(px, py) {
            var now = self.time();
            self.steptime = now - self.lasttime, self.lasttime = now;
            var dy = py - self.lasty, dx = px - self.lastx, sy = self.nc.getScrollTop(), sx = self.nc.getScrollLeft(), newy = sy + dy, newx = sx + dx;
            self.snapx = 0 > newx || newx > self.nc.page.maxw, self.snapy = 0 > newy || newy > self.nc.page.maxh, 
            self.speedx = dx, self.speedy = dy, self.lastx = px, self.lasty = py;
        }, this.stop = function() {
            self.nc.unsynched("domomentum2d"), self.timer && clearTimeout(self.timer), self.timer = 0, 
            self.lastscrollx = -1, self.lastscrolly = -1;
        }, this.doSnapy = function(nx, ny) {
            var snap = !1;
            0 > ny ? (ny = 0, snap = !0) : ny > self.nc.page.maxh && (ny = self.nc.page.maxh, 
            snap = !0), 0 > nx ? (nx = 0, snap = !0) : nx > self.nc.page.maxw && (nx = self.nc.page.maxw, 
            snap = !0), snap ? self.nc.doScrollPos(nx, ny, self.nc.opt.snapbackspeed) : self.nc.triggerScrollEnd();
        }, this.doMomentum = function(gp) {
            var t = self.time(), l = gp ? t + gp : self.lasttime, sl = self.nc.getScrollLeft(), st = self.nc.getScrollTop(), pageh = self.nc.page.maxh, pagew = self.nc.page.maxw;
            self.speedx = pagew > 0 ? Math.min(60, self.speedx) : 0, self.speedy = pageh > 0 ? Math.min(60, self.speedy) : 0;
            var chk = l && 60 >= t - l;
            (0 > st || st > pageh || 0 > sl || sl > pagew) && (chk = !1);
            var sy = self.speedy && chk ? self.speedy : !1, sx = self.speedx && chk ? self.speedx : !1;
            if (sy || sx) {
                var tm = Math.max(16, self.steptime);
                //timeout granularity
                if (tm > 50) {
                    // do smooth
                    var xm = tm / 50;
                    self.speedx *= xm, self.speedy *= xm, tm = 50;
                }
                self.demulxy = 0, self.lastscrollx = self.nc.getScrollLeft(), self.chkx = self.lastscrollx, 
                self.lastscrolly = self.nc.getScrollTop(), self.chky = self.lastscrolly;
                var nx = self.lastscrollx, ny = self.lastscrolly, onscroll = function() {
                    var df = self.time() - t > 600 ? .04 : .02;
                    self.speedx && (nx = Math.floor(self.lastscrollx - self.speedx * (1 - self.demulxy)), 
                    self.lastscrollx = nx, (0 > nx || nx > pagew) && (df = .1)), self.speedy && (ny = Math.floor(self.lastscrolly - self.speedy * (1 - self.demulxy)), 
                    self.lastscrolly = ny, (0 > ny || ny > pageh) && (df = .1)), self.demulxy = Math.min(1, self.demulxy + df), 
                    self.nc.synched("domomentum2d", function() {
                        if (self.speedx) {
                            var scx = self.nc.getScrollLeft();
                            scx != self.chkx && self.stop(), self.chkx = nx, self.nc.setScrollLeft(nx);
                        }
                        if (self.speedy) {
                            var scy = self.nc.getScrollTop();
                            scy != self.chky && self.stop(), self.chky = ny, self.nc.setScrollTop(ny);
                        }
                        self.timer || (self.nc.hideCursor(), self.doSnapy(nx, ny));
                    }), self.demulxy < 1 ? self.timer = setTimeout(onscroll, tm) : (self.stop(), self.nc.hideCursor(), 
                    self.doSnapy(nx, ny));
                };
                onscroll();
            } else self.doSnapy(self.nc.getScrollLeft(), self.nc.getScrollTop());
        };
    }, _scrollTop = jQuery.fn.scrollTop;
    // preserve original function
    jQuery.cssHooks.pageYOffset = {
        get: function(elem, computed, extra) {
            var nice = $.data(elem, "__nicescroll") || !1;
            return nice && nice.ishwscroll ? nice.getScrollTop() : _scrollTop.call(elem);
        },
        set: function(elem, value) {
            var nice = $.data(elem, "__nicescroll") || !1;
            return nice && nice.ishwscroll ? nice.setScrollTop(parseInt(value)) : _scrollTop.call(elem, value), 
            this;
        }
    }, /*  
  $.fx.step["scrollTop"] = function(fx){    
    $.cssHooks["scrollTop"].set( fx.elem, fx.now + fx.unit );
  };
*/
    jQuery.fn.scrollTop = function(value) {
        if ("undefined" == typeof value) {
            var nice = this[0] ? $.data(this[0], "__nicescroll") || !1 : !1;
            return nice && nice.ishwscroll ? nice.getScrollTop() : _scrollTop.call(this);
        }
        return this.each(function() {
            var nice = $.data(this, "__nicescroll") || !1;
            nice && nice.ishwscroll ? nice.setScrollTop(parseInt(value)) : _scrollTop.call($(this), value);
        });
    };
    // override jQuery scrollLeft
    var _scrollLeft = jQuery.fn.scrollLeft;
    // preserve original function
    $.cssHooks.pageXOffset = {
        get: function(elem, computed, extra) {
            var nice = $.data(elem, "__nicescroll") || !1;
            return nice && nice.ishwscroll ? nice.getScrollLeft() : _scrollLeft.call(elem);
        },
        set: function(elem, value) {
            var nice = $.data(elem, "__nicescroll") || !1;
            return nice && nice.ishwscroll ? nice.setScrollLeft(parseInt(value)) : _scrollLeft.call(elem, value), 
            this;
        }
    }, /*  
  $.fx.step["scrollLeft"] = function(fx){
    $.cssHooks["scrollLeft"].set( fx.elem, fx.now + fx.unit );
  };  
*/
    jQuery.fn.scrollLeft = function(value) {
        if ("undefined" == typeof value) {
            var nice = this[0] ? $.data(this[0], "__nicescroll") || !1 : !1;
            return nice && nice.ishwscroll ? nice.getScrollLeft() : _scrollLeft.call(this);
        }
        return this.each(function() {
            var nice = $.data(this, "__nicescroll") || !1;
            nice && nice.ishwscroll ? nice.setScrollLeft(parseInt(value)) : _scrollLeft.call($(this), value);
        });
    };
    var NiceScrollArray = function(doms) {
        var self = this;
        if (this.length = 0, this.name = "nicescrollarray", this.each = function(fn) {
            for (var a = 0, i = 0; a < self.length; a++) fn.call(self[a], i++);
            return self;
        }, this.push = function(nice) {
            self[self.length] = nice, self.length++;
        }, this.eq = function(idx) {
            return self[idx];
        }, doms) for (var a = 0; a < doms.length; a++) {
            var nice = $.data(doms[a], "__nicescroll") || !1;
            nice && (this[this.length] = nice, this.length++);
        }
        return this;
    };
    mplex(NiceScrollArray.prototype, [ "show", "hide", "toggle", "onResize", "resize", "remove", "stop", "doScrollPos" ], function(e, n) {
        e[n] = function() {
            var args = arguments;
            return this.each(function() {
                this[n].apply(this, args);
            });
        };
    }), jQuery.fn.getNiceScroll = function(index) {
        if ("undefined" == typeof index) return new NiceScrollArray(this);
        var nice = this[index] && $.data(this[index], "__nicescroll") || !1;
        return nice;
    }, jQuery.extend(jQuery.expr[":"], {
        nicescroll: function(a) {
            return $.data(a, "__nicescroll") ? !0 : !1;
        }
    }), $.fn.niceScroll = function(wrapper, opt) {
        "undefined" == typeof opt && ("object" != typeof wrapper || "jquery" in wrapper || (opt = wrapper, 
        wrapper = !1));
        var ret = new NiceScrollArray();
        "undefined" == typeof opt && (opt = {}), wrapper && (opt.doc = $(wrapper), opt.win = $(this));
        var docundef = !("doc" in opt);
        return docundef || "win" in opt || (opt.win = $(this)), this.each(function() {
            var nice = $(this).data("__nicescroll") || !1;
            nice || (opt.doc = docundef ? $(this) : opt.doc, nice = new NiceScrollClass(opt, $(this)), 
            $(this).data("__nicescroll", nice)), ret.push(nice);
        }), 1 == ret.length ? ret[0] : ret;
    }, window.NiceScroll = {
        getjQuery: function() {
            return jQuery;
        }
    }, $.nicescroll || ($.nicescroll = new NiceScrollArray(), $.nicescroll.options = _globaloptions);
}), /**
 * @author zhixin wen <wenzhixin2010@gmail.com>
 * @version 1.1.0
 * 
 * http://wenzhixin.net.cn/p/multiple-select/
 */
function($) {
    "use strict";
    function MultipleSelect($el, options) {
        var that = this, name = $el.attr("name") || options.name || "", elWidth = $el.width();
        this.$el = $el.hide(), this.options = options, this.$parent = $('<div class="ms-parent"></div>'), 
        this.$choice = $('<button type="button" class="ms-choice"><span class="placeholder">' + options.placeholder + "</span><div></div></button>"), 
        this.$drop = $('<div class="ms-drop ' + options.position + '"></div>'), this.$el.after(this.$parent), 
        this.$parent.append(this.$choice), this.$parent.append(this.$drop), this.$el.prop("disabled") && this.$choice.addClass("disabled"), 
        this.$choice.css("width", elWidth + "px"), this.$drop.css({
            width: (options.width || elWidth) + "px"
        }), this.options.keepOpen || $("body").click(function(e) {
            $(e.target)[0] !== that.$choice[0] && $(e.target).parents(".ms-choice")[0] !== that.$choice[0] && ($(e.target)[0] !== that.$drop[0] && $(e.target).parents(".ms-drop")[0] === that.$drop[0] || !that.options.isOpen || that.close());
        }), this.selectAllName = 'name="selectAll' + name + '"', this.selectGroupName = 'name="selectGroup' + name + '"', 
        this.selectItemName = 'name="selectItem' + name + '"';
    }
    MultipleSelect.prototype = {
        constructor: MultipleSelect,
        init: function() {
            var that = this, html = [];
            this.options.filter && html.push('<div class="ms-search">', '<input type="text" autocomplete="off" autocorrect="off" autocapitilize="off" spellcheck="false">', "</div>"), 
            html.push("<ul>"), this.options.selectAll && !this.options.single && html.push("<li>", "<label>", '<input type="checkbox" ' + this.selectAllName + " /> ", "[" + this.options.selectAllText + "]", "</label>", "</li>"), 
            $.each(this.$el.children(), function(i, elm) {
                html.push(that.optionToHtml(i, elm));
            }), html.push('<li class="ms-no-results">No matches found</li>'), html.push("</ul>"), 
            this.$drop.html(html.join("")), this.$drop.find("ul").css("max-height", this.options.maxHeight + "px"), 
            this.$drop.find(".multiple").css("width", this.options.multipleWidth + "px"), this.$searchInput = this.$drop.find(".ms-search input"), 
            this.$selectAll = this.$drop.find("input[" + this.selectAllName + "]"), this.$selectGroups = this.$drop.find("input[" + this.selectGroupName + "]"), 
            this.$selectItems = this.$drop.find("input[" + this.selectItemName + "]:enabled"), 
            this.$disableItems = this.$drop.find("input[" + this.selectItemName + "]:disabled"), 
            this.$noResults = this.$drop.find(".ms-no-results"), this.events(), this.update(), 
            this.options.isOpen && this.open();
        },
        optionToHtml: function(i, elm, group, groupDisabled) {
            var disabled, that = this, $elm = $(elm), html = [], multiple = this.options.multiple, type = this.options.single ? "radio" : "checkbox";
            if ($elm.is("option")) {
                var value = $elm.val(), text = $elm.text(), selected = $elm.prop("selected"), style = this.options.styler(value) ? ' style="' + this.options.styler(value) + '"' : "";
                disabled = groupDisabled || $elm.prop("disabled"), html.push("<li" + (multiple ? ' class="multiple"' : "") + style + ">", "<label" + (disabled ? ' class="disabled"' : "") + ">", '<input type="' + type + '" ' + this.selectItemName + ' value="' + value + '"' + (selected ? ' checked="checked"' : "") + (disabled ? ' disabled="disabled"' : "") + (group ? ' data-group="' + group + '"' : "") + "/> ", text, "</label>", "</li>");
            } else if (!group && $elm.is("optgroup")) {
                var _group = "group_" + i, label = $elm.attr("label");
                disabled = $elm.prop("disabled"), html.push('<li class="group">', '<label class="optgroup' + (disabled ? " disabled" : "") + '" data-group="' + _group + '">', '<input type="checkbox" ' + this.selectGroupName + (disabled ? ' disabled="disabled"' : "") + " /> ", label, "</label>", "</li>"), 
                $.each($elm.children(), function(i, elm) {
                    html.push(that.optionToHtml(i, elm, _group, disabled));
                });
            }
            return html.join("");
        },
        events: function() {
            var that = this;
            this.$choice.off("click").on("click", function(e) {
                e.preventDefault(), that[that.options.isOpen ? "close" : "open"]();
            }).off("focus").on("focus", this.options.onFocus).off("blur").on("blur", this.options.onBlur), 
            this.$parent.off("keydown").on("keydown", function(e) {
                switch (e.which) {
                  case 27:
                    // esc key
                    that.close(), that.$choice.focus();
                }
            }), this.$searchInput.off("keyup").on("keyup", function() {
                that.filter();
            }), this.$selectAll.off("click").on("click", function() {
                var checked = $(this).prop("checked"), $items = that.$selectItems.filter(":visible");
                $items.length === that.$selectItems.length ? that[checked ? "checkAll" : "uncheckAll"]() : (// when the filter option is true
                that.$selectGroups.prop("checked", checked), $items.prop("checked", checked), that.options[checked ? "onCheckAll" : "onUncheckAll"](), 
                that.update());
            }), this.$selectGroups.off("click").on("click", function() {
                var group = $(this).parent().attr("data-group"), $items = that.$selectItems.filter(":visible"), $children = $items.filter('[data-group="' + group + '"]'), checked = $children.length !== $children.filter(":checked").length;
                $children.prop("checked", checked), that.updateSelectAll(), that.update(), that.options.onOptgroupClick({
                    label: $(this).parent().text(),
                    checked: checked,
                    children: $children.get()
                });
            }), this.$selectItems.off("click").on("click", function() {
                that.updateSelectAll(), that.update(), that.updateOptGroupSelect(), that.options.onClick({
                    label: $(this).parent().text(),
                    value: $(this).val(),
                    checked: $(this).prop("checked")
                });
            });
        },
        open: function() {
            if (!this.$choice.hasClass("disabled")) {
                if (this.options.isOpen = !0, this.$choice.find(">div").addClass("open"), this.$drop.show(), 
                this.options.container) {
                    var offset = this.$drop.offset();
                    this.$drop.appendTo($(this.options.container)), this.$drop.offset({
                        top: offset.top,
                        left: offset.left
                    });
                }
                this.options.filter && (this.$searchInput.val(""), this.filter()), this.options.onOpen();
            }
        },
        close: function() {
            this.options.isOpen = !1, this.$choice.find(">div").removeClass("open"), this.$drop.hide(), 
            this.options.container && (this.$parent.append(this.$drop), this.$drop.css({
                top: "auto",
                left: "auto"
            })), this.options.onClose();
        },
        update: function() {
            var selects = this.getSelects("text"), $span = this.$choice.find(">span");
            selects.length === this.$selectItems.length + this.$disableItems.length && this.options.allSelected ? $span.removeClass("placeholder").html(this.options.allSelected) : selects.length > this.options.minumimCountSelected && this.options.countSelected ? $span.removeClass("placeholder").html(this.options.countSelected.replace("#", selects.length).replace("%", this.$selectItems.length + this.$disableItems.length)) : selects.length ? $span.removeClass("placeholder").html(selects.join(", ")) : $span.addClass("placeholder").html(this.options.placeholder), 
            // set selects to select
            this.$el.val(this.getSelects());
        },
        updateSelectAll: function() {
            var $items = this.$selectItems.filter(":visible");
            this.$selectAll.prop("checked", $items.length && $items.length === $items.filter(":checked").length), 
            this.$selectAll.prop("checked") && this.options.onCheckAll();
        },
        updateOptGroupSelect: function() {
            var $items = this.$selectItems.filter(":visible");
            $.each(this.$selectGroups, function(i, val) {
                var group = $(val).parent().attr("data-group"), $children = $items.filter('[data-group="' + group + '"]');
                $(val).prop("checked", $children.length && $children.length === $children.filter(":checked").length);
            });
        },
        //value or text, default: 'value'
        getSelects: function(type) {
            var that = this, texts = [], values = [];
            return this.$drop.find("input[" + this.selectItemName + "]:checked").each(function() {
                texts.push($(this).parent().text()), values.push($(this).val());
            }), "text" === type && this.$selectGroups.length && (texts = [], this.$selectGroups.each(function() {
                var html = [], text = $.trim($(this).parent().text()), group = $(this).parent().data("group"), $children = that.$drop.find("[" + that.selectItemName + '][data-group="' + group + '"]'), $selected = $children.filter(":checked");
                if (0 !== $selected.length) {
                    if (html.push("["), html.push(text), $children.length > $selected.length) {
                        var list = [];
                        $selected.each(function() {
                            list.push($(this).parent().text());
                        }), html.push(": " + list.join(", "));
                    }
                    html.push("]"), texts.push(html.join(""));
                }
            })), "text" === type ? texts : values;
        },
        setSelects: function(values) {
            var that = this;
            this.$selectItems.prop("checked", !1), $.each(values, function(i, value) {
                that.$selectItems.filter('[value="' + value + '"]').prop("checked", !0);
            }), this.$selectAll.prop("checked", this.$selectItems.length === this.$selectItems.filter(":checked").length), 
            this.update();
        },
        enable: function() {
            this.$choice.removeClass("disabled");
        },
        disable: function() {
            this.$choice.addClass("disabled");
        },
        checkAll: function() {
            this.$selectItems.prop("checked", !0), this.$selectGroups.prop("checked", !0), this.$selectAll.prop("checked", !0), 
            this.update(), this.options.onCheckAll();
        },
        uncheckAll: function() {
            this.$selectItems.prop("checked", !1), this.$selectGroups.prop("checked", !1), this.$selectAll.prop("checked", !1), 
            this.update(), this.options.onUncheckAll();
        },
        focus: function() {
            this.$choice.focus(), this.options.onFocus();
        },
        blur: function() {
            this.$choice.blur(), this.options.onBlur();
        },
        refresh: function() {
            this.init();
        },
        filter: function() {
            var that = this, text = $.trim(this.$searchInput.val()).toLowerCase();
            0 === text.length ? (this.$selectItems.parent().show(), this.$disableItems.parent().show(), 
            this.$selectGroups.parent().show()) : (this.$selectItems.each(function() {
                var $parent = $(this).parent();
                $parent[$parent.text().toLowerCase().indexOf(text) < 0 ? "hide" : "show"]();
            }), this.$disableItems.parent().hide(), this.$selectGroups.each(function() {
                var $parent = $(this).parent(), group = $parent.attr("data-group"), $items = that.$selectItems.filter(":visible");
                $parent[0 === $items.filter('[data-group="' + group + '"]').length ? "hide" : "show"]();
            }), //Check if no matches found
            this.$selectItems.filter(":visible").length ? (this.$selectAll.parent().show(), 
            this.$noResults.hide()) : (this.$selectAll.parent().hide(), this.$noResults.show())), 
            this.updateOptGroupSelect(), this.updateSelectAll();
        }
    }, $.fn.multipleSelect = function() {
        var value, option = arguments[0], args = arguments, allowedMethods = [ "getSelects", "setSelects", "enable", "disable", "checkAll", "uncheckAll", "focus", "blur", "refresh" ];
        return this.each(function() {
            var $this = $(this), data = $this.data("multipleSelect"), options = $.extend({}, $.fn.multipleSelect.defaults, $this.data(), "object" == typeof option && option);
            if (data || (data = new MultipleSelect($this, options), $this.data("multipleSelect", data)), 
            "string" == typeof option) {
                if ($.inArray(option, allowedMethods) < 0) throw "Unknown method: " + option;
                value = data[option](args[1]);
            } else data.init();
        }), value ? value : this;
    }, $.fn.multipleSelect.defaults = {
        name: "",
        isOpen: !1,
        placeholder: "",
        selectAll: !0,
        selectAllText: "Select all",
        allSelected: "All selected",
        minumimCountSelected: 3,
        countSelected: "# of % selected",
        multiple: !1,
        multipleWidth: 80,
        single: !1,
        filter: !1,
        width: void 0,
        maxHeight: 250,
        container: null,
        position: "bottom",
        keepOpen: !1,
        styler: function() {
            return !1;
        },
        onOpen: function() {
            return !1;
        },
        onClose: function() {
            return !1;
        },
        onCheckAll: function() {
            return !1;
        },
        onUncheckAll: function() {
            return !1;
        },
        onFocus: function() {
            return !1;
        },
        onBlur: function() {
            return !1;
        },
        onOptgroupClick: function() {
            return !1;
        },
        onClick: function() {
            return !1;
        }
    };
}(jQuery), /*!
* jquery.inputmask.js
* http://github.com/RobinHerbots/jquery.inputmask
* Copyright (c) 2010 - 2015 Robin Herbots
* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
* Version: 3.1.63
*/
!function(factory) {
    "function" == typeof define && define.amd ? define([ "jquery" ], factory) : "object" == typeof exports ? module.exports = factory(require("jquery")) : factory(jQuery);
}(function($) {
    function isInputEventSupported(eventName) {
        var el = document.createElement("input"), evName = "on" + eventName, isSupported = evName in el;
        return isSupported || (el.setAttribute(evName, "return;"), isSupported = "function" == typeof el[evName]), 
        el = null, isSupported;
    }
    function isInputTypeSupported(inputType) {
        var isSupported = "text" == inputType || "tel" == inputType || "password" == inputType;
        if (!isSupported) {
            var el = document.createElement("input");
            el.setAttribute("type", inputType), isSupported = "text" === el.type, el = null;
        }
        return isSupported;
    }
    function resolveAlias(aliasStr, options, opts) {
        var aliasDefinition = opts.aliases[aliasStr];
        return aliasDefinition ? (aliasDefinition.alias && resolveAlias(aliasDefinition.alias, void 0, opts), 
        $.extend(!0, opts, aliasDefinition), $.extend(!0, opts, options), !0) : !1;
    }
    function generateMaskSet(opts, nocache) {
        function analyseMask(mask) {
            function maskToken(isGroup, isOptional, isQuantifier, isAlternator) {
                this.matches = [], this.isGroup = isGroup || !1, this.isOptional = isOptional || !1, 
                this.isQuantifier = isQuantifier || !1, this.isAlternator = isAlternator || !1, 
                this.quantifier = {
                    min: 1,
                    max: 1
                };
            }
            function insertTestDefinition(mtoken, element, position) {
                var maskdef = opts.definitions[element], newBlockMarker = 0 == mtoken.matches.length;
                if (position = void 0 != position ? position : mtoken.matches.length, maskdef && !escaped) {
                    maskdef.placeholder = $.isFunction(maskdef.placeholder) ? maskdef.placeholder.call(this, opts) : maskdef.placeholder;
                    for (var prevalidators = maskdef.prevalidator, prevalidatorsL = prevalidators ? prevalidators.length : 0, i = 1; i < maskdef.cardinality; i++) {
                        var prevalidator = prevalidatorsL >= i ? prevalidators[i - 1] : [], validator = prevalidator.validator, cardinality = prevalidator.cardinality;
                        mtoken.matches.splice(position++, 0, {
                            fn: validator ? "string" == typeof validator ? new RegExp(validator) : new function() {
                                this.test = validator;
                            }() : new RegExp("."),
                            cardinality: cardinality ? cardinality : 1,
                            optionality: mtoken.isOptional,
                            newBlockMarker: newBlockMarker,
                            casing: maskdef.casing,
                            def: maskdef.definitionSymbol || element,
                            placeholder: maskdef.placeholder,
                            mask: element
                        });
                    }
                    mtoken.matches.splice(position++, 0, {
                        fn: maskdef.validator ? "string" == typeof maskdef.validator ? new RegExp(maskdef.validator) : new function() {
                            this.test = maskdef.validator;
                        }() : new RegExp("."),
                        cardinality: maskdef.cardinality,
                        optionality: mtoken.isOptional,
                        newBlockMarker: newBlockMarker,
                        casing: maskdef.casing,
                        def: maskdef.definitionSymbol || element,
                        placeholder: maskdef.placeholder,
                        mask: element
                    });
                } else mtoken.matches.splice(position++, 0, {
                    fn: null,
                    cardinality: 0,
                    optionality: mtoken.isOptional,
                    newBlockMarker: newBlockMarker,
                    casing: null,
                    def: element,
                    placeholder: void 0,
                    mask: element
                }), escaped = !1;
            }
            for (var match, m, openingToken, currentOpeningToken, alternator, lastMatch, tokenizer = /(?:[?*+]|\{[0-9\+\*]+(?:,[0-9\+\*]*)?\})\??|[^.?*+^${[]()|\\]+|./g, escaped = !1, currentToken = new maskToken(), openenings = [], maskTokens = []; match = tokenizer.exec(mask); ) switch (m = match[0], 
            m.charAt(0)) {
              case opts.optionalmarker.end:
              case opts.groupmarker.end:
                if (openingToken = openenings.pop(), openenings.length > 0) {
                    if (currentOpeningToken = openenings[openenings.length - 1], currentOpeningToken.matches.push(openingToken), 
                    currentOpeningToken.isAlternator) {
                        alternator = openenings.pop();
                        for (var mndx = 0; mndx < alternator.matches.length; mndx++) alternator.matches[mndx].isGroup = !1;
                        openenings.length > 0 ? (currentOpeningToken = openenings[openenings.length - 1], 
                        currentOpeningToken.matches.push(alternator)) : currentToken.matches.push(alternator);
                    }
                } else currentToken.matches.push(openingToken);
                break;

              case opts.optionalmarker.start:
                openenings.push(new maskToken(!1, !0));
                break;

              case opts.groupmarker.start:
                openenings.push(new maskToken(!0));
                break;

              case opts.quantifiermarker.start:
                var quantifier = new maskToken(!1, !1, !0);
                m = m.replace(/[{}]/g, "");
                var mq = m.split(","), mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]), mq1 = 1 == mq.length ? mq0 : isNaN(mq[1]) ? mq[1] : parseInt(mq[1]);
                if (("*" == mq1 || "+" == mq1) && (mq0 = "*" == mq1 ? 0 : 1), quantifier.quantifier = {
                    min: mq0,
                    max: mq1
                }, openenings.length > 0) {
                    var matches = openenings[openenings.length - 1].matches;
                    if (match = matches.pop(), !match.isGroup) {
                        var groupToken = new maskToken(!0);
                        groupToken.matches.push(match), match = groupToken;
                    }
                    matches.push(match), matches.push(quantifier);
                } else {
                    if (match = currentToken.matches.pop(), !match.isGroup) {
                        var groupToken = new maskToken(!0);
                        groupToken.matches.push(match), match = groupToken;
                    }
                    currentToken.matches.push(match), currentToken.matches.push(quantifier);
                }
                break;

              case opts.escapeChar:
                escaped = !0;
                break;

              case opts.alternatormarker:
                openenings.length > 0 ? (currentOpeningToken = openenings[openenings.length - 1], 
                lastMatch = currentOpeningToken.matches.pop()) : lastMatch = currentToken.matches.pop(), 
                lastMatch.isAlternator ? openenings.push(lastMatch) : (alternator = new maskToken(!1, !1, !1, !0), 
                alternator.matches.push(lastMatch), openenings.push(alternator));
                break;

              default:
                if (openenings.length > 0) {
                    if (currentOpeningToken = openenings[openenings.length - 1], currentOpeningToken.matches.length > 0 && !currentOpeningToken.isAlternator && (lastMatch = currentOpeningToken.matches[currentOpeningToken.matches.length - 1], 
                    lastMatch.isGroup && (lastMatch.isGroup = !1, insertTestDefinition(lastMatch, opts.groupmarker.start, 0), 
                    insertTestDefinition(lastMatch, opts.groupmarker.end))), insertTestDefinition(currentOpeningToken, m), 
                    currentOpeningToken.isAlternator) {
                        alternator = openenings.pop();
                        for (var mndx = 0; mndx < alternator.matches.length; mndx++) alternator.matches[mndx].isGroup = !1;
                        openenings.length > 0 ? (currentOpeningToken = openenings[openenings.length - 1], 
                        currentOpeningToken.matches.push(alternator)) : currentToken.matches.push(alternator);
                    }
                } else currentToken.matches.length > 0 && (lastMatch = currentToken.matches[currentToken.matches.length - 1], 
                lastMatch.isGroup && (lastMatch.isGroup = !1, insertTestDefinition(lastMatch, opts.groupmarker.start, 0), 
                insertTestDefinition(lastMatch, opts.groupmarker.end))), insertTestDefinition(currentToken, m);
            }
            return currentToken.matches.length > 0 && (lastMatch = currentToken.matches[currentToken.matches.length - 1], 
            lastMatch.isGroup && (lastMatch.isGroup = !1, insertTestDefinition(lastMatch, opts.groupmarker.start, 0), 
            insertTestDefinition(lastMatch, opts.groupmarker.end)), maskTokens.push(currentToken)), 
            maskTokens;
        }
        function generateMask(mask, metadata) {
            if (void 0 == mask || "" == mask) return void 0;
            if (1 == mask.length && 0 == opts.greedy && 0 != opts.repeat && (opts.placeholder = ""), 
            opts.repeat > 0 || "*" == opts.repeat || "+" == opts.repeat) {
                var repeatStart = "*" == opts.repeat ? 0 : "+" == opts.repeat ? 1 : opts.repeat;
                mask = opts.groupmarker.start + mask + opts.groupmarker.end + opts.quantifiermarker.start + repeatStart + "," + opts.repeat + opts.quantifiermarker.end;
            }
            var masksetDefinition;
            return void 0 == $.inputmask.masksCache[mask] || nocache === !0 ? (masksetDefinition = {
                mask: mask,
                maskToken: analyseMask(mask),
                validPositions: {},
                _buffer: void 0,
                buffer: void 0,
                tests: {},
                metadata: metadata
            }, nocache !== !0 && ($.inputmask.masksCache[mask] = masksetDefinition)) : masksetDefinition = $.extend(!0, {}, $.inputmask.masksCache[mask]), 
            masksetDefinition;
        }
        function preProcessMask(mask) {
            if (mask = mask.toString(), opts.numericInput) {
                mask = mask.split("").reverse();
                for (var ndx = 0; ndx < mask.length; ndx++) mask[ndx] == opts.optionalmarker.start ? mask[ndx] = opts.optionalmarker.end : mask[ndx] == opts.optionalmarker.end ? mask[ndx] = opts.optionalmarker.start : mask[ndx] == opts.groupmarker.start ? mask[ndx] = opts.groupmarker.end : mask[ndx] == opts.groupmarker.end && (mask[ndx] = opts.groupmarker.start);
                mask = mask.join("");
            }
            return mask;
        }
        var ms = void 0;
        if ($.isFunction(opts.mask) && (opts.mask = opts.mask.call(this, opts)), $.isArray(opts.mask)) {
            if (opts.mask.length > 1) {
                opts.keepStatic = void 0 == opts.keepStatic ? !0 : opts.keepStatic;
                var altMask = "(";
                return $.each(opts.mask, function(ndx, msk) {
                    altMask.length > 1 && (altMask += ")|("), altMask += preProcessMask(void 0 == msk.mask || $.isFunction(msk.mask) ? msk : msk.mask);
                }), altMask += ")", generateMask(altMask, opts.mask);
            }
            opts.mask = opts.mask.pop();
        }
        return opts.mask && (ms = void 0 == opts.mask.mask || $.isFunction(opts.mask.mask) ? generateMask(preProcessMask(opts.mask), opts.mask) : generateMask(preProcessMask(opts.mask.mask), opts.mask)), 
        ms;
    }
    function maskScope(actionObj, maskset, opts) {
        function getMaskTemplate(baseOnInput, minimalPos, includeInput) {
            minimalPos = minimalPos || 0;
            var ndxIntlzr, test, testPos, maskTemplate = [], pos = 0;
            do {
                if (baseOnInput === !0 && getMaskSet().validPositions[pos]) {
                    var validPos = getMaskSet().validPositions[pos];
                    test = validPos.match, ndxIntlzr = validPos.locator.slice(), maskTemplate.push(includeInput === !0 ? validPos.input : getPlaceholder(pos, test));
                } else testPos = getTestTemplate(pos, ndxIntlzr, pos - 1), test = testPos.match, 
                ndxIntlzr = testPos.locator.slice(), maskTemplate.push(getPlaceholder(pos, test));
                pos++;
            } while ((void 0 == maxLength || maxLength > pos - 1) && null != test.fn || null == test.fn && "" != test.def || minimalPos >= pos);
            return maskTemplate.pop(), maskTemplate;
        }
        function getMaskSet() {
            return maskset;
        }
        function resetMaskSet(soft) {
            var maskset = getMaskSet();
            maskset.buffer = void 0, maskset.tests = {}, soft !== !0 && (maskset._buffer = void 0, 
            maskset.validPositions = {}, maskset.p = 0);
        }
        function getLastValidPosition(closestTo, strict) {
            var maskset = getMaskSet(), lastValidPosition = -1, valids = maskset.validPositions;
            void 0 == closestTo && (closestTo = -1);
            var before = lastValidPosition, after = lastValidPosition;
            for (var posNdx in valids) {
                var psNdx = parseInt(posNdx);
                valids[psNdx] && (strict || null != valids[psNdx].match.fn) && (closestTo >= psNdx && (before = psNdx), 
                psNdx >= closestTo && (after = psNdx));
            }
            return lastValidPosition = -1 != before && closestTo - before > 1 || closestTo > after ? before : after;
        }
        function setValidPosition(pos, validTest, fromSetValid) {
            if (opts.insertMode && void 0 != getMaskSet().validPositions[pos] && void 0 == fromSetValid) {
                var i, positionsClone = $.extend(!0, {}, getMaskSet().validPositions), lvp = getLastValidPosition();
                for (i = pos; lvp >= i; i++) delete getMaskSet().validPositions[i];
                getMaskSet().validPositions[pos] = validTest;
                var j, valid = !0, vps = getMaskSet().validPositions;
                for (i = j = pos; lvp >= i; i++) {
                    var t = positionsClone[i];
                    if (void 0 != t) for (var posMatch = j, prevPosMatch = -1; posMatch < getMaskLength() && (null == t.match.fn && vps[i] && (vps[i].match.optionalQuantifier === !0 || vps[i].match.optionality === !0) || null != t.match.fn); ) {
                        if (null == t.match.fn || !opts.keepStatic && vps[i] && (void 0 != vps[i + 1] && getTests(i + 1, vps[i].locator.slice(), i).length > 1 || void 0 != vps[i].alternation) ? posMatch++ : posMatch = seekNext(j), 
                        positionCanMatchDefinition(posMatch, t.match.def)) {
                            valid = isValid(posMatch, t.input, !0, !0) !== !1, j = posMatch;
                            break;
                        }
                        if (valid = null == t.match.fn, prevPosMatch == posMatch) break;
                        prevPosMatch = posMatch;
                    }
                    if (!valid) break;
                }
                if (!valid) return getMaskSet().validPositions = $.extend(!0, {}, positionsClone), 
                !1;
            } else getMaskSet().validPositions[pos] = validTest;
            return !0;
        }
        function stripValidPositions(start, end, nocheck, strict) {
            var i, startPos = start;
            for (getMaskSet().p = start, void 0 != getMaskSet().validPositions[start] && getMaskSet().validPositions[start].input == opts.radixPoint && (end++, 
            startPos++), i = startPos; end > i; i++) void 0 != getMaskSet().validPositions[i] && (nocheck === !0 || 0 != opts.canClearPosition(getMaskSet(), i, getLastValidPosition(), strict, opts)) && delete getMaskSet().validPositions[i];
            for (resetMaskSet(!0), i = startPos + 1; i <= getLastValidPosition(); ) {
                for (;void 0 != getMaskSet().validPositions[startPos]; ) startPos++;
                var s = getMaskSet().validPositions[startPos];
                startPos > i && (i = startPos + 1);
                var t = getMaskSet().validPositions[i];
                void 0 != t && void 0 == s ? (positionCanMatchDefinition(startPos, t.match.def) && isValid(startPos, t.input, !0) !== !1 && (delete getMaskSet().validPositions[i], 
                i++), startPos++) : i++;
            }
            var lvp = getLastValidPosition(), ml = getMaskLength();
            for (lvp >= start && void 0 != getMaskSet().validPositions[lvp] && getMaskSet().validPositions[lvp].input == opts.radixPoint && delete getMaskSet().validPositions[lvp], 
            i = lvp + 1; ml >= i; i++) getMaskSet().validPositions[i] && delete getMaskSet().validPositions[i];
            resetMaskSet(!0);
        }
        function getTestTemplate(pos, ndxIntlzr, tstPs) {
            var testPos = getMaskSet().validPositions[pos];
            if (void 0 == testPos) for (var testPositions = getTests(pos, ndxIntlzr, tstPs), lvp = getLastValidPosition(), lvTest = getMaskSet().validPositions[lvp] || getTests(0)[0], lvTestAltArr = void 0 != lvTest.alternation ? lvTest.locator[lvTest.alternation].toString().split(",") : [], ndx = 0; ndx < testPositions.length && (testPos = testPositions[ndx], 
            !(testPos.match && (opts.greedy && testPos.match.optionalQuantifier !== !0 || (testPos.match.optionality === !1 || testPos.match.newBlockMarker === !1) && testPos.match.optionalQuantifier !== !0) && (void 0 == lvTest.alternation || lvTest.alternation != testPos.alternation || void 0 != testPos.locator[lvTest.alternation] && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(","), lvTestAltArr)))); ndx++) ;
            return testPos;
        }
        function getTest(pos) {
            return getMaskSet().validPositions[pos] ? getMaskSet().validPositions[pos].match : getTests(pos)[0].match;
        }
        function positionCanMatchDefinition(pos, def) {
            for (var valid = !1, tests = getTests(pos), tndx = 0; tndx < tests.length; tndx++) if (tests[tndx].match && tests[tndx].match.def == def) {
                valid = !0;
                break;
            }
            return valid;
        }
        function getTests(pos, ndxIntlzr, tstPs, cacheable) {
            function ResolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) {
                function handleMatch(match, loopNdx, quantifierRecurse) {
                    if (testPos > 1e4) return alert("jquery.inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. " + getMaskSet().mask), 
                    !0;
                    if (testPos == pos && void 0 == match.matches) return matches.push({
                        match: match,
                        locator: loopNdx.reverse()
                    }), !0;
                    if (void 0 != match.matches) {
                        if (match.isGroup && quantifierRecurse !== !0) {
                            if (match = handleMatch(maskToken.matches[tndx + 1], loopNdx)) return !0;
                        } else if (match.isOptional) {
                            var optionalToken = match;
                            if (match = ResolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse)) {
                                var latestMatch = matches[matches.length - 1].match, isFirstMatch = 0 == $.inArray(latestMatch, optionalToken.matches);
                                if (!isFirstMatch) return !0;
                                insertStop = !0, testPos = pos;
                            }
                        } else if (match.isAlternator) {
                            var maltMatches, alternateToken = match, malternateMatches = [], currentMatches = matches.slice(), loopNdxCnt = loopNdx.length, altIndex = ndxInitializer.length > 0 ? ndxInitializer.shift() : -1;
                            if (-1 == altIndex || "string" == typeof altIndex) {
                                var currentPos = testPos, ndxInitializerClone = ndxInitializer.slice(), altIndexArr = [];
                                "string" == typeof altIndex && (altIndexArr = altIndex.split(","));
                                for (var amndx = 0; amndx < alternateToken.matches.length; amndx++) {
                                    if (matches = [], match = handleMatch(alternateToken.matches[amndx], [ amndx ].concat(loopNdx), quantifierRecurse) || match, 
                                    match !== !0 && void 0 != match && altIndexArr[altIndexArr.length - 1] < alternateToken.matches.length) {
                                        var ntndx = maskToken.matches.indexOf(match) + 1;
                                        maskToken.matches.length > ntndx && (match = handleMatch(maskToken.matches[ntndx], [ ntndx ].concat(loopNdx.slice(1, loopNdx.length)), quantifierRecurse), 
                                        match && (altIndexArr.push(ntndx.toString()), $.each(matches, function(ndx, lmnt) {
                                            lmnt.alternation = loopNdx.length - 1;
                                        })));
                                    }
                                    maltMatches = matches.slice(), testPos = currentPos, matches = [];
                                    for (var i = 0; i < ndxInitializerClone.length; i++) ndxInitializer[i] = ndxInitializerClone[i];
                                    for (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {
                                        var altMatch = maltMatches[ndx1];
                                        altMatch.alternation = altMatch.alternation || loopNdxCnt;
                                        for (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) {
                                            var altMatch2 = malternateMatches[ndx2];
                                            if (altMatch.match.mask == altMatch2.match.mask && ("string" != typeof altIndex || -1 != $.inArray(altMatch.locator[altMatch.alternation].toString(), altIndexArr))) {
                                                maltMatches.splice(ndx1, 1), ndx1--, altMatch2.locator[altMatch.alternation] = altMatch2.locator[altMatch.alternation] + "," + altMatch.locator[altMatch.alternation], 
                                                altMatch2.alternation = altMatch.alternation;
                                                break;
                                            }
                                        }
                                    }
                                    malternateMatches = malternateMatches.concat(maltMatches);
                                }
                                "string" == typeof altIndex && (malternateMatches = $.map(malternateMatches, function(lmnt, ndx) {
                                    if (isFinite(ndx)) {
                                        var mamatch, alternation = lmnt.alternation, altLocArr = lmnt.locator[alternation].toString().split(",");
                                        lmnt.locator[alternation] = void 0, lmnt.alternation = void 0;
                                        for (var alndx = 0; alndx < altLocArr.length; alndx++) mamatch = -1 != $.inArray(altLocArr[alndx], altIndexArr), 
                                        mamatch && (void 0 != lmnt.locator[alternation] ? (lmnt.locator[alternation] += ",", 
                                        lmnt.locator[alternation] += altLocArr[alndx]) : lmnt.locator[alternation] = parseInt(altLocArr[alndx]), 
                                        lmnt.alternation = alternation);
                                        if (void 0 != lmnt.locator[alternation]) return lmnt;
                                    }
                                })), matches = currentMatches.concat(malternateMatches), testPos = pos, insertStop = matches.length > 0;
                            } else match = alternateToken.matches[altIndex] ? handleMatch(alternateToken.matches[altIndex], [ altIndex ].concat(loopNdx), quantifierRecurse) : !1;
                            if (match) return !0;
                        } else if (match.isQuantifier && quantifierRecurse !== !0) for (var qt = match, qndx = ndxInitializer.length > 0 && quantifierRecurse !== !0 ? ndxInitializer.shift() : 0; qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max) && pos >= testPos; qndx++) {
                            var tokenGroup = maskToken.matches[$.inArray(qt, maskToken.matches) - 1];
                            if (match = handleMatch(tokenGroup, [ qndx ].concat(loopNdx), !0)) {
                                var latestMatch = matches[matches.length - 1].match;
                                latestMatch.optionalQuantifier = qndx > qt.quantifier.min - 1;
                                var isFirstMatch = 0 == $.inArray(latestMatch, tokenGroup.matches);
                                if (isFirstMatch) {
                                    if (qndx > qt.quantifier.min - 1) {
                                        insertStop = !0, testPos = pos;
                                        break;
                                    }
                                    return !0;
                                }
                                return !0;
                            }
                        } else if (match = ResolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse)) return !0;
                    } else testPos++;
                }
                for (var tndx = ndxInitializer.length > 0 ? ndxInitializer.shift() : 0; tndx < maskToken.matches.length; tndx++) if (maskToken.matches[tndx].isQuantifier !== !0) {
                    var match = handleMatch(maskToken.matches[tndx], [ tndx ].concat(loopNdx), quantifierRecurse);
                    if (match && testPos == pos) return match;
                    if (testPos > pos) break;
                }
            }
            var maskTokens = getMaskSet().maskToken, testPos = ndxIntlzr ? tstPs : 0, ndxInitializer = ndxIntlzr || [ 0 ], matches = [], insertStop = !1;
            if (cacheable === !0 && getMaskSet().tests[pos]) return getMaskSet().tests[pos];
            if (void 0 == ndxIntlzr) {
                for (var test, previousPos = pos - 1; void 0 == (test = getMaskSet().validPositions[previousPos]) && previousPos > -1 && (!getMaskSet().tests[previousPos] || void 0 == (test = getMaskSet().tests[previousPos][0])); ) previousPos--;
                void 0 != test && previousPos > -1 && (testPos = previousPos, ndxInitializer = test.locator.slice());
            }
            for (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length; mtndx++) {
                var match = ResolveTestFromToken(maskTokens[mtndx], ndxInitializer, [ mtndx ]);
                if (match && testPos == pos || testPos > pos) break;
            }
            return (0 == matches.length || insertStop) && matches.push({
                match: {
                    fn: null,
                    cardinality: 0,
                    optionality: !0,
                    casing: null,
                    def: ""
                },
                locator: []
            }), getMaskSet().tests[pos] = $.extend(!0, [], matches), getMaskSet().tests[pos];
        }
        function getBufferTemplate() {
            return void 0 == getMaskSet()._buffer && (getMaskSet()._buffer = getMaskTemplate(!1, 1)), 
            getMaskSet()._buffer;
        }
        function getBuffer() {
            return void 0 == getMaskSet().buffer && (getMaskSet().buffer = getMaskTemplate(!0, getLastValidPosition(), !0)), 
            getMaskSet().buffer;
        }
        function refreshFromBuffer(start, end, buffer) {
            if (buffer = buffer || getBuffer().slice(), start === !0) resetMaskSet(), start = 0, 
            end = buffer.length; else for (var i = start; end > i; i++) delete getMaskSet().validPositions[i], 
            delete getMaskSet().tests[i];
            for (var i = start; end > i; i++) buffer[i] != opts.skipOptionalPartCharacter && isValid(i, buffer[i], !0, !0);
        }
        function casing(elem, test) {
            switch (test.casing) {
              case "upper":
                elem = elem.toUpperCase();
                break;

              case "lower":
                elem = elem.toLowerCase();
            }
            return elem;
        }
        function checkAlternationMatch(altArr1, altArr2) {
            for (var altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1), isMatch = !1, alndx = 0; alndx < altArr1.length; alndx++) if (-1 != $.inArray(altArr1[alndx], altArrC)) {
                isMatch = !0;
                break;
            }
            return isMatch;
        }
        function isValid(pos, c, strict, fromSetValid) {
            function _isValid(position, c, strict, fromSetValid) {
                var rslt = !1;
                return $.each(getTests(position), function(ndx, tst) {
                    for (var test = tst.match, loopend = c ? 1 : 0, chrs = "", i = (getBuffer(), test.cardinality); i > loopend; i--) chrs += getBufferElement(position - (i - 1));
                    if (c && (chrs += c), rslt = null != test.fn ? test.fn.test(chrs, getMaskSet(), position, strict, opts) : c != test.def && c != opts.skipOptionalPartCharacter || "" == test.def ? !1 : {
                        c: test.def,
                        pos: position
                    }, rslt !== !1) {
                        var elem = void 0 != rslt.c ? rslt.c : c;
                        elem = elem == opts.skipOptionalPartCharacter && null === test.fn ? test.def : elem;
                        var validatedPos = position, possibleModifiedBuffer = getBuffer();
                        if (void 0 != rslt.remove && ($.isArray(rslt.remove) || (rslt.remove = [ rslt.remove ]), 
                        $.each(rslt.remove.sort(function(a, b) {
                            return b - a;
                        }), function(ndx, lmnt) {
                            stripValidPositions(lmnt, lmnt + 1, !0);
                        })), void 0 != rslt.insert && ($.isArray(rslt.insert) || (rslt.insert = [ rslt.insert ]), 
                        $.each(rslt.insert.sort(function(a, b) {
                            return a - b;
                        }), function(ndx, lmnt) {
                            isValid(lmnt.pos, lmnt.c, !0);
                        })), rslt.refreshFromBuffer) {
                            var refresh = rslt.refreshFromBuffer;
                            if (strict = !0, refreshFromBuffer(refresh === !0 ? refresh : refresh.start, refresh.end, possibleModifiedBuffer), 
                            void 0 == rslt.pos && void 0 == rslt.c) return rslt.pos = getLastValidPosition(), 
                            !1;
                            if (validatedPos = void 0 != rslt.pos ? rslt.pos : position, validatedPos != position) return rslt = $.extend(rslt, isValid(validatedPos, elem, !0)), 
                            !1;
                        } else if (rslt !== !0 && void 0 != rslt.pos && rslt.pos != position && (validatedPos = rslt.pos, 
                        refreshFromBuffer(position, validatedPos), validatedPos != position)) return rslt = $.extend(rslt, isValid(validatedPos, elem, !0)), 
                        !1;
                        return 1 != rslt && void 0 == rslt.pos && void 0 == rslt.c ? !1 : (ndx > 0 && resetMaskSet(!0), 
                        setValidPosition(validatedPos, $.extend({}, tst, {
                            input: casing(elem, test)
                        }), fromSetValid) || (rslt = !1), !1);
                    }
                }), rslt;
            }
            function alternate(pos, c, strict, fromSetValid) {
                for (var lastAlt, alternation, isValidRslt, altPos, validPsClone = $.extend(!0, {}, getMaskSet().validPositions), lAlt = getLastValidPosition(); lAlt >= 0 && (altPos = getMaskSet().validPositions[lAlt], 
                !altPos || void 0 == altPos.alternation || (lastAlt = lAlt, alternation = getMaskSet().validPositions[lastAlt].alternation, 
                getTestTemplate(lastAlt).locator[altPos.alternation] == altPos.locator[altPos.alternation])); lAlt--) ;
                if (void 0 != alternation) for (var decisionPos in getMaskSet().validPositions) if (altPos = getMaskSet().validPositions[decisionPos], 
                parseInt(decisionPos) > parseInt(lastAlt) && void 0 != altPos.alternation) {
                    var altNdxs = getMaskSet().validPositions[lastAlt].locator[alternation].toString().split(","), decisionTaker = altPos.locator[alternation] || altNdxs[0];
                    decisionTaker.length > 0 && (decisionTaker = decisionTaker.split(",")[0]);
                    for (var mndx = 0; mndx < altNdxs.length; mndx++) if (decisionTaker < altNdxs[mndx]) {
                        for (var possibilityPos, possibilities, dp = decisionPos - 1; dp >= 0; dp--) if (possibilityPos = getMaskSet().validPositions[dp], 
                        void 0 != possibilityPos) {
                            possibilities = possibilityPos.locator[alternation], possibilityPos.locator[alternation] = parseInt(altNdxs[mndx]);
                            break;
                        }
                        if (decisionTaker != possibilityPos.locator[alternation]) {
                            for (var validInputs = [], i = decisionPos; i < getLastValidPosition() + 1; i++) {
                                var validPos = getMaskSet().validPositions[i];
                                validPos && null != validPos.match.fn && validInputs.push(validPos.input), delete getMaskSet().validPositions[i], 
                                delete getMaskSet().tests[i];
                            }
                            for (resetMaskSet(!0), opts.keepStatic = !opts.keepStatic, isValidRslt = !0; validInputs.length > 0; ) {
                                var input = validInputs.shift();
                                if (input != opts.skipOptionalPartCharacter && !(isValidRslt = isValid(getLastValidPosition() + 1, input, !1, !0))) break;
                            }
                            if (possibilityPos.alternation = alternation, possibilityPos.locator[alternation] = possibilities, 
                            isValidRslt) {
                                var targetLvp = getLastValidPosition(pos) + 1;
                                isValidRslt = isValid(pos > targetLvp ? targetLvp : pos, c, strict, fromSetValid);
                            }
                            if (opts.keepStatic = !opts.keepStatic, isValidRslt) return isValidRslt;
                            resetMaskSet(), getMaskSet().validPositions = $.extend(!0, {}, validPsClone);
                        }
                    }
                    break;
                }
                return !1;
            }
            function trackbackAlternations(originalPos, newPos) {
                for (var vp = getMaskSet().validPositions[newPos], targetLocator = vp.locator, tll = targetLocator.length, ps = originalPos; newPos > ps; ps++) if (!isMask(ps)) {
                    var tests = getTests(ps), bestMatch = tests[0], equality = -1;
                    $.each(tests, function(ndx, tst) {
                        for (var i = 0; tll > i; i++) tst.locator[i] && checkAlternationMatch(tst.locator[i].toString().split(","), targetLocator[i].toString().split(",")) && i > equality && (equality = i, 
                        bestMatch = tst);
                    }), setValidPosition(ps, $.extend({}, bestMatch, {
                        input: bestMatch.match.def
                    }), !0);
                }
            }
            strict = strict === !0;
            for (var buffer = getBuffer(), pndx = pos - 1; pndx > -1 && !getMaskSet().validPositions[pndx]; pndx--) ;
            for (pndx++; pos > pndx; pndx++) void 0 == getMaskSet().validPositions[pndx] && ((!isMask(pndx) || buffer[pndx] != getPlaceholder(pndx)) && getTests(pndx).length > 1 || buffer[pndx] == opts.radixPoint || "0" == buffer[pndx] && $.inArray(opts.radixPoint, buffer) < pndx) && _isValid(pndx, buffer[pndx], !0);
            var maskPos = pos, result = !1, positionsClone = $.extend(!0, {}, getMaskSet().validPositions);
            if (maskPos < getMaskLength() && (result = _isValid(maskPos, c, strict, fromSetValid), 
            (!strict || fromSetValid) && result === !1)) {
                var currentPosValid = getMaskSet().validPositions[maskPos];
                if (!currentPosValid || null != currentPosValid.match.fn || currentPosValid.match.def != c && c != opts.skipOptionalPartCharacter) {
                    if ((opts.insertMode || void 0 == getMaskSet().validPositions[seekNext(maskPos)]) && !isMask(maskPos)) for (var nPos = maskPos + 1, snPos = seekNext(maskPos); snPos >= nPos; nPos++) if (result = _isValid(nPos, c, strict, fromSetValid), 
                    result !== !1) {
                        trackbackAlternations(maskPos, nPos), maskPos = nPos;
                        break;
                    }
                } else result = {
                    caret: seekNext(maskPos)
                };
            }
            if (result === !1 && opts.keepStatic && isComplete(buffer) && (result = alternate(pos, c, strict, fromSetValid)), 
            result === !0 && (result = {
                pos: maskPos
            }), $.isFunction(opts.postValidation) && 0 != result && !strict) {
                resetMaskSet(!0);
                var postValidResult = opts.postValidation(getBuffer(), opts);
                if (!postValidResult) return resetMaskSet(!0), getMaskSet().validPositions = $.extend(!0, {}, positionsClone), 
                !1;
            }
            return result;
        }
        function isMask(pos) {
            var test = getTest(pos);
            if (null != test.fn) return test.fn;
            if (!opts.keepStatic && void 0 == getMaskSet().validPositions[pos]) {
                for (var tests = getTests(pos), staticAlternations = !0, i = 0; i < tests.length; i++) if ("" != tests[i].match.def && (void 0 == tests[i].alternation || tests[i].locator[tests[i].alternation].length > 1)) {
                    staticAlternations = !1;
                    break;
                }
                return staticAlternations;
            }
            return !1;
        }
        function getMaskLength() {
            var maskLength;
            maxLength = $el.prop("maxLength"), -1 == maxLength && (maxLength = void 0);
            var pos, lvp = getLastValidPosition(), testPos = getMaskSet().validPositions[lvp], ndxIntlzr = void 0 != testPos ? testPos.locator.slice() : void 0;
            for (pos = lvp + 1; void 0 == testPos || null != testPos.match.fn || null == testPos.match.fn && "" != testPos.match.def; pos++) testPos = getTestTemplate(pos, ndxIntlzr, pos - 1), 
            ndxIntlzr = testPos.locator.slice();
            var lastTest = getTest(pos - 1);
            return maskLength = "" != lastTest.def ? pos : pos - 1, void 0 == maxLength || maxLength > maskLength ? maskLength : maxLength;
        }
        function seekNext(pos) {
            var maskL = getMaskLength();
            if (pos >= maskL) return maskL;
            for (var position = pos; ++position < maskL && !isMask(position) && (opts.nojumps !== !0 || opts.nojumpsThreshold > position); ) ;
            return position;
        }
        function seekPrevious(pos) {
            var position = pos;
            if (0 >= position) return 0;
            for (;--position > 0 && !isMask(position); ) ;
            return position;
        }
        function getBufferElement(position) {
            return void 0 == getMaskSet().validPositions[position] ? getPlaceholder(position) : getMaskSet().validPositions[position].input;
        }
        function writeBuffer(input, buffer, caretPos, event, triggerInputEvent) {
            if (event && $.isFunction(opts.onBeforeWrite)) {
                var result = opts.onBeforeWrite.call(input, event, buffer, caretPos, opts);
                if (result) {
                    if (result.refreshFromBuffer) {
                        var refresh = result.refreshFromBuffer;
                        refreshFromBuffer(refresh === !0 ? refresh : refresh.start, refresh.end, result.buffer), 
                        resetMaskSet(!0), buffer = getBuffer();
                    }
                    caretPos = result.caret || caretPos;
                }
            }
            input._valueSet(buffer.join("")), void 0 != caretPos && caret(input, caretPos), 
            triggerInputEvent === !0 && (skipInputEvent = !0, $(input).trigger("input"));
        }
        function getPlaceholder(pos, test) {
            if (test = test || getTest(pos), void 0 != test.placeholder) return test.placeholder;
            if (null == test.fn) {
                if (!opts.keepStatic && void 0 == getMaskSet().validPositions[pos]) {
                    for (var tests = getTests(pos), staticAlternations = !0, i = 0; i < tests.length; i++) if ("" != tests[i].match.def && (null !== tests[i].match.fn || void 0 == tests[i].alternation || tests[i].locator[tests[i].alternation].length > 1)) {
                        staticAlternations = !1;
                        break;
                    }
                    if (staticAlternations) return opts.placeholder.charAt(pos % opts.placeholder.length);
                }
                return test.def;
            }
            return opts.placeholder.charAt(pos % opts.placeholder.length);
        }
        function checkVal(input, writeOut, strict, nptvl) {
            function isTemplateMatch() {
                var isMatch = !1, charCodeNdx = getBufferTemplate().slice(initialNdx, seekNext(initialNdx)).join("").indexOf(charCodes);
                if (-1 != charCodeNdx && !isMask(initialNdx)) {
                    isMatch = !0;
                    for (var bufferTemplateArr = getBufferTemplate().slice(initialNdx, initialNdx + charCodeNdx), i = 0; i < bufferTemplateArr.length; i++) if (" " != bufferTemplateArr[i]) {
                        isMatch = !1;
                        break;
                    }
                }
                return isMatch;
            }
            var inputValue = void 0 != nptvl ? nptvl.slice() : input._valueGet().split(""), charCodes = "", initialNdx = 0;
            if (resetMaskSet(), getMaskSet().p = seekNext(-1), writeOut && input._valueSet(""), 
            !strict) {
                var staticInput = getBufferTemplate().slice(0, seekNext(-1)).join(""), matches = inputValue.join("").match(new RegExp("^" + escapeRegex(staticInput), "g"));
                matches && matches.length > 0 && (inputValue.splice(0, matches.length * staticInput.length), 
                initialNdx = seekNext(initialNdx));
            }
            $.each(inputValue, function(ndx, charCode) {
                var keypress = $.Event("keypress");
                keypress.which = charCode.charCodeAt(0), charCodes += charCode;
                var lvp = getLastValidPosition(void 0, !0), lvTest = getMaskSet().validPositions[lvp], nextTest = getTestTemplate(lvp + 1, lvTest ? lvTest.locator.slice() : void 0, lvp);
                if (!isTemplateMatch() || strict) {
                    var pos = strict ? ndx : null == nextTest.match.fn && nextTest.match.optionality && lvp + 1 < getMaskSet().p ? lvp + 1 : getMaskSet().p;
                    keypressEvent.call(input, keypress, !0, !1, strict, pos), initialNdx = pos + 1, 
                    charCodes = "";
                } else keypressEvent.call(input, keypress, !0, !1, !0, lvp + 1);
            }), writeOut && writeBuffer(input, getBuffer(), $(input).is(":focus") ? seekNext(getLastValidPosition(0)) : void 0, $.Event("checkval"));
        }
        function escapeRegex(str) {
            return $.inputmask.escapeRegex(str);
        }
        function unmaskedvalue($input) {
            if ($input.data("_inputmask") && !$input.hasClass("hasDatepicker")) {
                var umValue = [], vps = getMaskSet().validPositions;
                for (var pndx in vps) vps[pndx].match && null != vps[pndx].match.fn && umValue.push(vps[pndx].input);
                var unmaskedValue = (isRTL ? umValue.reverse() : umValue).join(""), bufferValue = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join("");
                return $.isFunction(opts.onUnMask) && (unmaskedValue = opts.onUnMask.call($input, bufferValue, unmaskedValue, opts) || unmaskedValue), 
                unmaskedValue;
            }
            return $input[0]._valueGet();
        }
        function TranslatePosition(pos) {
            if (isRTL && "number" == typeof pos && (!opts.greedy || "" != opts.placeholder)) {
                var bffrLght = getBuffer().length;
                pos = bffrLght - pos;
            }
            return pos;
        }
        function caret(input, begin, end) {
            var range, npt = input.jquery && input.length > 0 ? input[0] : input;
            if ("number" != typeof begin) return npt.setSelectionRange ? (begin = npt.selectionStart, 
            end = npt.selectionEnd) : window.getSelection ? (range = window.getSelection().getRangeAt(0), 
            (range.commonAncestorContainer.parentNode == npt || range.commonAncestorContainer == npt) && (begin = range.startOffset, 
            end = range.endOffset)) : document.selection && document.selection.createRange && (range = document.selection.createRange(), 
            begin = 0 - range.duplicate().moveStart("character", -1e5), end = begin + range.text.length), 
            {
                begin: TranslatePosition(begin),
                end: TranslatePosition(end)
            };
            if (begin = TranslatePosition(begin), end = TranslatePosition(end), end = "number" == typeof end ? end : begin, 
            $(npt).is(":visible")) {
                var scrollCalc = $(npt).css("font-size").replace("px", "") * end;
                if (npt.scrollLeft = scrollCalc > npt.scrollWidth ? scrollCalc : 0, androidchrome || 0 != opts.insertMode || begin != end || end++, 
                npt.setSelectionRange) npt.selectionStart = begin, npt.selectionEnd = end; else if (window.getSelection) {
                    if (range = document.createRange(), void 0 == npt.firstChild) {
                        var textNode = document.createTextNode("");
                        npt.appendChild(textNode);
                    }
                    range.setStart(npt.firstChild, begin < npt._valueGet().length ? begin : npt._valueGet().length), 
                    range.setEnd(npt.firstChild, end < npt._valueGet().length ? end : npt._valueGet().length), 
                    range.collapse(!0);
                    var sel = window.getSelection();
                    sel.removeAllRanges(), sel.addRange(range);
                } else npt.createTextRange && (range = npt.createTextRange(), range.collapse(!0), 
                range.moveEnd("character", end), range.moveStart("character", begin), range.select());
            }
        }
        function determineLastRequiredPosition(returnDefinition) {
            var pos, testPos, buffer = getBuffer(), bl = buffer.length, lvp = getLastValidPosition(), positions = {}, lvTest = getMaskSet().validPositions[lvp], ndxIntlzr = void 0 != lvTest ? lvTest.locator.slice() : void 0;
            for (pos = lvp + 1; pos < buffer.length; pos++) testPos = getTestTemplate(pos, ndxIntlzr, pos - 1), 
            ndxIntlzr = testPos.locator.slice(), positions[pos] = $.extend(!0, {}, testPos);
            var lvTestAlt = lvTest && void 0 != lvTest.alternation ? lvTest.locator[lvTest.alternation] : void 0;
            for (pos = bl - 1; pos > lvp && (testPos = positions[pos], (testPos.match.optionality || testPos.match.optionalQuantifier || lvTestAlt && (lvTestAlt != positions[pos].locator[lvTest.alternation] && null != testPos.match.fn || null == testPos.match.fn && testPos.locator[lvTest.alternation] && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(","), lvTestAlt.split(",")) && "" != getTests(pos)[0].def)) && buffer[pos] == getPlaceholder(pos, testPos.match)); pos--) bl--;
            return returnDefinition ? {
                l: bl,
                def: positions[bl] ? positions[bl].match : void 0
            } : bl;
        }
        function clearOptionalTail(buffer) {
            for (var rl = determineLastRequiredPosition(), lmib = buffer.length - 1; lmib > rl && !isMask(lmib); lmib--) ;
            return buffer.splice(rl, lmib + 1 - rl), buffer;
        }
        function isComplete(buffer) {
            if ($.isFunction(opts.isComplete)) return opts.isComplete.call($el, buffer, opts);
            if ("*" == opts.repeat) return void 0;
            var complete = !1, lrp = determineLastRequiredPosition(!0), aml = seekPrevious(lrp.l);
            if (getLastValidPosition(), void 0 == lrp.def || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {
                complete = !0;
                for (var i = 0; aml >= i; i++) {
                    var test = getTestTemplate(i).match;
                    if (null != test.fn && void 0 == getMaskSet().validPositions[i] && test.optionality !== !0 && test.optionalQuantifier !== !0 || null == test.fn && buffer[i] != getPlaceholder(i, test)) {
                        complete = !1;
                        break;
                    }
                }
            }
            return complete;
        }
        function isSelection(begin, end) {
            return isRTL ? begin - end > 1 || begin - end == 1 && opts.insertMode : end - begin > 1 || end - begin == 1 && opts.insertMode;
        }
        function installEventRuler(npt) {
            var events = $._data(npt).events, inComposition = !1;
            $.each(events, function(eventType, eventHandlers) {
                $.each(eventHandlers, function(ndx, eventHandler) {
                    if ("inputmask" == eventHandler.namespace && "setvalue" != eventHandler.type) {
                        var handler = eventHandler.handler;
                        eventHandler.handler = function(e) {
                            if (!(this.disabled || this.readOnly && !("keydown" == e.type && e.ctrlKey && 67 == e.keyCode || e.keyCode == $.inputmask.keyCode.TAB))) {
                                switch (e.type) {
                                  case "input":
                                    if (skipInputEvent === !0 || inComposition === !0) return skipInputEvent = !1, e.preventDefault();
                                    break;

                                  case "keydown":
                                    skipKeyPressEvent = !1, inComposition = !1;
                                    break;

                                  case "keypress":
                                    if (skipKeyPressEvent === !0) return e.preventDefault();
                                    skipKeyPressEvent = !0;
                                    break;

                                  case "compositionstart":
                                    inComposition = !0;
                                    break;

                                  case "compositionupdate":
                                    skipInputEvent = !0;
                                    break;

                                  case "compositionend":
                                    inComposition = !1;
                                }
                                return handler.apply(this, arguments);
                            }
                            e.preventDefault();
                        };
                    }
                });
            });
        }
        function patchValueProperty(npt) {
            function PatchValhook(type) {
                if (void 0 == $.valHooks[type] || 1 != $.valHooks[type].inputmaskpatch) {
                    var valhookGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function(elem) {
                        return elem.value;
                    }, valhookSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function(elem, value) {
                        return elem.value = value, elem;
                    };
                    $.valHooks[type] = {
                        get: function(elem) {
                            var $elem = $(elem);
                            if ($elem.data("_inputmask")) {
                                if ($elem.data("_inputmask").opts.autoUnmask) return $elem.inputmask("unmaskedvalue");
                                var result = valhookGet(elem), inputData = $elem.data("_inputmask"), maskset = inputData.maskset, bufferTemplate = maskset._buffer;
                                return bufferTemplate = bufferTemplate ? bufferTemplate.join("") : "", result != bufferTemplate ? result : "";
                            }
                            return valhookGet(elem);
                        },
                        set: function(elem, value) {
                            var result, $elem = $(elem), inputData = $elem.data("_inputmask");
                            return result = valhookSet(elem, value), inputData && $elem.triggerHandler("setvalue.inputmask"), 
                            result;
                        },
                        inputmaskpatch: !0
                    };
                }
            }
            function getter() {
                var $self = $(this), inputData = $(this).data("_inputmask");
                return inputData ? inputData.opts.autoUnmask ? $self.inputmask("unmaskedvalue") : valueGet.call(this) != getBufferTemplate().join("") ? valueGet.call(this) : "" : valueGet.call(this);
            }
            function setter(value) {
                var inputData = $(this).data("_inputmask");
                valueSet.call(this, value), inputData && $(this).triggerHandler("setvalue.inputmask");
            }
            function InstallNativeValueSetFallback(npt) {
                $(npt).bind("mouseenter.inputmask", function(event) {
                    var $input = $(this), input = this, value = input._valueGet();
                    "" != value && value != getBuffer().join("") && $input.triggerHandler("setvalue.inputmask");
                });
                //!! the bound handlers are executed in the order they where bound
                var events = $._data(npt).events, handlers = events.mouseover;
                if (handlers) {
                    for (var ourHandler = handlers[handlers.length - 1], i = handlers.length - 1; i > 0; i--) handlers[i] = handlers[i - 1];
                    handlers[0] = ourHandler;
                }
            }
            var valueGet, valueSet;
            if (!npt._valueGet) {
                var valueProperty;
                Object.getOwnPropertyDescriptor && void 0 == npt.value ? (valueGet = function() {
                    return this.textContent;
                }, valueSet = function(value) {
                    this.textContent = value;
                }, Object.defineProperty(npt, "value", {
                    get: getter,
                    set: setter
                })) : ((valueProperty = Object.getOwnPropertyDescriptor && Object.getOwnPropertyDescriptor(npt, "value")) && valueProperty.configurable, 
                document.__lookupGetter__ && npt.__lookupGetter__("value") ? (valueGet = npt.__lookupGetter__("value"), 
                valueSet = npt.__lookupSetter__("value"), npt.__defineGetter__("value", getter), 
                npt.__defineSetter__("value", setter)) : (valueGet = function() {
                    return npt.value;
                }, valueSet = function(value) {
                    npt.value = value;
                }, PatchValhook(npt.type), InstallNativeValueSetFallback(npt))), npt._valueGet = function(overruleRTL) {
                    return isRTL && overruleRTL !== !0 ? valueGet.call(this).split("").reverse().join("") : valueGet.call(this);
                }, npt._valueSet = function(value) {
                    valueSet.call(this, isRTL ? value.split("").reverse().join("") : value);
                };
            }
        }
        function handleRemove(input, k, pos, strict) {
            function generalize() {
                if (opts.keepStatic) {
                    resetMaskSet(!0);
                    var lastAlt, validInputs = [], positionsClone = $.extend(!0, {}, getMaskSet().validPositions);
                    for (lastAlt = getLastValidPosition(); lastAlt >= 0; lastAlt--) {
                        var validPos = getMaskSet().validPositions[lastAlt];
                        if (validPos) {
                            if (void 0 != validPos.alternation && validPos.locator[validPos.alternation] == getTestTemplate(lastAlt).locator[validPos.alternation]) break;
                            null != validPos.match.fn && validInputs.push(validPos.input), delete getMaskSet().validPositions[lastAlt];
                        }
                    }
                    if (lastAlt > 0) for (;validInputs.length > 0; ) {
                        getMaskSet().p = seekNext(getLastValidPosition());
                        var keypress = $.Event("keypress");
                        keypress.which = validInputs.pop().charCodeAt(0), keypressEvent.call(input, keypress, !0, !1, !1, getMaskSet().p);
                    } else getMaskSet().validPositions = $.extend(!0, {}, positionsClone);
                }
            }
            if ((opts.numericInput || isRTL) && (k == $.inputmask.keyCode.BACKSPACE ? k = $.inputmask.keyCode.DELETE : k == $.inputmask.keyCode.DELETE && (k = $.inputmask.keyCode.BACKSPACE), 
            isRTL)) {
                var pend = pos.end;
                pos.end = pos.begin, pos.begin = pend;
            }
            if (k == $.inputmask.keyCode.BACKSPACE && (pos.end - pos.begin < 1 || 0 == opts.insertMode) ? pos.begin = seekPrevious(pos.begin) : k == $.inputmask.keyCode.DELETE && pos.begin == pos.end && (pos.end = isMask(pos.end) ? pos.end + 1 : seekNext(pos.end) + 1), 
            stripValidPositions(pos.begin, pos.end, !1, strict), strict !== !0) {
                generalize();
                var lvp = getLastValidPosition(pos.begin);
                lvp < pos.begin ? (-1 == lvp && resetMaskSet(), getMaskSet().p = seekNext(lvp)) : getMaskSet().p = pos.begin;
            }
        }
        function keydownEvent(e) {
            var input = this, $input = $(input), k = e.keyCode, pos = caret(input);
            k == $.inputmask.keyCode.BACKSPACE || k == $.inputmask.keyCode.DELETE || iphone && 127 == k || e.ctrlKey && 88 == k && !isInputEventSupported("cut") ? (e.preventDefault(), 
            88 == k && (undoValue = getBuffer().join("")), handleRemove(input, k, pos), writeBuffer(input, getBuffer(), getMaskSet().p, e, undoValue != getBuffer().join("")), 
            input._valueGet() == getBufferTemplate().join("") ? $input.trigger("cleared") : isComplete(getBuffer()) === !0 && $input.trigger("complete"), 
            opts.showTooltip && $input.prop("title", getMaskSet().mask)) : k == $.inputmask.keyCode.END || k == $.inputmask.keyCode.PAGE_DOWN ? setTimeout(function() {
                var caretPos = seekNext(getLastValidPosition());
                opts.insertMode || caretPos != getMaskLength() || e.shiftKey || caretPos--, caret(input, e.shiftKey ? pos.begin : caretPos, caretPos);
            }, 0) : k == $.inputmask.keyCode.HOME && !e.shiftKey || k == $.inputmask.keyCode.PAGE_UP ? caret(input, 0, e.shiftKey ? pos.begin : 0) : (opts.undoOnEscape && k == $.inputmask.keyCode.ESCAPE || 90 == k && e.ctrlKey) && e.altKey !== !0 ? (checkVal(input, !0, !1, undoValue.split("")), 
            $input.click()) : k != $.inputmask.keyCode.INSERT || e.shiftKey || e.ctrlKey ? 0 != opts.insertMode || e.shiftKey || (k == $.inputmask.keyCode.RIGHT ? setTimeout(function() {
                var caretPos = caret(input);
                caret(input, caretPos.begin);
            }, 0) : k == $.inputmask.keyCode.LEFT && setTimeout(function() {
                var caretPos = caret(input);
                caret(input, isRTL ? caretPos.begin + 1 : caretPos.begin - 1);
            }, 0)) : (opts.insertMode = !opts.insertMode, caret(input, opts.insertMode || pos.begin != getMaskLength() ? pos.begin : pos.begin - 1)), 
            opts.onKeyDown.call(this, e, getBuffer(), caret(input).begin, opts), ignorable = -1 != $.inArray(k, opts.ignorables);
        }
        function keypressEvent(e, checkval, writeOut, strict, ndx) {
            var input = this, $input = $(input), k = e.which || e.charCode || e.keyCode;
            if (!(checkval === !0 || e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable)) return !0;
            if (k) {
                46 == k && 0 == e.shiftKey && "," == opts.radixPoint && (k = 44);
                var forwardPosition, pos = checkval ? {
                    begin: ndx,
                    end: ndx
                } : caret(input), c = String.fromCharCode(k), isSlctn = isSelection(pos.begin, pos.end);
                isSlctn && (getMaskSet().undoPositions = $.extend(!0, {}, getMaskSet().validPositions), 
                handleRemove(input, $.inputmask.keyCode.DELETE, pos, !0), pos.begin = getMaskSet().p, 
                opts.insertMode || (opts.insertMode = !opts.insertMode, setValidPosition(pos.begin, strict), 
                opts.insertMode = !opts.insertMode), isSlctn = !opts.multi), getMaskSet().writeOutBuffer = !0;
                var p = isRTL && !isSlctn ? pos.end : pos.begin, valResult = isValid(p, c, strict);
                if (valResult !== !1) {
                    if (valResult !== !0 && (p = void 0 != valResult.pos ? valResult.pos : p, c = void 0 != valResult.c ? valResult.c : c), 
                    resetMaskSet(!0), void 0 != valResult.caret) forwardPosition = valResult.caret; else {
                        var vps = getMaskSet().validPositions;
                        forwardPosition = !opts.keepStatic && (void 0 != vps[p + 1] && getTests(p + 1, vps[p].locator.slice(), p).length > 1 || void 0 != vps[p].alternation) ? p + 1 : seekNext(p);
                    }
                    getMaskSet().p = forwardPosition;
                }
                if (writeOut !== !1) {
                    var self = this;
                    if (setTimeout(function() {
                        opts.onKeyValidation.call(self, valResult, opts);
                    }, 0), getMaskSet().writeOutBuffer && valResult !== !1) {
                        var buffer = getBuffer();
                        writeBuffer(input, buffer, checkval ? void 0 : opts.numericInput ? seekPrevious(forwardPosition) : forwardPosition, e, checkval !== !0), 
                        checkval !== !0 && setTimeout(function() {
                            isComplete(buffer) === !0 && $input.trigger("complete");
                        }, 0);
                    } else isSlctn && (getMaskSet().buffer = void 0, getMaskSet().validPositions = getMaskSet().undoPositions);
                } else isSlctn && (getMaskSet().buffer = void 0, getMaskSet().validPositions = getMaskSet().undoPositions);
                if (opts.showTooltip && $input.prop("title", getMaskSet().mask), checkval && $.isFunction(opts.onBeforeWrite)) {
                    var result = opts.onBeforeWrite.call(this, e, getBuffer(), forwardPosition, opts);
                    if (result && result.refreshFromBuffer) {
                        var refresh = result.refreshFromBuffer;
                        refreshFromBuffer(refresh === !0 ? refresh : refresh.start, refresh.end, result.buffer), 
                        resetMaskSet(!0), result.caret && (getMaskSet().p = result.caret);
                    }
                }
                e.preventDefault();
            }
        }
        function pasteEvent(e) {
            var input = this, $input = $(input), inputValue = input._valueGet(!0), caretPos = caret(input);
            if ("propertychange" == e.type && input._valueGet().length <= getMaskLength()) return !0;
            if ("paste" == e.type) {
                var valueBeforeCaret = inputValue.substr(0, caretPos.begin), valueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);
                valueBeforeCaret == getBufferTemplate().slice(0, caretPos.begin).join("") && (valueBeforeCaret = ""), 
                valueAfterCaret == getBufferTemplate().slice(caretPos.end).join("") && (valueAfterCaret = ""), 
                window.clipboardData && window.clipboardData.getData ? inputValue = valueBeforeCaret + window.clipboardData.getData("Text") + valueAfterCaret : e.originalEvent && e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData && (inputValue = valueBeforeCaret + e.originalEvent.clipboardData.getData("text/plain") + valueAfterCaret);
            }
            var pasteValue = inputValue;
            if ($.isFunction(opts.onBeforePaste)) {
                if (pasteValue = opts.onBeforePaste.call(input, inputValue, opts), pasteValue === !1) return e.preventDefault(), 
                !1;
                pasteValue || (pasteValue = inputValue);
            }
            return checkVal(input, !0, !1, isRTL ? pasteValue.split("").reverse() : pasteValue.split("")), 
            $input.click(), isComplete(getBuffer()) === !0 && $input.trigger("complete"), !1;
        }
        function inputFallBackEvent(e) {
            var input = this;
            checkVal(input, !0, !1), isComplete(getBuffer()) === !0 && $(input).trigger("complete"), 
            e.preventDefault();
        }
        function compositionStartEvent(e) {
            var input = this;
            undoValue = getBuffer().join(""), ("" == compositionData || 0 != e.originalEvent.data.indexOf(compositionData)) && (compositionCaretPos = caret(input));
        }
        function compositionUpdateEvent(e) {
            var input = this, caretPos = compositionCaretPos || caret(input);
            0 == e.originalEvent.data.indexOf(compositionData) && (resetMaskSet(), caretPos = {
                begin: 0,
                end: 0
            });
            var newData = e.originalEvent.data;
            caret(input, caretPos.begin, caretPos.end);
            for (var i = 0; i < newData.length; i++) {
                var keypress = $.Event("keypress");
                keypress.which = newData.charCodeAt(i), skipKeyPressEvent = !1, ignorable = !1, 
                keypressEvent.call(input, keypress);
            }
            setTimeout(function() {
                var forwardPosition = getMaskSet().p;
                writeBuffer(input, getBuffer(), opts.numericInput ? seekPrevious(forwardPosition) : forwardPosition);
            }, 0), compositionData = e.originalEvent.data;
        }
        function compositionEndEvent(e) {}
        function mask(el) {
            if ($el = $(el), $el.data("_inputmask", {
                maskset: maskset,
                opts: opts,
                isRTL: !1
            }), opts.showTooltip && $el.prop("title", getMaskSet().mask), ("rtl" == el.dir || opts.rightAlign) && $el.css("text-align", "right"), 
            "rtl" == el.dir || opts.numericInput) {
                el.dir = "ltr", $el.removeAttr("dir");
                var inputData = $el.data("_inputmask");
                inputData.isRTL = !0, $el.data("_inputmask", inputData), isRTL = !0;
            }
            $el.unbind(".inputmask"), ($el.is(":input") && isInputTypeSupported($el.attr("type")) || el.isContentEditable) && ($el.closest("form").bind("submit", function(e) {
                undoValue != getBuffer().join("") && $el.change(), $el[0]._valueGet && $el[0]._valueGet() == getBufferTemplate().join("") && $el[0]._valueSet(""), 
                opts.removeMaskOnSubmit && $el.inputmask("remove");
            }).bind("reset", function() {
                setTimeout(function() {
                    $el.triggerHandler("setvalue.inputmask");
                }, 0);
            }), $el.bind("mouseenter.inputmask", function() {
                var $input = $(this), input = this;
                !$input.is(":focus") && opts.showMaskOnHover && input._valueGet() != getBuffer().join("") && writeBuffer(input, getBuffer());
            }).bind("blur.inputmask", function(e) {
                var $input = $(this), input = this;
                if ($input.data("_inputmask")) {
                    var nptValue = input._valueGet(), buffer = getBuffer().slice();
                    firstClick = !0, undoValue != buffer.join("") && setTimeout(function() {
                        $input.change(), undoValue = buffer.join("");
                    }, 0), "" != nptValue && (opts.clearMaskOnLostFocus && (nptValue == getBufferTemplate().join("") ? buffer = [] : clearOptionalTail(buffer)), 
                    isComplete(buffer) === !1 && ($input.trigger("incomplete"), opts.clearIncomplete && (resetMaskSet(), 
                    buffer = opts.clearMaskOnLostFocus ? [] : getBufferTemplate().slice())), writeBuffer(input, buffer, void 0, e));
                }
            }).bind("focus.inputmask", function(e) {
                var input = ($(this), this), nptValue = input._valueGet();
                opts.showMaskOnFocus && (!opts.showMaskOnHover || opts.showMaskOnHover && "" == nptValue) && input._valueGet() != getBuffer().join("") && writeBuffer(input, getBuffer(), seekNext(getLastValidPosition())), 
                undoValue = getBuffer().join("");
            }).bind("mouseleave.inputmask", function() {
                var $input = $(this), input = this;
                if (opts.clearMaskOnLostFocus) {
                    var buffer = getBuffer().slice(), nptValue = input._valueGet();
                    $input.is(":focus") || nptValue == $input.attr("placeholder") || "" == nptValue || (nptValue == getBufferTemplate().join("") ? buffer = [] : clearOptionalTail(buffer), 
                    writeBuffer(input, buffer));
                }
            }).bind("click.inputmask", function() {
                var $input = $(this), input = this;
                if ($input.is(":focus")) {
                    var selectedCaret = caret(input);
                    if (selectedCaret.begin == selectedCaret.end) if (opts.radixFocus && "" != opts.radixPoint && -1 != $.inArray(opts.radixPoint, getBuffer()) && (firstClick || getBuffer().join("") == getBufferTemplate().join(""))) caret(input, $.inArray(opts.radixPoint, getBuffer())), 
                    firstClick = !1; else {
                        var clickPosition = TranslatePosition(selectedCaret.begin), lastPosition = seekNext(getLastValidPosition(clickPosition));
                        lastPosition > clickPosition ? caret(input, isMask(clickPosition) ? clickPosition : seekNext(clickPosition)) : caret(input, lastPosition);
                    }
                }
            }).bind("dblclick.inputmask", function() {
                var input = this;
                setTimeout(function() {
                    caret(input, 0, seekNext(getLastValidPosition()));
                }, 0);
            }).bind(PasteEventType + ".inputmask dragdrop.inputmask drop.inputmask", pasteEvent).bind("cut.inputmask", function(e) {
                skipInputEvent = !0;
                var input = this, $input = $(input), pos = caret(input);
                handleRemove(input, $.inputmask.keyCode.DELETE, pos), writeBuffer(input, getBuffer(), getMaskSet().p, e, undoValue != getBuffer().join("")), 
                input._valueGet() == getBufferTemplate().join("") && $input.trigger("cleared"), 
                opts.showTooltip && $input.prop("title", getMaskSet().mask);
            }).bind("complete.inputmask", opts.oncomplete).bind("incomplete.inputmask", opts.onincomplete).bind("cleared.inputmask", opts.oncleared), 
            $el.bind("keydown.inputmask", keydownEvent).bind("keypress.inputmask", keypressEvent), 
            androidfirefox || $el.bind("compositionstart.inputmask", compositionStartEvent).bind("compositionupdate.inputmask", compositionUpdateEvent).bind("compositionend.inputmask", compositionEndEvent), 
            "paste" === PasteEventType && $el.bind("input.inputmask", inputFallBackEvent)), 
            $el.bind("setvalue.inputmask", function() {
                var input = this, value = input._valueGet();
                input._valueSet($.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(input, value, opts) || value : value), 
                checkVal(input, !0, !1), undoValue = getBuffer().join(""), (opts.clearMaskOnLostFocus || opts.clearIncomplete) && input._valueGet() == getBufferTemplate().join("") && input._valueSet("");
            }), patchValueProperty(el);
            var initialValue = $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(el, el._valueGet(), opts) || el._valueGet() : el._valueGet();
            checkVal(el, !0, !1, initialValue.split(""));
            var buffer = getBuffer().slice();
            undoValue = buffer.join("");
            var activeElement;
            try {
                activeElement = document.activeElement;
            } catch (e) {}
            isComplete(buffer) === !1 && opts.clearIncomplete && resetMaskSet(), opts.clearMaskOnLostFocus && (buffer.join("") == getBufferTemplate().join("") ? buffer = [] : clearOptionalTail(buffer)), 
            writeBuffer(el, buffer), activeElement === el && caret(el, seekNext(getLastValidPosition())), 
            installEventRuler(el);
        }
        var undoValue, compositionCaretPos, compositionData, $el, maxLength, isRTL = !1, skipKeyPressEvent = !1, skipInputEvent = !1, ignorable = !1, firstClick = !0;
        if (void 0 != actionObj) switch (actionObj.action) {
          case "isComplete":
            return $el = $(actionObj.el), maskset = $el.data("_inputmask").maskset, opts = $el.data("_inputmask").opts, 
            isComplete(actionObj.buffer);

          case "unmaskedvalue":
            return $el = actionObj.$input, maskset = $el.data("_inputmask").maskset, opts = $el.data("_inputmask").opts, 
            isRTL = actionObj.$input.data("_inputmask").isRTL, unmaskedvalue(actionObj.$input);

          case "mask":
            undoValue = getBuffer().join(""), mask(actionObj.el);
            break;

          case "format":
            $el = $({}), $el.data("_inputmask", {
                maskset: maskset,
                opts: opts,
                isRTL: opts.numericInput
            }), opts.numericInput && (isRTL = !0);
            var valueBuffer = ($.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call($el, actionObj.value, opts) || actionObj.value : actionObj.value).split("");
            return checkVal($el, !1, !1, isRTL ? valueBuffer.reverse() : valueBuffer), $.isFunction(opts.onBeforeWrite) && opts.onBeforeWrite.call(this, void 0, getBuffer(), 0, opts), 
            actionObj.metadata ? {
                value: isRTL ? getBuffer().slice().reverse().join("") : getBuffer().join(""),
                metadata: $el.inputmask("getmetadata")
            } : isRTL ? getBuffer().slice().reverse().join("") : getBuffer().join("");

          case "isValid":
            $el = $({}), $el.data("_inputmask", {
                maskset: maskset,
                opts: opts,
                isRTL: opts.numericInput
            }), opts.numericInput && (isRTL = !0);
            var valueBuffer = actionObj.value.split("");
            checkVal($el, !1, !0, isRTL ? valueBuffer.reverse() : valueBuffer);
            for (var buffer = getBuffer(), rl = determineLastRequiredPosition(), lmib = buffer.length - 1; lmib > rl && !isMask(lmib); lmib--) ;
            return buffer.splice(rl, lmib + 1 - rl), isComplete(buffer) && actionObj.value == buffer.join("");

          case "getemptymask":
            return $el = $(actionObj.el), maskset = $el.data("_inputmask").maskset, opts = $el.data("_inputmask").opts, 
            getBufferTemplate();

          case "remove":
            var el = actionObj.el;
            $el = $(el), maskset = $el.data("_inputmask").maskset, opts = $el.data("_inputmask").opts, 
            el._valueSet(unmaskedvalue($el)), $el.unbind(".inputmask"), $el.removeData("_inputmask");
            var valueProperty;
            Object.getOwnPropertyDescriptor && (valueProperty = Object.getOwnPropertyDescriptor(el, "value")), 
            valueProperty && valueProperty.get ? el._valueGet && Object.defineProperty(el, "value", {
                get: el._valueGet,
                set: el._valueSet
            }) : document.__lookupGetter__ && el.__lookupGetter__("value") && el._valueGet && (el.__defineGetter__("value", el._valueGet), 
            el.__defineSetter__("value", el._valueSet));
            try {
                delete el._valueGet, delete el._valueSet;
            } catch (e) {
                el._valueGet = void 0, el._valueSet = void 0;
            }
            break;

          case "getmetadata":
            if ($el = $(actionObj.el), maskset = $el.data("_inputmask").maskset, opts = $el.data("_inputmask").opts, 
            $.isArray(maskset.metadata)) {
                for (var alternation, lvp = getLastValidPosition(), firstAlt = lvp; firstAlt >= 0; firstAlt--) if (getMaskSet().validPositions[firstAlt] && void 0 != getMaskSet().validPositions[firstAlt].alternation) {
                    alternation = getMaskSet().validPositions[firstAlt].alternation;
                    break;
                }
                return void 0 != alternation ? maskset.metadata[getMaskSet().validPositions[lvp].locator[alternation]] : maskset.metadata[0];
            }
            return maskset.metadata;
        }
    }
    if (void 0 === $.fn.inputmask) {
        var ua = navigator.userAgent, iphone = null !== ua.match(new RegExp("iphone", "i")), androidchrome = (null !== ua.match(new RegExp("android.*safari.*", "i")), 
        null !== ua.match(new RegExp("android.*chrome.*", "i"))), androidfirefox = null !== ua.match(new RegExp("android.*firefox.*", "i")), PasteEventType = (/Kindle/i.test(ua) || /Silk/i.test(ua) || /KFTT/i.test(ua) || /KFOT/i.test(ua) || /KFJWA/i.test(ua) || /KFJWI/i.test(ua) || /KFSOWI/i.test(ua) || /KFTHWA/i.test(ua) || /KFTHWI/i.test(ua) || /KFAPWA/i.test(ua) || /KFAPWI/i.test(ua), 
        isInputEventSupported("paste") ? "paste" : isInputEventSupported("input") ? "input" : "propertychange");
        $.inputmask = {
            defaults: {
                placeholder: "_",
                optionalmarker: {
                    start: "[",
                    end: "]"
                },
                quantifiermarker: {
                    start: "{",
                    end: "}"
                },
                groupmarker: {
                    start: "(",
                    end: ")"
                },
                alternatormarker: "|",
                escapeChar: "\\",
                mask: null,
                oncomplete: $.noop,
                onincomplete: $.noop,
                oncleared: $.noop,
                repeat: 0,
                greedy: !0,
                autoUnmask: !1,
                removeMaskOnSubmit: !1,
                clearMaskOnLostFocus: !0,
                insertMode: !0,
                clearIncomplete: !1,
                aliases: {},
                alias: null,
                onKeyDown: $.noop,
                onBeforeMask: void 0,
                onBeforePaste: void 0,
                onBeforeWrite: void 0,
                onUnMask: void 0,
                showMaskOnFocus: !0,
                showMaskOnHover: !0,
                onKeyValidation: $.noop,
                skipOptionalPartCharacter: " ",
                showTooltip: !1,
                numericInput: !1,
                rightAlign: !1,
                undoOnEscape: !0,
                radixPoint: "",
                radixFocus: !1,
                nojumps: !1,
                nojumpsThreshold: 0,
                keepStatic: void 0,
                definitions: {
                    "9": {
                        validator: "[0-9]",
                        cardinality: 1,
                        definitionSymbol: "*"
                    },
                    a: {
                        validator: "[A-Za-z--]",
                        cardinality: 1,
                        definitionSymbol: "*"
                    },
                    "*": {
                        validator: "[0-9A-Za-z--]",
                        cardinality: 1
                    }
                },
                ignorables: [ 8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123 ],
                isComplete: void 0,
                canClearPosition: $.noop,
                postValidation: void 0
            },
            keyCode: {
                ALT: 18,
                BACKSPACE: 8,
                CAPS_LOCK: 20,
                COMMA: 188,
                COMMAND: 91,
                COMMAND_LEFT: 91,
                COMMAND_RIGHT: 93,
                CONTROL: 17,
                DELETE: 46,
                DOWN: 40,
                END: 35,
                ENTER: 13,
                ESCAPE: 27,
                HOME: 36,
                INSERT: 45,
                LEFT: 37,
                MENU: 93,
                NUMPAD_ADD: 107,
                NUMPAD_DECIMAL: 110,
                NUMPAD_DIVIDE: 111,
                NUMPAD_ENTER: 108,
                NUMPAD_MULTIPLY: 106,
                NUMPAD_SUBTRACT: 109,
                PAGE_DOWN: 34,
                PAGE_UP: 33,
                PERIOD: 190,
                RIGHT: 39,
                SHIFT: 16,
                SPACE: 32,
                TAB: 9,
                UP: 38,
                WINDOWS: 91
            },
            masksCache: {},
            escapeRegex: function(str) {
                var specials = [ "/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^" ];
                return str.replace(new RegExp("(\\" + specials.join("|\\") + ")", "gim"), "\\$1");
            },
            format: function(value, options, metadata) {
                var opts = $.extend(!0, {}, $.inputmask.defaults, options);
                return resolveAlias(opts.alias, options, opts), maskScope({
                    action: "format",
                    value: value,
                    metadata: metadata
                }, generateMaskSet(opts, options && void 0 !== options.definitions), opts);
            },
            isValid: function(value, options) {
                var opts = $.extend(!0, {}, $.inputmask.defaults, options);
                return resolveAlias(opts.alias, options, opts), maskScope({
                    action: "isValid",
                    value: value
                }, generateMaskSet(opts, options && void 0 !== options.definitions), opts);
            }
        }, $.fn.inputmask = function(fn, options) {
            function importAttributeOptions(npt, opts, importedOptionsContainer) {
                var $npt = $(npt);
                $npt.data("inputmask-alias") && resolveAlias($npt.data("inputmask-alias"), $.extend(!0, {}, opts), opts);
                for (var option in opts) {
                    var optionData = $npt.data("inputmask-" + option.toLowerCase());
                    void 0 != optionData && (optionData = "boolean" == typeof optionData ? optionData : optionData.toString(), 
                    "mask" == option && 0 == optionData.indexOf("[") ? (opts[option] = optionData.replace(/[\s[\]]/g, "").split("','"), 
                    opts[option][0] = opts[option][0].replace("'", ""), opts[option][opts[option].length - 1] = opts[option][opts[option].length - 1].replace("'", "")) : opts[option] = optionData, 
                    importedOptionsContainer && (importedOptionsContainer[option] = opts[option]));
                }
                return opts;
            }
            var maskset, opts = $.extend(!0, {}, $.inputmask.defaults, options);
            if ("string" == typeof fn) switch (fn) {
              case "mask":
                return resolveAlias(opts.alias, options, opts), this.each(function() {
                    return importAttributeOptions(this, opts), maskset = generateMaskSet(opts, options && void 0 !== options.definitions), 
                    void 0 == maskset ? this : void maskScope({
                        action: "mask",
                        el: this
                    }, maskset, opts);
                });

              case "unmaskedvalue":
                var $input = $(this);
                return $input.data("_inputmask") ? maskScope({
                    action: "unmaskedvalue",
                    $input: $input
                }) : $input.val();

              case "remove":
                return this.each(function() {
                    var $input = $(this);
                    $input.data("_inputmask") && maskScope({
                        action: "remove",
                        el: this
                    });
                });

              case "getemptymask":
                return this.data("_inputmask") ? maskScope({
                    action: "getemptymask",
                    el: this
                }) : "";

              case "hasMaskedValue":
                return this.data("_inputmask") ? !this.data("_inputmask").opts.autoUnmask : !1;

              case "isComplete":
                return this.data("_inputmask") ? maskScope({
                    action: "isComplete",
                    buffer: this[0]._valueGet().split(""),
                    el: this
                }) : !0;

              case "getmetadata":
                return this.data("_inputmask") ? maskScope({
                    action: "getmetadata",
                    el: this
                }) : void 0;

              default:
                return resolveAlias(opts.alias, options, opts), resolveAlias(fn, options, opts) || (opts.mask = fn), 
                this.each(function() {
                    return importAttributeOptions(this, opts), maskset = generateMaskSet(opts, options && void 0 !== options.definitions), 
                    void 0 == maskset ? this : void maskScope({
                        action: "mask",
                        el: this
                    }, maskset, opts);
                });
            } else {
                if ("object" == typeof fn) return opts = $.extend(!0, {}, $.inputmask.defaults, fn), 
                resolveAlias(opts.alias, fn, opts), this.each(function() {
                    return importAttributeOptions(this, opts), maskset = generateMaskSet(opts, fn && void 0 !== fn.definitions), 
                    void 0 == maskset ? this : void maskScope({
                        action: "mask",
                        el: this
                    }, maskset, opts);
                });
                if (void 0 == fn) return this.each(function() {
                    var attrOptions = $(this).attr("data-inputmask");
                    if (attrOptions && "" != attrOptions) try {
                        attrOptions = attrOptions.replace(new RegExp("'", "g"), '"');
                        var dataoptions = $.parseJSON("{" + attrOptions + "}");
                        $.extend(!0, dataoptions, options), opts = $.extend(!0, {}, $.inputmask.defaults, dataoptions), 
                        opts = importAttributeOptions(this, opts), resolveAlias(opts.alias, dataoptions, opts), 
                        opts.alias = void 0, $(this).inputmask("mask", opts);
                    } catch (ex) {}
                    if ($(this).attr("data-inputmask-mask") || $(this).attr("data-inputmask-alias")) {
                        opts = $.extend(!0, {}, $.inputmask.defaults, {});
                        var dataOptions = {};
                        opts = importAttributeOptions(this, opts, dataOptions), resolveAlias(opts.alias, dataOptions, opts), 
                        opts.alias = void 0, $(this).inputmask("mask", opts);
                    }
                });
            }
        };
    }
    return $.fn.inputmask;
}), "undefined" == typeof jQuery) throw new Error("Bootstrap requires jQuery");

/* ========================================================================
 * Bootstrap: transition.js v3.0.3
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */
+function($) {
    "use strict";
    // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
    // ============================================================
    function transitionEnd() {
        var el = document.createElement("bootstrap"), transEndEventNames = {
            WebkitTransition: "webkitTransitionEnd",
            MozTransition: "transitionend",
            OTransition: "oTransitionEnd otransitionend",
            transition: "transitionend"
        };
        for (var name in transEndEventNames) if (void 0 !== el.style[name]) return {
            end: transEndEventNames[name]
        };
    }
    // http://blog.alexmaccaw.com/css-transitions
    $.fn.emulateTransitionEnd = function(duration) {
        var called = !1, $el = this;
        $(this).one($.support.transition.end, function() {
            called = !0;
        });
        var callback = function() {
            called || $($el).trigger($.support.transition.end);
        };
        return setTimeout(callback, duration), this;
    }, $(function() {
        $.support.transition = transitionEnd();
    });
}(jQuery), /* ========================================================================
 * Bootstrap: alert.js v3.0.3
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */
+function($) {
    "use strict";
    // ALERT CLASS DEFINITION
    // ======================
    var dismiss = '[data-dismiss="alert"]', Alert = function(el) {
        $(el).on("click", dismiss, this.close);
    };
    Alert.prototype.close = function(e) {
        function removeElement() {
            $parent.trigger("closed.bs.alert").remove();
        }
        var $this = $(this), selector = $this.attr("data-target");
        selector || (selector = $this.attr("href"), selector = selector && selector.replace(/.*(?=#[^\s]*$)/, ""));
        var $parent = $(selector);
        e && e.preventDefault(), $parent.length || ($parent = $this.hasClass("alert") ? $this : $this.parent()), 
        $parent.trigger(e = $.Event("close.bs.alert")), e.isDefaultPrevented() || ($parent.removeClass("in"), 
        $.support.transition && $parent.hasClass("fade") ? $parent.one($.support.transition.end, removeElement).emulateTransitionEnd(150) : removeElement());
    };
    // ALERT PLUGIN DEFINITION
    // =======================
    var old = $.fn.alert;
    $.fn.alert = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.alert");
            data || $this.data("bs.alert", data = new Alert(this)), "string" == typeof option && data[option].call($this);
        });
    }, $.fn.alert.Constructor = Alert, // ALERT NO CONFLICT
    // =================
    $.fn.alert.noConflict = function() {
        return $.fn.alert = old, this;
    }, // ALERT DATA-API
    // ==============
    $(document).on("click.bs.alert.data-api", dismiss, Alert.prototype.close);
}(jQuery), /* ========================================================================
 * Bootstrap: button.js v3.0.3
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */
+function($) {
    "use strict";
    // BUTTON PUBLIC CLASS DEFINITION
    // ==============================
    var Button = function(element, options) {
        this.$element = $(element), this.options = $.extend({}, Button.DEFAULTS, options);
    };
    Button.DEFAULTS = {
        loadingText: "loading..."
    }, Button.prototype.setState = function(state) {
        var d = "disabled", $el = this.$element, val = $el.is("input") ? "val" : "html", data = $el.data();
        state += "Text", data.resetText || $el.data("resetText", $el[val]()), $el[val](data[state] || this.options[state]), 
        setTimeout(function() {
            "loadingText" == state ? $el.addClass(d).attr(d, d) : $el.removeClass(d).removeAttr(d);
        }, 0);
    }, Button.prototype.toggle = function() {
        var $parent = this.$element.closest('[data-toggle="buttons"]'), changed = !0;
        if ($parent.length) {
            var $input = this.$element.find("input");
            "radio" === $input.prop("type") && (// see if clicking on current one
            $input.prop("checked") && this.$element.hasClass("active") ? changed = !1 : $parent.find(".active").removeClass("active")), 
            changed && $input.prop("checked", !this.$element.hasClass("active")).trigger("change");
        }
        changed && this.$element.toggleClass("active");
    };
    // BUTTON PLUGIN DEFINITION
    // ========================
    var old = $.fn.button;
    $.fn.button = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.button"), options = "object" == typeof option && option;
            data || $this.data("bs.button", data = new Button(this, options)), "toggle" == option ? data.toggle() : option && data.setState(option);
        });
    }, $.fn.button.Constructor = Button, // BUTTON NO CONFLICT
    // ==================
    $.fn.button.noConflict = function() {
        return $.fn.button = old, this;
    }, // BUTTON DATA-API
    // ===============
    $(document).on("click.bs.button.data-api", "[data-toggle^=button]", function(e) {
        var $btn = $(e.target);
        $btn.hasClass("btn") || ($btn = $btn.closest(".btn")), $btn.button("toggle"), e.preventDefault();
    });
}(jQuery), /* ========================================================================
 * Bootstrap: carousel.js v3.0.3
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */
+function($) {
    "use strict";
    // CAROUSEL CLASS DEFINITION
    // =========================
    var Carousel = function(element, options) {
        this.$element = $(element), this.$indicators = this.$element.find(".carousel-indicators"), 
        this.options = options, this.paused = this.sliding = this.interval = this.$active = this.$items = null, 
        "hover" == this.options.pause && this.$element.on("mouseenter", $.proxy(this.pause, this)).on("mouseleave", $.proxy(this.cycle, this));
    };
    Carousel.DEFAULTS = {
        interval: 5e3,
        pause: "hover",
        wrap: !0
    }, Carousel.prototype.cycle = function(e) {
        return e || (this.paused = !1), this.interval && clearInterval(this.interval), this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval)), 
        this;
    }, Carousel.prototype.getActiveIndex = function() {
        return this.$active = this.$element.find(".item.active"), this.$items = this.$active.parent().children(), 
        this.$items.index(this.$active);
    }, Carousel.prototype.to = function(pos) {
        var that = this, activeIndex = this.getActiveIndex();
        return pos > this.$items.length - 1 || 0 > pos ? void 0 : this.sliding ? this.$element.one("slid.bs.carousel", function() {
            that.to(pos);
        }) : activeIndex == pos ? this.pause().cycle() : this.slide(pos > activeIndex ? "next" : "prev", $(this.$items[pos]));
    }, Carousel.prototype.pause = function(e) {
        return e || (this.paused = !0), this.$element.find(".next, .prev").length && $.support.transition.end && (this.$element.trigger($.support.transition.end), 
        this.cycle(!0)), this.interval = clearInterval(this.interval), this;
    }, Carousel.prototype.next = function() {
        return this.sliding ? void 0 : this.slide("next");
    }, Carousel.prototype.prev = function() {
        return this.sliding ? void 0 : this.slide("prev");
    }, Carousel.prototype.slide = function(type, next) {
        var $active = this.$element.find(".item.active"), $next = next || $active[type](), isCycling = this.interval, direction = "next" == type ? "left" : "right", fallback = "next" == type ? "first" : "last", that = this;
        if (!$next.length) {
            if (!this.options.wrap) return;
            $next = this.$element.find(".item")[fallback]();
        }
        this.sliding = !0, isCycling && this.pause();
        var e = $.Event("slide.bs.carousel", {
            relatedTarget: $next[0],
            direction: direction
        });
        if (!$next.hasClass("active")) {
            if (this.$indicators.length && (this.$indicators.find(".active").removeClass("active"), 
            this.$element.one("slid.bs.carousel", function() {
                var $nextIndicator = $(that.$indicators.children()[that.getActiveIndex()]);
                $nextIndicator && $nextIndicator.addClass("active");
            })), $.support.transition && this.$element.hasClass("slide")) {
                if (this.$element.trigger(e), e.isDefaultPrevented()) return;
                $next.addClass(type), $next[0].offsetWidth, // force reflow
                $active.addClass(direction), $next.addClass(direction), $active.one($.support.transition.end, function() {
                    $next.removeClass([ type, direction ].join(" ")).addClass("active"), $active.removeClass([ "active", direction ].join(" ")), 
                    that.sliding = !1, setTimeout(function() {
                        that.$element.trigger("slid.bs.carousel");
                    }, 0);
                }).emulateTransitionEnd(600);
            } else {
                if (this.$element.trigger(e), e.isDefaultPrevented()) return;
                $active.removeClass("active"), $next.addClass("active"), this.sliding = !1, this.$element.trigger("slid.bs.carousel");
            }
            return isCycling && this.cycle(), this;
        }
    };
    // CAROUSEL PLUGIN DEFINITION
    // ==========================
    var old = $.fn.carousel;
    $.fn.carousel = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.carousel"), options = $.extend({}, Carousel.DEFAULTS, $this.data(), "object" == typeof option && option), action = "string" == typeof option ? option : options.slide;
            data || $this.data("bs.carousel", data = new Carousel(this, options)), "number" == typeof option ? data.to(option) : action ? data[action]() : options.interval && data.pause().cycle();
        });
    }, $.fn.carousel.Constructor = Carousel, // CAROUSEL NO CONFLICT
    // ====================
    $.fn.carousel.noConflict = function() {
        return $.fn.carousel = old, this;
    }, // CAROUSEL DATA-API
    // =================
    $(document).on("click.bs.carousel.data-api", "[data-slide], [data-slide-to]", function(e) {
        var href, $this = $(this), $target = $($this.attr("data-target") || (href = $this.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, "")), options = $.extend({}, $target.data(), $this.data()), slideIndex = $this.attr("data-slide-to");
        slideIndex && (options.interval = !1), $target.carousel(options), (slideIndex = $this.attr("data-slide-to")) && $target.data("bs.carousel").to(slideIndex), 
        e.preventDefault();
    }), $(window).on("load", function() {
        $('[data-ride="carousel"]').each(function() {
            var $carousel = $(this);
            $carousel.carousel($carousel.data());
        });
    });
}(jQuery), /* ========================================================================
 * Bootstrap: collapse.js v3.0.3
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */
+function($) {
    "use strict";
    // COLLAPSE PUBLIC CLASS DEFINITION
    // ================================
    var Collapse = function(element, options) {
        this.$element = $(element), this.options = $.extend({}, Collapse.DEFAULTS, options), 
        this.transitioning = null, this.options.parent && (this.$parent = $(this.options.parent)), 
        this.options.toggle && this.toggle();
    };
    Collapse.DEFAULTS = {
        toggle: !0
    }, Collapse.prototype.dimension = function() {
        var hasWidth = this.$element.hasClass("width");
        return hasWidth ? "width" : "height";
    }, Collapse.prototype.show = function() {
        if (!this.transitioning && !this.$element.hasClass("in")) {
            var startEvent = $.Event("show.bs.collapse");
            if (this.$element.trigger(startEvent), !startEvent.isDefaultPrevented()) {
                var actives = this.$parent && this.$parent.find("> .panel > .in");
                if (actives && actives.length) {
                    var hasData = actives.data("bs.collapse");
                    if (hasData && hasData.transitioning) return;
                    actives.collapse("hide"), hasData || actives.data("bs.collapse", null);
                }
                var dimension = this.dimension();
                this.$element.removeClass("collapse").addClass("collapsing")[dimension](0), this.transitioning = 1;
                var complete = function() {
                    this.$element.removeClass("collapsing").addClass("in")[dimension]("auto"), this.transitioning = 0, 
                    this.$element.trigger("shown.bs.collapse");
                };
                if (!$.support.transition) return complete.call(this);
                var scrollSize = $.camelCase([ "scroll", dimension ].join("-"));
                this.$element.one($.support.transition.end, $.proxy(complete, this)).emulateTransitionEnd(350)[dimension](this.$element[0][scrollSize]);
            }
        }
    }, Collapse.prototype.hide = function() {
        if (!this.transitioning && this.$element.hasClass("in")) {
            var startEvent = $.Event("hide.bs.collapse");
            if (this.$element.trigger(startEvent), !startEvent.isDefaultPrevented()) {
                var dimension = this.dimension();
                this.$element[dimension](this.$element[dimension]())[0].offsetHeight, this.$element.addClass("collapsing").removeClass("collapse").removeClass("in"), 
                this.transitioning = 1;
                var complete = function() {
                    this.transitioning = 0, this.$element.trigger("hidden.bs.collapse").removeClass("collapsing").addClass("collapse");
                };
                return $.support.transition ? void this.$element[dimension](0).one($.support.transition.end, $.proxy(complete, this)).emulateTransitionEnd(350) : complete.call(this);
            }
        }
    }, Collapse.prototype.toggle = function() {
        this[this.$element.hasClass("in") ? "hide" : "show"]();
    };
    // COLLAPSE PLUGIN DEFINITION
    // ==========================
    var old = $.fn.collapse;
    $.fn.collapse = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.collapse"), options = $.extend({}, Collapse.DEFAULTS, $this.data(), "object" == typeof option && option);
            data || $this.data("bs.collapse", data = new Collapse(this, options)), "string" == typeof option && data[option]();
        });
    }, $.fn.collapse.Constructor = Collapse, // COLLAPSE NO CONFLICT
    // ====================
    $.fn.collapse.noConflict = function() {
        return $.fn.collapse = old, this;
    }, // COLLAPSE DATA-API
    // =================
    $(document).on("click.bs.collapse.data-api", "[data-toggle=collapse]", function(e) {
        var href, $this = $(this), target = $this.attr("data-target") || e.preventDefault() || (href = $this.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, ""), $target = $(target), data = $target.data("bs.collapse"), option = data ? "toggle" : $this.data(), parent = $this.attr("data-parent"), $parent = parent && $(parent);
        data && data.transitioning || ($parent && $parent.find('[data-toggle=collapse][data-parent="' + parent + '"]').not($this).addClass("collapsed"), 
        $this[$target.hasClass("in") ? "addClass" : "removeClass"]("collapsed")), $target.collapse(option);
    });
}(jQuery), /* ========================================================================
 * Bootstrap: dropdown.js v3.0.3
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */
+function($) {
    "use strict";
    function clearMenus() {
        $(backdrop).remove(), $(toggle).each(function(e) {
            var $parent = getParent($(this));
            $parent.hasClass("open") && ($parent.trigger(e = $.Event("hide.bs.dropdown")), e.isDefaultPrevented() || $parent.removeClass("open").trigger("hidden.bs.dropdown"));
        });
    }
    function getParent($this) {
        var selector = $this.attr("data-target");
        selector || (selector = $this.attr("href"), selector = selector && /#/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, ""));
        var $parent = selector && $(selector);
        return $parent && $parent.length ? $parent : $this.parent();
    }
    // DROPDOWN CLASS DEFINITION
    // =========================
    var backdrop = ".dropdown-backdrop", toggle = "[data-toggle=dropdown]", Dropdown = function(element) {
        $(element).on("click.bs.dropdown", this.toggle);
    };
    Dropdown.prototype.toggle = function(e) {
        var $this = $(this);
        if (!$this.is(".disabled, :disabled")) {
            var $parent = getParent($this), isActive = $parent.hasClass("open");
            if (clearMenus(), !isActive) {
                if ("ontouchstart" in document.documentElement && !$parent.closest(".navbar-nav").length && // if mobile we use a backdrop because click events don't delegate
                $('<div class="dropdown-backdrop"/>').insertAfter($(this)).on("click", clearMenus), 
                $parent.trigger(e = $.Event("show.bs.dropdown")), e.isDefaultPrevented()) return;
                $parent.toggleClass("open").trigger("shown.bs.dropdown"), $this.focus();
            }
            return !1;
        }
    }, Dropdown.prototype.keydown = function(e) {
        if (/(38|40|27)/.test(e.keyCode)) {
            var $this = $(this);
            if (e.preventDefault(), e.stopPropagation(), !$this.is(".disabled, :disabled")) {
                var $parent = getParent($this), isActive = $parent.hasClass("open");
                if (!isActive || isActive && 27 == e.keyCode) return 27 == e.which && $parent.find(toggle).focus(), 
                $this.click();
                var $items = $("[role=menu] li:not(.divider):visible a", $parent);
                if ($items.length) {
                    var index = $items.index($items.filter(":focus"));
                    38 == e.keyCode && index > 0 && index--, // up
                    40 == e.keyCode && index < $items.length - 1 && index++, // down
                    ~index || (index = 0), $items.eq(index).focus();
                }
            }
        }
    };
    // DROPDOWN PLUGIN DEFINITION
    // ==========================
    var old = $.fn.dropdown;
    $.fn.dropdown = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.dropdown");
            data || $this.data("bs.dropdown", data = new Dropdown(this)), "string" == typeof option && data[option].call($this);
        });
    }, $.fn.dropdown.Constructor = Dropdown, // DROPDOWN NO CONFLICT
    // ====================
    $.fn.dropdown.noConflict = function() {
        return $.fn.dropdown = old, this;
    }, // APPLY TO STANDARD DROPDOWN ELEMENTS
    // ===================================
    $(document).on("click.bs.dropdown.data-api", clearMenus).on("click.bs.dropdown.data-api", ".dropdown form", function(e) {
        e.stopPropagation();
    }).on("click.bs.dropdown.data-api", toggle, Dropdown.prototype.toggle).on("keydown.bs.dropdown.data-api", toggle + ", [role=menu]", Dropdown.prototype.keydown);
}(jQuery), /* ========================================================================
 * Bootstrap: modal.js v3.0.3
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */
+function($) {
    "use strict";
    // MODAL CLASS DEFINITION
    // ======================
    var Modal = function(element, options) {
        this.options = options, this.$element = $(element), this.$backdrop = this.isShown = null, 
        this.options.remote && this.$element.load(this.options.remote);
    };
    Modal.DEFAULTS = {
        backdrop: !0,
        keyboard: !0,
        show: !0
    }, Modal.prototype.toggle = function(_relatedTarget) {
        return this[this.isShown ? "hide" : "show"](_relatedTarget);
    }, Modal.prototype.show = function(_relatedTarget) {
        var that = this, e = $.Event("show.bs.modal", {
            relatedTarget: _relatedTarget
        });
        this.$element.trigger(e), this.isShown || e.isDefaultPrevented() || (this.isShown = !0, 
        this.escape(), this.$element.on("click.dismiss.modal", '[data-dismiss="modal"]', $.proxy(this.hide, this)), 
        this.backdrop(function() {
            var transition = $.support.transition && that.$element.hasClass("fade");
            that.$element.parent().length || that.$element.appendTo(document.body), that.$element.show(), 
            transition && that.$element[0].offsetWidth, that.$element.addClass("in").attr("aria-hidden", !1), 
            that.enforceFocus();
            var e = $.Event("shown.bs.modal", {
                relatedTarget: _relatedTarget
            });
            transition ? that.$element.find(".modal-dialog").one($.support.transition.end, function() {
                that.$element.focus().trigger(e);
            }).emulateTransitionEnd(300) : that.$element.focus().trigger(e);
        }));
    }, Modal.prototype.hide = function(e) {
        e && e.preventDefault(), e = $.Event("hide.bs.modal"), this.$element.trigger(e), 
        this.isShown && !e.isDefaultPrevented() && (this.isShown = !1, this.escape(), $(document).off("focusin.bs.modal"), 
        this.$element.removeClass("in").attr("aria-hidden", !0).off("click.dismiss.modal"), 
        $.support.transition && this.$element.hasClass("fade") ? this.$element.one($.support.transition.end, $.proxy(this.hideModal, this)).emulateTransitionEnd(300) : this.hideModal());
    }, Modal.prototype.enforceFocus = function() {
        $(document).off("focusin.bs.modal").on("focusin.bs.modal", $.proxy(function(e) {
            this.$element[0] === e.target || this.$element.has(e.target).length || this.$element.focus();
        }, this));
    }, Modal.prototype.escape = function() {
        this.isShown && this.options.keyboard ? this.$element.on("keyup.dismiss.bs.modal", $.proxy(function(e) {
            27 == e.which && this.hide();
        }, this)) : this.isShown || this.$element.off("keyup.dismiss.bs.modal");
    }, Modal.prototype.hideModal = function() {
        var that = this;
        this.$element.hide(), this.backdrop(function() {
            that.removeBackdrop(), that.$element.trigger("hidden.bs.modal");
        });
    }, Modal.prototype.removeBackdrop = function() {
        this.$backdrop && this.$backdrop.remove(), this.$backdrop = null;
    }, Modal.prototype.backdrop = function(callback) {
        var animate = this.$element.hasClass("fade") ? "fade" : "";
        if (this.isShown && this.options.backdrop) {
            var doAnimate = $.support.transition && animate;
            if (this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />').appendTo(document.body), 
            this.$element.on("click.dismiss.modal", $.proxy(function(e) {
                e.target === e.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus.call(this.$element[0]) : this.hide.call(this));
            }, this)), doAnimate && this.$backdrop[0].offsetWidth, // force reflow
            this.$backdrop.addClass("in"), !callback) return;
            doAnimate ? this.$backdrop.one($.support.transition.end, callback).emulateTransitionEnd(150) : callback();
        } else !this.isShown && this.$backdrop ? (this.$backdrop.removeClass("in"), $.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one($.support.transition.end, callback).emulateTransitionEnd(150) : callback()) : callback && callback();
    };
    // MODAL PLUGIN DEFINITION
    // =======================
    var old = $.fn.modal;
    $.fn.modal = function(option, _relatedTarget) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.modal"), options = $.extend({}, Modal.DEFAULTS, $this.data(), "object" == typeof option && option);
            data || $this.data("bs.modal", data = new Modal(this, options)), "string" == typeof option ? data[option](_relatedTarget) : options.show && data.show(_relatedTarget);
        });
    }, $.fn.modal.Constructor = Modal, // MODAL NO CONFLICT
    // =================
    $.fn.modal.noConflict = function() {
        return $.fn.modal = old, this;
    }, // MODAL DATA-API
    // ==============
    $(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function(e) {
        var $this = $(this), href = $this.attr("href"), $target = $($this.attr("data-target") || href && href.replace(/.*(?=#[^\s]+$)/, "")), option = $target.data("modal") ? "toggle" : $.extend({
            remote: !/#/.test(href) && href
        }, $target.data(), $this.data());
        e.preventDefault(), $target.modal(option, this).one("hide", function() {
            $this.is(":visible") && $this.focus();
        });
    }), $(document).on("show.bs.modal", ".modal", function() {
        $(document.body).addClass("modal-open");
    }).on("hidden.bs.modal", ".modal", function() {
        $(document.body).removeClass("modal-open");
    });
}(jQuery), /* ========================================================================
 * Bootstrap: tooltip.js v3.0.3
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */
+function($) {
    "use strict";
    // TOOLTIP PUBLIC CLASS DEFINITION
    // ===============================
    var Tooltip = function(element, options) {
        this.type = this.options = this.enabled = this.timeout = this.hoverState = this.$element = null, 
        this.init("tooltip", element, options);
    };
    Tooltip.DEFAULTS = {
        animation: !0,
        placement: "top",
        selector: !1,
        template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: !1,
        container: !1
    }, Tooltip.prototype.init = function(type, element, options) {
        this.enabled = !0, this.type = type, this.$element = $(element), this.options = this.getOptions(options);
        for (var triggers = this.options.trigger.split(" "), i = triggers.length; i--; ) {
            var trigger = triggers[i];
            if ("click" == trigger) this.$element.on("click." + this.type, this.options.selector, $.proxy(this.toggle, this)); else if ("manual" != trigger) {
                var eventIn = "hover" == trigger ? "mouseenter" : "focus", eventOut = "hover" == trigger ? "mouseleave" : "blur";
                this.$element.on(eventIn + "." + this.type, this.options.selector, $.proxy(this.enter, this)), 
                this.$element.on(eventOut + "." + this.type, this.options.selector, $.proxy(this.leave, this));
            }
        }
        this.options.selector ? this._options = $.extend({}, this.options, {
            trigger: "manual",
            selector: ""
        }) : this.fixTitle();
    }, Tooltip.prototype.getDefaults = function() {
        return Tooltip.DEFAULTS;
    }, Tooltip.prototype.getOptions = function(options) {
        return options = $.extend({}, this.getDefaults(), this.$element.data(), options), 
        options.delay && "number" == typeof options.delay && (options.delay = {
            show: options.delay,
            hide: options.delay
        }), options;
    }, Tooltip.prototype.getDelegateOptions = function() {
        var options = {}, defaults = this.getDefaults();
        return this._options && $.each(this._options, function(key, value) {
            defaults[key] != value && (options[key] = value);
        }), options;
    }, Tooltip.prototype.enter = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget)[this.type](this.getDelegateOptions()).data("bs." + this.type);
        return clearTimeout(self.timeout), self.hoverState = "in", self.options.delay && self.options.delay.show ? void (self.timeout = setTimeout(function() {
            "in" == self.hoverState && self.show();
        }, self.options.delay.show)) : self.show();
    }, Tooltip.prototype.leave = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget)[this.type](this.getDelegateOptions()).data("bs." + this.type);
        return clearTimeout(self.timeout), self.hoverState = "out", self.options.delay && self.options.delay.hide ? void (self.timeout = setTimeout(function() {
            "out" == self.hoverState && self.hide();
        }, self.options.delay.hide)) : self.hide();
    }, Tooltip.prototype.show = function() {
        var e = $.Event("show.bs." + this.type);
        if (this.hasContent() && this.enabled) {
            if (this.$element.trigger(e), e.isDefaultPrevented()) return;
            var $tip = this.tip();
            this.setContent(), this.options.animation && $tip.addClass("fade");
            var placement = "function" == typeof this.options.placement ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement, autoToken = /\s?auto?\s?/i, autoPlace = autoToken.test(placement);
            autoPlace && (placement = placement.replace(autoToken, "") || "top"), $tip.detach().css({
                top: 0,
                left: 0,
                display: "block"
            }).addClass(placement), this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);
            var pos = this.getPosition(), actualWidth = $tip[0].offsetWidth, actualHeight = $tip[0].offsetHeight;
            if (autoPlace) {
                var $parent = this.$element.parent(), orgPlacement = placement, docScroll = document.documentElement.scrollTop || document.body.scrollTop, parentWidth = "body" == this.options.container ? window.innerWidth : $parent.outerWidth(), parentHeight = "body" == this.options.container ? window.innerHeight : $parent.outerHeight(), parentLeft = "body" == this.options.container ? 0 : $parent.offset().left;
                placement = "bottom" == placement && pos.top + pos.height + actualHeight - docScroll > parentHeight ? "top" : "top" == placement && pos.top - docScroll - actualHeight < 0 ? "bottom" : "right" == placement && pos.right + actualWidth > parentWidth ? "left" : "left" == placement && pos.left - actualWidth < parentLeft ? "right" : placement, 
                $tip.removeClass(orgPlacement).addClass(placement);
            }
            var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);
            this.applyPlacement(calculatedOffset, placement), this.$element.trigger("shown.bs." + this.type);
        }
    }, Tooltip.prototype.applyPlacement = function(offset, placement) {
        var replace, $tip = this.tip(), width = $tip[0].offsetWidth, height = $tip[0].offsetHeight, marginTop = parseInt($tip.css("margin-top"), 10), marginLeft = parseInt($tip.css("margin-left"), 10);
        // we must check for NaN for ie 8/9
        isNaN(marginTop) && (marginTop = 0), isNaN(marginLeft) && (marginLeft = 0), offset.top = offset.top + marginTop, 
        offset.left = offset.left + marginLeft, $tip.offset(offset).addClass("in");
        // check to see if placing tip in new offset caused the tip to resize itself
        var actualWidth = $tip[0].offsetWidth, actualHeight = $tip[0].offsetHeight;
        if ("top" == placement && actualHeight != height && (replace = !0, offset.top = offset.top + height - actualHeight), 
        /bottom|top/.test(placement)) {
            var delta = 0;
            offset.left < 0 && (delta = -2 * offset.left, offset.left = 0, $tip.offset(offset), 
            actualWidth = $tip[0].offsetWidth, actualHeight = $tip[0].offsetHeight), this.replaceArrow(delta - width + actualWidth, actualWidth, "left");
        } else this.replaceArrow(actualHeight - height, actualHeight, "top");
        replace && $tip.offset(offset);
    }, Tooltip.prototype.replaceArrow = function(delta, dimension, position) {
        this.arrow().css(position, delta ? 50 * (1 - delta / dimension) + "%" : "");
    }, Tooltip.prototype.setContent = function() {
        var $tip = this.tip(), title = this.getTitle();
        $tip.find(".tooltip-inner")[this.options.html ? "html" : "text"](title), $tip.removeClass("fade in top bottom left right");
    }, Tooltip.prototype.hide = function() {
        function complete() {
            "in" != that.hoverState && $tip.detach();
        }
        var that = this, $tip = this.tip(), e = $.Event("hide.bs." + this.type);
        return this.$element.trigger(e), e.isDefaultPrevented() ? void 0 : ($tip.removeClass("in"), 
        $.support.transition && this.$tip.hasClass("fade") ? $tip.one($.support.transition.end, complete).emulateTransitionEnd(150) : complete(), 
        this.$element.trigger("hidden.bs." + this.type), this);
    }, Tooltip.prototype.fixTitle = function() {
        var $e = this.$element;
        ($e.attr("title") || "string" != typeof $e.attr("data-original-title")) && $e.attr("data-original-title", $e.attr("title") || "").attr("title", "");
    }, Tooltip.prototype.hasContent = function() {
        return this.getTitle();
    }, Tooltip.prototype.getPosition = function() {
        var el = this.$element[0];
        return $.extend({}, "function" == typeof el.getBoundingClientRect ? el.getBoundingClientRect() : {
            width: el.offsetWidth,
            height: el.offsetHeight
        }, this.$element.offset());
    }, Tooltip.prototype.getCalculatedOffset = function(placement, pos, actualWidth, actualHeight) {
        /* placement == 'right' */
        return "bottom" == placement ? {
            top: pos.top + pos.height,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : "top" == placement ? {
            top: pos.top - actualHeight,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : "left" == placement ? {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left - actualWidth
        } : {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left + pos.width
        };
    }, Tooltip.prototype.getTitle = function() {
        var title, $e = this.$element, o = this.options;
        return title = $e.attr("data-original-title") || ("function" == typeof o.title ? o.title.call($e[0]) : o.title);
    }, Tooltip.prototype.tip = function() {
        return this.$tip = this.$tip || $(this.options.template);
    }, Tooltip.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow");
    }, Tooltip.prototype.validate = function() {
        this.$element[0].parentNode || (this.hide(), this.$element = null, this.options = null);
    }, Tooltip.prototype.enable = function() {
        this.enabled = !0;
    }, Tooltip.prototype.disable = function() {
        this.enabled = !1;
    }, Tooltip.prototype.toggleEnabled = function() {
        this.enabled = !this.enabled;
    }, Tooltip.prototype.toggle = function(e) {
        var self = e ? $(e.currentTarget)[this.type](this.getDelegateOptions()).data("bs." + this.type) : this;
        self.tip().hasClass("in") ? self.leave(self) : self.enter(self);
    }, Tooltip.prototype.destroy = function() {
        this.hide().$element.off("." + this.type).removeData("bs." + this.type);
    };
    // TOOLTIP PLUGIN DEFINITION
    // =========================
    var old = $.fn.tooltip;
    $.fn.tooltip = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.tooltip"), options = "object" == typeof option && option;
            data || $this.data("bs.tooltip", data = new Tooltip(this, options)), "string" == typeof option && data[option]();
        });
    }, $.fn.tooltip.Constructor = Tooltip, // TOOLTIP NO CONFLICT
    // ===================
    $.fn.tooltip.noConflict = function() {
        return $.fn.tooltip = old, this;
    };
}(jQuery), /* ========================================================================
 * Bootstrap: popover.js v3.0.3
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */
+function($) {
    "use strict";
    // POPOVER PUBLIC CLASS DEFINITION
    // ===============================
    var Popover = function(element, options) {
        this.init("popover", element, options);
    };
    if (!$.fn.tooltip) throw new Error("Popover requires tooltip.js");
    Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    }), // NOTE: POPOVER EXTENDS tooltip.js
    // ================================
    Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype), Popover.prototype.constructor = Popover, 
    Popover.prototype.getDefaults = function() {
        return Popover.DEFAULTS;
    }, Popover.prototype.setContent = function() {
        var $tip = this.tip(), title = this.getTitle(), content = this.getContent();
        $tip.find(".popover-title")[this.options.html ? "html" : "text"](title), $tip.find(".popover-content")[this.options.html ? "html" : "text"](content), 
        $tip.removeClass("fade top bottom left right in"), // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
        // this manually by checking the contents.
        $tip.find(".popover-title").html() || $tip.find(".popover-title").hide();
    }, Popover.prototype.hasContent = function() {
        return this.getTitle() || this.getContent();
    }, Popover.prototype.getContent = function() {
        var $e = this.$element, o = this.options;
        return $e.attr("data-content") || ("function" == typeof o.content ? o.content.call($e[0]) : o.content);
    }, Popover.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".arrow");
    }, Popover.prototype.tip = function() {
        return this.$tip || (this.$tip = $(this.options.template)), this.$tip;
    };
    // POPOVER PLUGIN DEFINITION
    // =========================
    var old = $.fn.popover;
    $.fn.popover = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.popover"), options = "object" == typeof option && option;
            data || $this.data("bs.popover", data = new Popover(this, options)), "string" == typeof option && data[option]();
        });
    }, $.fn.popover.Constructor = Popover, // POPOVER NO CONFLICT
    // ===================
    $.fn.popover.noConflict = function() {
        return $.fn.popover = old, this;
    };
}(jQuery), /* ========================================================================
 * Bootstrap: scrollspy.js v3.0.3
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */
+function($) {
    "use strict";
    // SCROLLSPY CLASS DEFINITION
    // ==========================
    function ScrollSpy(element, options) {
        var href, process = $.proxy(this.process, this);
        this.$element = $($(element).is("body") ? window : element), this.$body = $("body"), 
        this.$scrollElement = this.$element.on("scroll.bs.scroll-spy.data-api", process), 
        this.options = $.extend({}, ScrollSpy.DEFAULTS, options), this.selector = (this.options.target || (href = $(element).attr("href")) && href.replace(/.*(?=#[^\s]+$)/, "") || "") + " .nav li > a", 
        this.offsets = $([]), this.targets = $([]), this.activeTarget = null, this.refresh(), 
        this.process();
    }
    ScrollSpy.DEFAULTS = {
        offset: 10
    }, ScrollSpy.prototype.refresh = function() {
        var offsetMethod = this.$element[0] == window ? "offset" : "position";
        this.offsets = $([]), this.targets = $([]);
        var self = this;
        this.$body.find(this.selector).map(function() {
            var $el = $(this), href = $el.data("target") || $el.attr("href"), $href = /^#\w/.test(href) && $(href);
            return $href && $href.length && [ [ $href[offsetMethod]().top + (!$.isWindow(self.$scrollElement.get(0)) && self.$scrollElement.scrollTop()), href ] ] || null;
        }).sort(function(a, b) {
            return a[0] - b[0];
        }).each(function() {
            self.offsets.push(this[0]), self.targets.push(this[1]);
        });
    }, ScrollSpy.prototype.process = function() {
        var i, scrollTop = this.$scrollElement.scrollTop() + this.options.offset, scrollHeight = this.$scrollElement[0].scrollHeight || this.$body[0].scrollHeight, maxScroll = scrollHeight - this.$scrollElement.height(), offsets = this.offsets, targets = this.targets, activeTarget = this.activeTarget;
        if (scrollTop >= maxScroll) return activeTarget != (i = targets.last()[0]) && this.activate(i);
        for (i = offsets.length; i--; ) activeTarget != targets[i] && scrollTop >= offsets[i] && (!offsets[i + 1] || scrollTop <= offsets[i + 1]) && this.activate(targets[i]);
    }, ScrollSpy.prototype.activate = function(target) {
        this.activeTarget = target, $(this.selector).parents(".active").removeClass("active");
        var selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]', active = $(selector).parents("li").addClass("active");
        active.parent(".dropdown-menu").length && (active = active.closest("li.dropdown").addClass("active")), 
        active.trigger("activate.bs.scrollspy");
    };
    // SCROLLSPY PLUGIN DEFINITION
    // ===========================
    var old = $.fn.scrollspy;
    $.fn.scrollspy = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.scrollspy"), options = "object" == typeof option && option;
            data || $this.data("bs.scrollspy", data = new ScrollSpy(this, options)), "string" == typeof option && data[option]();
        });
    }, $.fn.scrollspy.Constructor = ScrollSpy, // SCROLLSPY NO CONFLICT
    // =====================
    $.fn.scrollspy.noConflict = function() {
        return $.fn.scrollspy = old, this;
    }, // SCROLLSPY DATA-API
    // ==================
    $(window).on("load", function() {
        $('[data-spy="scroll"]').each(function() {
            var $spy = $(this);
            $spy.scrollspy($spy.data());
        });
    });
}(jQuery), /* ========================================================================
 * Bootstrap: tab.js v3.0.3
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */
+function($) {
    "use strict";
    // TAB CLASS DEFINITION
    // ====================
    var Tab = function(element) {
        this.element = $(element);
    };
    Tab.prototype.show = function() {
        var $this = this.element, $ul = $this.closest("ul:not(.dropdown-menu)"), selector = $this.data("target");
        if (selector || (selector = $this.attr("href"), selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "")), 
        !$this.parent("li").hasClass("active")) {
            var previous = $ul.find(".active:last a")[0], e = $.Event("show.bs.tab", {
                relatedTarget: previous
            });
            if ($this.trigger(e), !e.isDefaultPrevented()) {
                var $target = $(selector);
                this.activate($this.parent("li"), $ul), this.activate($target, $target.parent(), function() {
                    $this.trigger({
                        type: "shown.bs.tab",
                        relatedTarget: previous
                    });
                });
            }
        }
    }, Tab.prototype.activate = function(element, container, callback) {
        function next() {
            $active.removeClass("active").find("> .dropdown-menu > .active").removeClass("active"), 
            element.addClass("active"), transition ? (element[0].offsetWidth, // reflow for transition
            element.addClass("in")) : element.removeClass("fade"), element.parent(".dropdown-menu") && element.closest("li.dropdown").addClass("active"), 
            callback && callback();
        }
        var $active = container.find("> .active"), transition = callback && $.support.transition && $active.hasClass("fade");
        transition ? $active.one($.support.transition.end, next).emulateTransitionEnd(150) : next(), 
        $active.removeClass("in");
    };
    // TAB PLUGIN DEFINITION
    // =====================
    var old = $.fn.tab;
    $.fn.tab = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.tab");
            data || $this.data("bs.tab", data = new Tab(this)), "string" == typeof option && data[option]();
        });
    }, $.fn.tab.Constructor = Tab, // TAB NO CONFLICT
    // ===============
    $.fn.tab.noConflict = function() {
        return $.fn.tab = old, this;
    }, // TAB DATA-API
    // ============
    $(document).on("click.bs.tab.data-api", '[data-toggle="tab"], [data-toggle="pill"]', function(e) {
        e.preventDefault(), $(this).tab("show");
    });
}(jQuery), /* ========================================================================
 * Bootstrap: affix.js v3.0.3
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */
+function($) {
    "use strict";
    // AFFIX CLASS DEFINITION
    // ======================
    var Affix = function(element, options) {
        this.options = $.extend({}, Affix.DEFAULTS, options), this.$window = $(window).on("scroll.bs.affix.data-api", $.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", $.proxy(this.checkPositionWithEventLoop, this)), 
        this.$element = $(element), this.affixed = this.unpin = null, this.checkPosition();
    };
    Affix.RESET = "affix affix-top affix-bottom", Affix.DEFAULTS = {
        offset: 0
    }, Affix.prototype.checkPositionWithEventLoop = function() {
        setTimeout($.proxy(this.checkPosition, this), 1);
    }, Affix.prototype.checkPosition = function() {
        if (this.$element.is(":visible")) {
            var scrollHeight = $(document).height(), scrollTop = this.$window.scrollTop(), position = this.$element.offset(), offset = this.options.offset, offsetTop = offset.top, offsetBottom = offset.bottom;
            "object" != typeof offset && (offsetBottom = offsetTop = offset), "function" == typeof offsetTop && (offsetTop = offset.top()), 
            "function" == typeof offsetBottom && (offsetBottom = offset.bottom());
            var affix = null != this.unpin && scrollTop + this.unpin <= position.top ? !1 : null != offsetBottom && position.top + this.$element.height() >= scrollHeight - offsetBottom ? "bottom" : null != offsetTop && offsetTop >= scrollTop ? "top" : !1;
            this.affixed !== affix && (this.unpin && this.$element.css("top", ""), this.affixed = affix, 
            this.unpin = "bottom" == affix ? position.top - scrollTop : null, this.$element.removeClass(Affix.RESET).addClass("affix" + (affix ? "-" + affix : "")), 
            "bottom" == affix && this.$element.offset({
                top: document.body.offsetHeight - offsetBottom - this.$element.height()
            }));
        }
    };
    // AFFIX PLUGIN DEFINITION
    // =======================
    var old = $.fn.affix;
    $.fn.affix = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.affix"), options = "object" == typeof option && option;
            data || $this.data("bs.affix", data = new Affix(this, options)), "string" == typeof option && data[option]();
        });
    }, $.fn.affix.Constructor = Affix, // AFFIX NO CONFLICT
    // =================
    $.fn.affix.noConflict = function() {
        return $.fn.affix = old, this;
    }, // AFFIX DATA-API
    // ==============
    $(window).on("load", function() {
        $('[data-spy="affix"]').each(function() {
            var $spy = $(this), data = $spy.data();
            data.offset = data.offset || {}, data.offsetBottom && (data.offset.bottom = data.offsetBottom), 
            data.offsetTop && (data.offset.top = data.offsetTop), $spy.affix(data);
        });
    });
}(jQuery), /*!
 * Bootstrap Colorpicker
 * http://mjolnic.github.io/bootstrap-colorpicker/
 *
 * Originally written by (c) 2012 Stefan Petre
 * Licensed under the Apache License v2.0
 * http://www.apache.org/licenses/LICENSE-2.0.txt
 *
 * @todo Update DOCS
 */
function(factory) {
    "use strict";
    "function" == typeof define && define.amd ? define([ "jquery" ], factory) : window.jQuery && !window.jQuery.fn.colorpicker && factory(window.jQuery);
}(function($) {
    "use strict";
    // Color object
    var Color = function(val) {
        this.value = {
            h: 0,
            s: 0,
            b: 0,
            a: 1
        }, this.origFormat = null, // original string format
        val && (void 0 !== val.toLowerCase ? (val += "", "#" === val.charAt(0) || 3 !== val.length && 6 !== val.length || (val = "#" + val), 
        this.setColor(val)) : void 0 !== val.h && (this.value = val));
    };
    Color.prototype = {
        constructor: Color,
        // 140 predefined colors from the HTML Colors spec
        colors: {
            aliceblue: "#f0f8ff",
            antiquewhite: "#faebd7",
            aqua: "#00ffff",
            aquamarine: "#7fffd4",
            azure: "#f0ffff",
            beige: "#f5f5dc",
            bisque: "#ffe4c4",
            black: "#000000",
            blanchedalmond: "#ffebcd",
            blue: "#0000ff",
            blueviolet: "#8a2be2",
            brown: "#a52a2a",
            burlywood: "#deb887",
            cadetblue: "#5f9ea0",
            chartreuse: "#7fff00",
            chocolate: "#d2691e",
            coral: "#ff7f50",
            cornflowerblue: "#6495ed",
            cornsilk: "#fff8dc",
            crimson: "#dc143c",
            cyan: "#00ffff",
            darkblue: "#00008b",
            darkcyan: "#008b8b",
            darkgoldenrod: "#b8860b",
            darkgray: "#a9a9a9",
            darkgreen: "#006400",
            darkkhaki: "#bdb76b",
            darkmagenta: "#8b008b",
            darkolivegreen: "#556b2f",
            darkorange: "#ff8c00",
            darkorchid: "#9932cc",
            darkred: "#8b0000",
            darksalmon: "#e9967a",
            darkseagreen: "#8fbc8f",
            darkslateblue: "#483d8b",
            darkslategray: "#2f4f4f",
            darkturquoise: "#00ced1",
            darkviolet: "#9400d3",
            deeppink: "#ff1493",
            deepskyblue: "#00bfff",
            dimgray: "#696969",
            dodgerblue: "#1e90ff",
            firebrick: "#b22222",
            floralwhite: "#fffaf0",
            forestgreen: "#228b22",
            fuchsia: "#ff00ff",
            gainsboro: "#dcdcdc",
            ghostwhite: "#f8f8ff",
            gold: "#ffd700",
            goldenrod: "#daa520",
            gray: "#808080",
            green: "#008000",
            greenyellow: "#adff2f",
            honeydew: "#f0fff0",
            hotpink: "#ff69b4",
            "indianred ": "#cd5c5c",
            "indigo ": "#4b0082",
            ivory: "#fffff0",
            khaki: "#f0e68c",
            lavender: "#e6e6fa",
            lavenderblush: "#fff0f5",
            lawngreen: "#7cfc00",
            lemonchiffon: "#fffacd",
            lightblue: "#add8e6",
            lightcoral: "#f08080",
            lightcyan: "#e0ffff",
            lightgoldenrodyellow: "#fafad2",
            lightgrey: "#d3d3d3",
            lightgreen: "#90ee90",
            lightpink: "#ffb6c1",
            lightsalmon: "#ffa07a",
            lightseagreen: "#20b2aa",
            lightskyblue: "#87cefa",
            lightslategray: "#778899",
            lightsteelblue: "#b0c4de",
            lightyellow: "#ffffe0",
            lime: "#00ff00",
            limegreen: "#32cd32",
            linen: "#faf0e6",
            magenta: "#ff00ff",
            maroon: "#800000",
            mediumaquamarine: "#66cdaa",
            mediumblue: "#0000cd",
            mediumorchid: "#ba55d3",
            mediumpurple: "#9370d8",
            mediumseagreen: "#3cb371",
            mediumslateblue: "#7b68ee",
            mediumspringgreen: "#00fa9a",
            mediumturquoise: "#48d1cc",
            mediumvioletred: "#c71585",
            midnightblue: "#191970",
            mintcream: "#f5fffa",
            mistyrose: "#ffe4e1",
            moccasin: "#ffe4b5",
            navajowhite: "#ffdead",
            navy: "#000080",
            oldlace: "#fdf5e6",
            olive: "#808000",
            olivedrab: "#6b8e23",
            orange: "#ffa500",
            orangered: "#ff4500",
            orchid: "#da70d6",
            palegoldenrod: "#eee8aa",
            palegreen: "#98fb98",
            paleturquoise: "#afeeee",
            palevioletred: "#d87093",
            papayawhip: "#ffefd5",
            peachpuff: "#ffdab9",
            peru: "#cd853f",
            pink: "#ffc0cb",
            plum: "#dda0dd",
            powderblue: "#b0e0e6",
            purple: "#800080",
            red: "#ff0000",
            rosybrown: "#bc8f8f",
            royalblue: "#4169e1",
            saddlebrown: "#8b4513",
            salmon: "#fa8072",
            sandybrown: "#f4a460",
            seagreen: "#2e8b57",
            seashell: "#fff5ee",
            sienna: "#a0522d",
            silver: "#c0c0c0",
            skyblue: "#87ceeb",
            slateblue: "#6a5acd",
            slategray: "#708090",
            snow: "#fffafa",
            springgreen: "#00ff7f",
            steelblue: "#4682b4",
            tan: "#d2b48c",
            teal: "#008080",
            thistle: "#d8bfd8",
            tomato: "#ff6347",
            turquoise: "#40e0d0",
            violet: "#ee82ee",
            wheat: "#f5deb3",
            white: "#ffffff",
            whitesmoke: "#f5f5f5",
            yellow: "#ffff00",
            yellowgreen: "#9acd32"
        },
        _sanitizeNumber: function(val) {
            return "number" == typeof val ? val : isNaN(val) || null === val || "" === val || void 0 === val ? 1 : void 0 !== val.toLowerCase ? parseFloat(val) : 1;
        },
        //parse a string to HSB
        setColor: function(strVal) {
            strVal = strVal.toLowerCase(), this.value = this.stringToHSB(strVal) || {
                h: 0,
                s: 0,
                b: 0,
                a: 1
            };
        },
        stringToHSB: function(strVal) {
            strVal = strVal.toLowerCase();
            var that = this, result = !1;
            return $.each(this.stringParsers, function(i, parser) {
                var match = parser.re.exec(strVal), values = match && parser.parse.apply(that, [ match ]), format = parser.format || "rgba";
                return values ? (result = format.match(/hsla?/) ? that.RGBtoHSB.apply(that, that.HSLtoRGB.apply(that, values)) : that.RGBtoHSB.apply(that, values), 
                that.origFormat = format, !1) : !0;
            }), result;
        },
        setHue: function(h) {
            this.value.h = 1 - h;
        },
        setSaturation: function(s) {
            this.value.s = s;
        },
        setBrightness: function(b) {
            this.value.b = 1 - b;
        },
        setAlpha: function(a) {
            this.value.a = parseInt(100 * (1 - a), 10) / 100;
        },
        toRGB: function(h, s, b, a) {
            h || (h = this.value.h, s = this.value.s, b = this.value.b), h *= 360;
            var R, G, B, X, C;
            return h = h % 360 / 60, C = b * s, X = C * (1 - Math.abs(h % 2 - 1)), R = G = B = b - C, 
            h = ~~h, R += [ C, X, 0, 0, X, C ][h], G += [ X, C, C, X, 0, 0 ][h], B += [ 0, 0, X, C, C, X ][h], 
            {
                r: Math.round(255 * R),
                g: Math.round(255 * G),
                b: Math.round(255 * B),
                a: a || this.value.a
            };
        },
        toHex: function(h, s, b, a) {
            var rgb = this.toRGB(h, s, b, a);
            return "#" + (1 << 24 | parseInt(rgb.r) << 16 | parseInt(rgb.g) << 8 | parseInt(rgb.b)).toString(16).substr(1);
        },
        toHSL: function(h, s, b, a) {
            h = h || this.value.h, s = s || this.value.s, b = b || this.value.b, a = a || this.value.a;
            var H = h, L = (2 - s) * b, S = s * b;
            return S /= L > 0 && 1 >= L ? L : 2 - L, L /= 2, S > 1 && (S = 1), {
                h: isNaN(H) ? 0 : H,
                s: isNaN(S) ? 0 : S,
                l: isNaN(L) ? 0 : L,
                a: isNaN(a) ? 0 : a
            };
        },
        toAlias: function(r, g, b, a) {
            var rgb = this.toHex(r, g, b, a);
            for (var alias in this.colors) if (this.colors[alias] == rgb) return alias;
            return !1;
        },
        RGBtoHSB: function(r, g, b, a) {
            r /= 255, g /= 255, b /= 255;
            var H, S, V, C;
            return V = Math.max(r, g, b), C = V - Math.min(r, g, b), H = 0 === C ? null : V === r ? (g - b) / C : V === g ? (b - r) / C + 2 : (r - g) / C + 4, 
            H = (H + 360) % 6 * 60 / 360, S = 0 === C ? 0 : C / V, {
                h: this._sanitizeNumber(H),
                s: S,
                b: V,
                a: this._sanitizeNumber(a)
            };
        },
        HueToRGB: function(p, q, h) {
            return 0 > h ? h += 1 : h > 1 && (h -= 1), 1 > 6 * h ? p + (q - p) * h * 6 : 1 > 2 * h ? q : 2 > 3 * h ? p + (q - p) * (2 / 3 - h) * 6 : p;
        },
        HSLtoRGB: function(h, s, l, a) {
            0 > s && (s = 0);
            var q;
            q = .5 >= l ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q, tr = h + 1 / 3, tg = h, tb = h - 1 / 3, r = Math.round(255 * this.HueToRGB(p, q, tr)), g = Math.round(255 * this.HueToRGB(p, q, tg)), b = Math.round(255 * this.HueToRGB(p, q, tb));
            return [ r, g, b, this._sanitizeNumber(a) ];
        },
        toString: function(format) {
            switch (format = format || "rgba") {
              case "rgb":
                var rgb = this.toRGB();
                return "rgb(" + rgb.r + "," + rgb.g + "," + rgb.b + ")";

              case "rgba":
                var rgb = this.toRGB();
                return "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + rgb.a + ")";

              case "hsl":
                var hsl = this.toHSL();
                return "hsl(" + Math.round(360 * hsl.h) + "," + Math.round(100 * hsl.s) + "%," + Math.round(100 * hsl.l) + "%)";

              case "hsla":
                var hsl = this.toHSL();
                return "hsla(" + Math.round(360 * hsl.h) + "," + Math.round(100 * hsl.s) + "%," + Math.round(100 * hsl.l) + "%," + hsl.a + ")";

              case "hex":
                return this.toHex();

              case "alias":
                return this.toAlias() || this.toHex();

              default:
                return !1;
            }
        },
        // a set of RE's that can match strings and generate color tuples.
        // from John Resig color plugin
        // https://github.com/jquery/jquery-color/
        stringParsers: [ {
            re: /#?([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,
            format: "hex",
            parse: function(execResult) {
                return [ parseInt(execResult[1], 16), parseInt(execResult[2], 16), parseInt(execResult[3], 16), 1 ];
            }
        }, {
            re: /#?([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/,
            format: "hex",
            parse: function(execResult) {
                return [ parseInt(execResult[1] + execResult[1], 16), parseInt(execResult[2] + execResult[2], 16), parseInt(execResult[3] + execResult[3], 16), 1 ];
            }
        }, {
            re: /rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*?\)/,
            format: "rgb",
            parse: function(execResult) {
                return [ execResult[1], execResult[2], execResult[3], 1 ];
            }
        }, {
            re: /rgb\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*?\)/,
            format: "rgb",
            parse: function(execResult) {
                return [ 2.55 * execResult[1], 2.55 * execResult[2], 2.55 * execResult[3], 1 ];
            }
        }, {
            re: /rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
            format: "rgba",
            parse: function(execResult) {
                return [ execResult[1], execResult[2], execResult[3], execResult[4] ];
            }
        }, {
            re: /rgba\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
            format: "rgba",
            parse: function(execResult) {
                return [ 2.55 * execResult[1], 2.55 * execResult[2], 2.55 * execResult[3], execResult[4] ];
            }
        }, {
            re: /hsl\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*?\)/,
            format: "hsl",
            parse: function(execResult) {
                return [ execResult[1] / 360, execResult[2] / 100, execResult[3] / 100, execResult[4] ];
            }
        }, {
            re: /hsla\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
            format: "hsla",
            parse: function(execResult) {
                return [ execResult[1] / 360, execResult[2] / 100, execResult[3] / 100, execResult[4] ];
            }
        }, {
            //predefined color name
            re: /^([a-z]{3,})$/,
            format: "alias",
            parse: function(execResult) {
                var hexval = this.colorNameToHex(execResult[0]) || "#000000", match = this.stringParsers[0].re.exec(hexval), values = match && this.stringParsers[0].parse.apply(this, [ match ]);
                return values;
            }
        } ],
        colorNameToHex: function(name) {
            return "undefined" != typeof this.colors[name.toLowerCase()] ? this.colors[name.toLowerCase()] : !1;
        }
    };
    var defaults = {
        horizontal: !1,
        // horizontal mode layout ?
        inline: !1,
        //forces to show the colorpicker as an inline element
        color: !1,
        //forces a color
        format: !1,
        //forces a format
        input: "input",
        // children input selector
        container: !1,
        // container selector
        component: ".add-on, .input-group-addon",
        // children component selector
        sliders: {
            saturation: {
                maxLeft: 100,
                maxTop: 100,
                callLeft: "setSaturation",
                callTop: "setBrightness"
            },
            hue: {
                maxLeft: 0,
                maxTop: 100,
                callLeft: !1,
                callTop: "setHue"
            },
            alpha: {
                maxLeft: 0,
                maxTop: 100,
                callLeft: !1,
                callTop: "setAlpha"
            }
        },
        slidersHorz: {
            saturation: {
                maxLeft: 100,
                maxTop: 100,
                callLeft: "setSaturation",
                callTop: "setBrightness"
            },
            hue: {
                maxLeft: 100,
                maxTop: 0,
                callLeft: "setHue",
                callTop: !1
            },
            alpha: {
                maxLeft: 100,
                maxTop: 0,
                callLeft: "setAlpha",
                callTop: !1
            }
        },
        template: '<div class="colorpicker dropdown-menu"><div class="colorpicker-saturation"><i><b></b></i></div><div class="colorpicker-hue"><i></i></div><div class="colorpicker-alpha"><i></i></div><div class="colorpicker-color"><div /></div></div>'
    }, Colorpicker = function(element, options) {
        this.element = $(element).addClass("colorpicker-element"), this.options = $.extend({}, defaults, this.element.data(), options), 
        this.component = this.options.component, this.component = this.component !== !1 ? this.element.find(this.component) : !1, 
        this.component && 0 === this.component.length && (this.component = !1), this.container = this.options.container === !0 ? this.element : this.options.container, 
        this.container = this.container !== !1 ? $(this.container) : !1, // Is the element an input? Should we search inside for any input?
        this.input = this.element.is("input") ? this.element : this.options.input ? this.element.find(this.options.input) : !1, 
        this.input && 0 === this.input.length && (this.input = !1), // Set HSB color
        this.color = new Color(this.options.color !== !1 ? this.options.color : this.getValue()), 
        this.format = this.options.format !== !1 ? this.options.format : this.color.origFormat, 
        // Setup picker
        this.picker = $(this.options.template), this.options.inline ? this.picker.addClass("colorpicker-inline colorpicker-visible") : this.picker.addClass("colorpicker-hidden"), 
        this.options.horizontal && this.picker.addClass("colorpicker-horizontal"), ("rgba" === this.format || "hsla" === this.format) && this.picker.addClass("colorpicker-with-alpha"), 
        this.picker.on("mousedown.colorpicker touchstart.colorpicker", $.proxy(this.mousedown, this)), 
        this.picker.appendTo(this.container ? this.container : $("body")), // Bind events
        this.input !== !1 && (this.input.on({
            "keyup.colorpicker": $.proxy(this.keyup, this)
        }), this.component === !1 && this.element.on({
            "focus.colorpicker": $.proxy(this.show, this)
        }), this.options.inline === !1 && this.element.on({
            "focusout.colorpicker": $.proxy(this.hide, this)
        })), this.component !== !1 && this.component.on({
            "click.colorpicker": $.proxy(this.show, this)
        }), this.input === !1 && this.component === !1 && this.element.on({
            "click.colorpicker": $.proxy(this.show, this)
        }), // for HTML5 input[type='color']
        this.input !== !1 && this.component !== !1 && "color" === this.input.attr("type") && this.input.on({
            "click.colorpicker": $.proxy(this.show, this),
            "focus.colorpicker": $.proxy(this.show, this)
        }), this.update(), $($.proxy(function() {
            this.element.trigger("create");
        }, this));
    };
    Colorpicker.version = "2.0.0-beta", Colorpicker.Color = Color, Colorpicker.prototype = {
        constructor: Colorpicker,
        destroy: function() {
            this.picker.remove(), this.element.removeData("colorpicker").off(".colorpicker"), 
            this.input !== !1 && this.input.off(".colorpicker"), this.component !== !1 && this.component.off(".colorpicker"), 
            this.element.removeClass("colorpicker-element"), this.element.trigger({
                type: "destroy"
            });
        },
        reposition: function() {
            if (this.options.inline !== !1 || this.options.container) return !1;
            var type = this.container && this.container[0] !== document.body ? "position" : "offset", offset = this.component ? this.component[type]() : this.element[type]();
            this.picker.css({
                top: offset.top + (this.component ? this.component.outerHeight() : this.element.outerHeight()),
                left: offset.left
            });
        },
        show: function(e) {
            return this.isDisabled() ? !1 : (this.picker.addClass("colorpicker-visible").removeClass("colorpicker-hidden"), 
            this.reposition(), $(window).on("resize.colorpicker", $.proxy(this.reposition, this)), 
            !e || this.hasInput() && "color" !== this.input.attr("type") || e.stopPropagation && e.preventDefault && (e.stopPropagation(), 
            e.preventDefault()), this.options.inline === !1 && $(window.document).on({
                "mousedown.colorpicker": $.proxy(this.hide, this)
            }), void this.element.trigger({
                type: "showPicker",
                color: this.color
            }));
        },
        hide: function() {
            this.picker.addClass("colorpicker-hidden").removeClass("colorpicker-visible"), $(window).off("resize.colorpicker", this.reposition), 
            $(document).off({
                "mousedown.colorpicker": this.hide
            }), this.update(), this.element.trigger({
                type: "hidePicker",
                color: this.color
            });
        },
        updateData: function(val) {
            return val = val || this.color.toString(this.format), this.element.data("color", val), 
            val;
        },
        updateInput: function(val) {
            return val = val || this.color.toString(this.format), this.input !== !1 && this.input.prop("value", val), 
            val;
        },
        updatePicker: function(val) {
            void 0 !== val && (this.color = new Color(val));
            var sl = this.options.horizontal === !1 ? this.options.sliders : this.options.slidersHorz, icns = this.picker.find("i");
            return 0 !== icns.length ? (this.options.horizontal === !1 ? (sl = this.options.sliders, 
            icns.eq(1).css("top", sl.hue.maxTop * (1 - this.color.value.h)).end().eq(2).css("top", sl.alpha.maxTop * (1 - this.color.value.a))) : (sl = this.options.slidersHorz, 
            icns.eq(1).css("left", sl.hue.maxLeft * (1 - this.color.value.h)).end().eq(2).css("left", sl.alpha.maxLeft * (1 - this.color.value.a))), 
            icns.eq(0).css({
                top: sl.saturation.maxTop - this.color.value.b * sl.saturation.maxTop,
                left: this.color.value.s * sl.saturation.maxLeft
            }), this.picker.find(".colorpicker-saturation").css("backgroundColor", this.color.toHex(this.color.value.h, 1, 1, 1)), 
            this.picker.find(".colorpicker-alpha").css("backgroundColor", this.color.toHex()), 
            this.picker.find(".colorpicker-color, .colorpicker-color div").css("backgroundColor", this.color.toString(this.format)), 
            val) : void 0;
        },
        updateComponent: function(val) {
            if (val = val || this.color.toString(this.format), this.component !== !1) {
                var icn = this.component.find("i").eq(0);
                icn.length > 0 ? icn.css({
                    backgroundColor: val
                }) : this.component.css({
                    backgroundColor: val
                });
            }
            return val;
        },
        update: function(force) {
            var val = this.updateComponent();
            // Update input/data only if the current value is not blank
            return (this.getValue(!1) !== !1 || force === !0) && (this.updateInput(val), this.updateData(val)), 
            this.updatePicker(), val;
        },
        setValue: function(val) {
            // set color manually
            this.color = new Color(val), this.update(), this.element.trigger({
                type: "changeColor",
                color: this.color,
                value: val
            });
        },
        getValue: function(defaultValue) {
            defaultValue = void 0 === defaultValue ? "#000000" : defaultValue;
            var val;
            // if not defined or empty, return default
            return val = this.hasInput() ? this.input.val() : this.element.data("color"), (void 0 === val || "" === val || null === val) && (val = defaultValue), 
            val;
        },
        hasInput: function() {
            return this.input !== !1;
        },
        isDisabled: function() {
            return this.hasInput() ? this.input.prop("disabled") === !0 : !1;
        },
        disable: function() {
            return this.hasInput() ? (this.input.prop("disabled", !0), !0) : !1;
        },
        enable: function() {
            return this.hasInput() ? (this.input.prop("disabled", !1), !0) : !1;
        },
        currentSlider: null,
        mousePointer: {
            left: 0,
            top: 0
        },
        mousedown: function(e) {
            e.pageX || e.pageY || !e.originalEvent || (e.pageX = e.originalEvent.touches[0].pageX, 
            e.pageY = e.originalEvent.touches[0].pageY), e.stopPropagation(), e.preventDefault();
            var target = $(e.target), zone = target.closest("div"), sl = this.options.horizontal ? this.options.slidersHorz : this.options.sliders;
            if (!zone.is(".colorpicker")) {
                if (zone.is(".colorpicker-saturation")) this.currentSlider = $.extend({}, sl.saturation); else if (zone.is(".colorpicker-hue")) this.currentSlider = $.extend({}, sl.hue); else {
                    if (!zone.is(".colorpicker-alpha")) return !1;
                    this.currentSlider = $.extend({}, sl.alpha);
                }
                var offset = zone.offset();
                //reference to guide's style
                this.currentSlider.guide = zone.find("i")[0].style, this.currentSlider.left = e.pageX - offset.left, 
                this.currentSlider.top = e.pageY - offset.top, this.mousePointer = {
                    left: e.pageX,
                    top: e.pageY
                }, //trigger mousemove to move the guide to the current position
                $(document).on({
                    "mousemove.colorpicker": $.proxy(this.mousemove, this),
                    "touchmove.colorpicker": $.proxy(this.mousemove, this),
                    "mouseup.colorpicker": $.proxy(this.mouseup, this),
                    "touchend.colorpicker": $.proxy(this.mouseup, this)
                }).trigger("mousemove");
            }
            return !1;
        },
        mousemove: function(e) {
            e.pageX || e.pageY || !e.originalEvent || (e.pageX = e.originalEvent.touches[0].pageX, 
            e.pageY = e.originalEvent.touches[0].pageY), e.stopPropagation(), e.preventDefault();
            var left = Math.max(0, Math.min(this.currentSlider.maxLeft, this.currentSlider.left + ((e.pageX || this.mousePointer.left) - this.mousePointer.left))), top = Math.max(0, Math.min(this.currentSlider.maxTop, this.currentSlider.top + ((e.pageY || this.mousePointer.top) - this.mousePointer.top)));
            return this.currentSlider.guide.left = left + "px", this.currentSlider.guide.top = top + "px", 
            this.currentSlider.callLeft && this.color[this.currentSlider.callLeft].call(this.color, left / this.currentSlider.maxLeft), 
            this.currentSlider.callTop && this.color[this.currentSlider.callTop].call(this.color, top / this.currentSlider.maxTop), 
            this.update(!0), this.element.trigger({
                type: "changeColor",
                color: this.color
            }), !1;
        },
        mouseup: function(e) {
            return e.stopPropagation(), e.preventDefault(), $(document).off({
                "mousemove.colorpicker": this.mousemove,
                "touchmove.colorpicker": this.mousemove,
                "mouseup.colorpicker": this.mouseup,
                "touchend.colorpicker": this.mouseup
            }), !1;
        },
        keyup: function(e) {
            if (38 === e.keyCode) this.color.value.a < 1 && (this.color.value.a = Math.round(100 * (this.color.value.a + .01)) / 100), 
            this.update(!0); else if (40 === e.keyCode) this.color.value.a > 0 && (this.color.value.a = Math.round(100 * (this.color.value.a - .01)) / 100), 
            this.update(!0); else {
                var val = this.input.val();
                this.color = new Color(val), this.getValue(!1) !== !1 && (this.updateData(), this.updateComponent(), 
                this.updatePicker());
            }
            this.element.trigger({
                type: "changeColor",
                color: this.color,
                value: val
            });
        }
    }, $.colorpicker = Colorpicker, $.fn.colorpicker = function(option) {
        var pickerArgs = arguments;
        return this.each(function() {
            var $this = $(this), inst = $this.data("colorpicker"), options = "object" == typeof option ? option : {};
            inst || "string" == typeof option ? "string" == typeof option && inst[option].apply(inst, Array.prototype.slice.call(pickerArgs, 1)) : $this.data("colorpicker", new Colorpicker(this, options));
        });
    }, $.fn.colorpicker.constructor = Colorpicker;
}), /**
 * bootbox.js v4.0.0
 *
 * http://bootboxjs.com/license.txt
 */
window.bootbox = window.bootbox || function a(b, c) {
    "use strict";
    function d(a) {
        var b = s[q.locale];
        return b ? b[a] : s.en[a];
    }
    function e(a, c, d) {
        a.preventDefault();
        var e = b.isFunction(d) && d(a) === !1;
        e || c.modal("hide");
    }
    function f(a) {
        var b, c = 0;
        for (b in a) c++;
        return c;
    }
    function g(a, c) {
        var d = 0;
        b.each(a, function(a, b) {
            c(a, b, d++);
        });
    }
    function h(a) {
        var c, d;
        if ("object" != typeof a) throw new Error("Please supply an object of options");
        if (!a.message) throw new Error("Please specify a message");
        return a = b.extend({}, q, a), a.buttons || (a.buttons = {}), a.backdrop = a.backdrop ? "static" : !1, 
        c = a.buttons, d = f(c), g(c, function(a, e, f) {
            if (b.isFunction(e) && (e = c[a] = {
                callback: e
            }), "object" !== b.type(e)) throw new Error("button with key " + a + " must be an object");
            e.label || (e.label = a), e.className || (e.className = 2 >= d && f === d - 1 ? "btn-primary" : "btn-default");
        }), a;
    }
    function i(a, b) {
        var c = a.length, d = {};
        if (1 > c || c > 2) throw new Error("Invalid argument length");
        return 2 === c || "string" == typeof a[0] ? (d[b[0]] = a[0], d[b[1]] = a[1]) : d = a[0], 
        d;
    }
    function j(a, c, d) {
        return b.extend(!0, {}, a, i(c, d));
    }
    function k(a, b, c) {
        return n(j(m.apply(null, a), b, c), a);
    }
    function l() {
        for (var a = {}, b = 0, c = arguments.length; c > b; b++) {
            var e = arguments[b], f = e.toLowerCase(), g = e.toUpperCase();
            a[f] = {
                label: d(g)
            };
        }
        return a;
    }
    function m() {
        return {
            buttons: l.apply(null, arguments)
        };
    }
    function n(a, b) {
        var d = {};
        return g(b, function(a, b) {
            d[b] = !0;
        }), g(a.buttons, function(a) {
            if (d[a] === c) throw new Error("button key " + a + " is not allowed (options are " + b.join("\n") + ")");
        }), a;
    }
    var o = {
        dialog: "<div class='bootbox modal' tabindex='-1' role='dialog'><div class='modal-dialog'><div class='modal-content'><div class='modal-body'><div class='bootbox-body'></div></div></div></div></div>",
        header: "<div class='modal-header'><h4 class='modal-title'></h4></div>",
        footer: "<div class='modal-footer'></div>",
        closeButton: "<button type='button' class='bootbox-close-button close'>&times;</button>",
        form: "<form class='bootbox-form'></form>",
        inputs: {
            text: "<input class='bootbox-input form-control' autocomplete=off type=text />"
        }
    }, p = b("body"), q = {
        locale: "en",
        backdrop: !0,
        animate: !0,
        className: null,
        closeButton: !0,
        show: !0
    }, r = {};
    r.alert = function() {
        var a;
        if (a = k([ "ok" ], arguments, [ "message", "callback" ]), a.callback && !b.isFunction(a.callback)) throw new Error("alert requires callback property to be a function when provided");
        return a.buttons.ok.callback = a.onEscape = function() {
            return b.isFunction(a.callback) ? a.callback() : !0;
        }, r.dialog(a);
    }, r.confirm = function() {
        var a;
        if (a = k([ "cancel", "confirm" ], arguments, [ "message", "callback" ]), a.buttons.cancel.callback = a.onEscape = function() {
            return a.callback(!1);
        }, a.buttons.confirm.callback = function() {
            return a.callback(!0);
        }, !b.isFunction(a.callback)) throw new Error("confirm requires a callback");
        return r.dialog(a);
    }, r.prompt = function() {
        var a, d, e, f, g, h;
        if (f = b(o.form), d = {
            buttons: l("cancel", "confirm"),
            value: ""
        }, a = n(j(d, arguments, [ "title", "callback" ]), [ "cancel", "confirm" ]), h = a.show === c ? !0 : a.show, 
        a.message = f, a.buttons.cancel.callback = a.onEscape = function() {
            return a.callback(null);
        }, a.buttons.confirm.callback = function() {
            return a.callback(g.val());
        }, a.show = !1, !a.title) throw new Error("prompt requires a title");
        if (!b.isFunction(a.callback)) throw new Error("prompt requires a callback");
        return g = b(o.inputs.text), g.val(a.value), f.append(g), f.on("submit", function(a) {
            a.preventDefault(), e.find(".btn-primary").click();
        }), e = r.dialog(a), e.off("shown.bs.modal"), e.on("shown.bs.modal", function() {
            g.focus();
        }), h === !0 && e.modal("show"), e;
    }, r.dialog = function(a) {
        a = h(a);
        var c = b(o.dialog), d = c.find(".modal-body"), f = a.buttons, i = "", j = {
            onEscape: a.onEscape
        };
        if (g(f, function(a, b) {
            i += "<button data-bb-handler='" + a + "' type='button' class='btn " + b.className + "'>" + b.label + "</button>", 
            j[a] = b.callback;
        }), d.find(".bootbox-body").html(a.message), a.animate === !0 && c.addClass("fade"), 
        a.className && c.addClass(a.className), a.title && d.before(o.header), a.closeButton) {
            var k = b(o.closeButton);
            a.title ? c.find(".modal-header").prepend(k) : k.css("margin-top", "-10px").prependTo(d);
        }
        return a.title && c.find(".modal-title").html(a.title), i.length && (d.after(o.footer), 
        c.find(".modal-footer").html(i)), c.on("hidden.bs.modal", function(a) {
            a.target === this && c.remove();
        }), c.on("shown.bs.modal", function() {
            c.find(".btn-primary:first").focus();
        }), c.on("escape.close.bb", function(a) {
            j.onEscape && e(a, c, j.onEscape);
        }), c.on("click", ".modal-footer button", function(a) {
            var d = b(this).data("bb-handler");
            e(a, c, j[d]);
        }), c.on("click", ".bootbox-close-button", function(a) {
            e(a, c, j.onEscape);
        }), c.on("keyup", function(a) {
            27 === a.which && c.trigger("escape.close.bb");
        }), p.append(c), c.modal({
            backdrop: a.backdrop,
            keyboard: !1,
            show: !1
        }), a.show && c.modal("show"), c;
    }, r.setDefaults = function(a) {
        b.extend(q, a);
    }, r.hideAll = function() {
        b(".bootbox").modal("hide");
    };
    var s = {
        br: {
            OK: "OK",
            CANCEL: "Cancelar",
            CONFIRM: "Sim"
        },
        da: {
            OK: "OK",
            CANCEL: "Annuller",
            CONFIRM: "Accepter"
        },
        de: {
            OK: "OK",
            CANCEL: "Abbrechen",
            CONFIRM: "Akzeptieren"
        },
        en: {
            OK: "OK",
            CANCEL: "Cancel",
            CONFIRM: "OK"
        },
        es: {
            OK: "OK",
            CANCEL: "Cancelar",
            CONFIRM: "Aceptar"
        },
        fi: {
            OK: "OK",
            CANCEL: "Peruuta",
            CONFIRM: "OK"
        },
        fr: {
            OK: "OK",
            CANCEL: "Annuler",
            CONFIRM: "D'accord"
        },
        it: {
            OK: "OK",
            CANCEL: "Annulla",
            CONFIRM: "Conferma"
        },
        nl: {
            OK: "OK",
            CANCEL: "Annuleren",
            CONFIRM: "Accepteren"
        },
        pl: {
            OK: "OK",
            CANCEL: "Anuluj",
            CONFIRM: "Potwierd"
        },
        ru: {
            OK: "OK",
            CANCEL: "",
            CONFIRM: ""
        },
        zh_CN: {
            OK: "OK",
            CANCEL: "",
            CONFIRM: ""
        },
        zh_TW: {
            OK: "OK",
            CANCEL: "",
            CONFIRM: ""
        }
    };
    return r.init = function(c) {
        window.bootbox = a(c || b);
    }, r;
}(window.jQuery), /**
 * Unicorn Admin Template
 * Version 2.2.0
 * Diablo9983 -> diablo9983@gmail.com
 **/
$(function() {
    var ul = $("#sidebar > ul"), ul2 = $("#sidebar > ul > li.open ul");
    // === Resize window related === //
    $(window).on("resize", function() {
        wwidth = $(window).width(), wwidth >= 768 && wwidth <= 991 && ($("#sidebar > ul > li.open ul").attr("style", "").parent().removeClass("open"), 
        ul.css({
            display: "block"
        })), wwidth <= 767 && ($("#sidebar").niceScroll(), $("#sidebar").getNiceScroll().resize(), 
        $(window).scrollTop() > 35 && $("body").addClass("fixed"), $(window).scroll(function() {
            $(window).scrollTop() > 35 ? $("body").addClass("fixed") : $("body").removeClass("fixed");
        })), wwidth > 767 && (ul.css({
            display: "block"
        }), $("body").removeClass("menu-open"), $("#sidebar").attr("style", ""), $("#user-nav > ul").css({
            width: "auto",
            margin: "0"
        }));
    }), $(window).width() <= 767 && ($(window).scrollTop() > 35 && $("body").addClass("fixed"), 
    $(window).scroll(function() {
        $(window).scrollTop() > 35 ? $("body").addClass("fixed") : $("body").removeClass("fixed");
    }), //jPM.on();
    $("#sidebar").niceScroll({
        zindex: "9999"
    }), $("#sidebar").getNiceScroll().resize()), $(window).width() > 767 && ul.css({
        display: "block"
    }), $(window).width() > 767 && $(window).width() < 992 && ul2.css({
        display: "none"
    }), $("#menu-trigger").on("click", function() {
        return $(window).width() <= 767 && ($("body").hasClass("menu-open") ? $("body").removeClass("menu-open") : $("body").addClass("menu-open")), 
        !1;
    }), // === Tooltips === //
    $(".tip").tooltip(), $(".tip-left").tooltip({
        placement: "left"
    }), $(".tip-right").tooltip({
        placement: "right"
    }), $(".tip-top").tooltip({
        placement: "top"
    }), $(".tip-bottom").tooltip({
        placement: "bottom"
    }), // === Style switcher === //
    $("#style-switcher i").click(function() {
        $(this).hasClass("open") ? ($(this).parent().animate({
            right: "-=220"
        }), $(this).removeClass("open")) : ($(this).parent().animate({
            right: "+=220"
        }), $(this).addClass("open")), $(this).toggleClass("icon-arrow-left"), $(this).toggleClass("icon-arrow-right");
    }), $("#style-switcher a").click(function() {
        var style = $(this).attr("href").replace("#", "");
        $(".skin-color").attr("href", "css/unicorn." + style + ".css"), $(this).siblings("a").css({
            "border-color": "transparent"
        }), $(this).css({
            "border-color": "#aaaaaa"
        });
    }), $(document).on("click", ".submenu > a", function(e) {
        e.preventDefault();
        var submenu = $(this).siblings("ul"), li = $(this).parents("li"), submenus = $("#sidebar li.submenu ul"), submenus_parents = $("#sidebar li.submenu");
        li.hasClass("open") ? ($(window).width() > 976 || $(window).width() < 768 ? submenu.slideUp() : submenu.fadeOut(150), 
        li.removeClass("open")) : ($(window).width() > 976 || $(window).width() < 768 ? (submenus.slideUp(), 
        submenu.slideDown()) : (submenus.fadeOut(150), submenu.fadeIn(150)), submenus_parents.removeClass("open"), 
        li.addClass("open")), $("#sidebar").getNiceScroll().resize();
    }), $("#sidebar li.submenu ul").on("mouseleave", function() {
        $(window).width() >= 768 && $(window).width() < 977 && $(this).fadeOut(150).parent().removeClass("open");
    }), $(".go-full-screen").click(function() {
        backdrop = $(".white-backdrop"), wbox = $(this).parents(".widget-box"), /*if($('body > .white-backdrop').length <= 0) {
		 $('<div class="white-backdrop">').appendTo('body');
		 }*/
        wbox.hasClass("widget-full-screen") ? backdrop.fadeIn(200, function() {
            wbox.removeClass("widget-full-screen", function() {
                backdrop.fadeOut(200);
            });
        }) : backdrop.fadeIn(200, function() {
            wbox.addClass("widget-full-screen", function() {
                backdrop.fadeOut(200);
            });
        });
    }), // IE7
    $(function($) {
        $("input[type=text], input[type=password], textarea").bind("focus blur", function() {
            $(this).toggleClass("focus");
        });
    }), //Theme Switcher
    switcherBtn = $("#switcher-button"), switcherPanel = $("#switcher-inner"), switcherBtn.click(function() {
        switcherPanel.hasClass("open") ? (switcherPanel.hide(300), switcherPanel.removeClass("open")) : (switcherPanel.show(300), 
        switcherPanel.addClass("open"));
    }), color = $("body").data("color"), $("#color-style a[data-color=" + color + "]").addClass("active"), 
    $("#color-style a").click(function() {
        var color = $(this).attr("data-color");
        return $(this).parent().find("a").removeClass("active"), $(this).addClass("active"), 
        $("body").attr("data-color", color), !1;
    }), $("body").hasClass("flat") ? $('#layout-type a[data-option="flat"]').addClass("active") : $('#layout-type a[data-option="old"]').addClass("active"), 
    $("#layout-type a").click(function() {
        var type = $(this).attr("data-option");
        return "flat" == type ? $("body").addClass("flat") : $("body").removeClass("flat"), 
        $(this).parent().find("a").removeClass("active"), $(this).addClass("active"), !1;
    });
}), /*! jQuery Timepicker Addon - v1.5.0 - 2014-09-01
* http://trentrichardson.com/examples/timepicker
* Copyright (c) 2014 Trent Richardson; Licensed MIT */
function($) {
    if (/*
	* Lets not redefine timepicker, Prevent "Uncaught RangeError: Maximum call stack size exceeded"
	*/
    $.ui.timepicker = $.ui.timepicker || {}, !$.ui.timepicker.version) {
        /*
	* Extend jQueryUI, get it started with our version number
	*/
        $.extend($.ui, {
            timepicker: {
                version: "1.5.0"
            }
        });
        /* 
	* Timepicker manager.
	* Use the singleton instance of this class, $.timepicker, to interact with the time picker.
	* Settings for (groups of) time pickers are maintained in an instance object,
	* allowing multiple different settings on the same page.
	*/
        var Timepicker = function() {
            this.regional = [], // Available regional settings, indexed by language code
            this.regional[""] = {
                // Default regional settings
                currentText: "Now",
                closeText: "Done",
                amNames: [ "AM", "A" ],
                pmNames: [ "PM", "P" ],
                timeFormat: "HH:mm",
                timeSuffix: "",
                timeOnlyTitle: "Choose Time",
                timeText: "Time",
                hourText: "Hour",
                minuteText: "Minute",
                secondText: "Second",
                millisecText: "Millisecond",
                microsecText: "Microsecond",
                timezoneText: "Time Zone",
                isRTL: !1
            }, this._defaults = {
                // Global defaults for all the datetime picker instances
                showButtonPanel: !0,
                timeOnly: !1,
                timeOnlyShowDate: !1,
                showHour: null,
                showMinute: null,
                showSecond: null,
                showMillisec: null,
                showMicrosec: null,
                showTimezone: null,
                showTime: !0,
                stepHour: 1,
                stepMinute: 1,
                stepSecond: 1,
                stepMillisec: 1,
                stepMicrosec: 1,
                hour: 0,
                minute: 0,
                second: 0,
                millisec: 0,
                microsec: 0,
                timezone: null,
                hourMin: 0,
                minuteMin: 0,
                secondMin: 0,
                millisecMin: 0,
                microsecMin: 0,
                hourMax: 23,
                minuteMax: 59,
                secondMax: 59,
                millisecMax: 999,
                microsecMax: 999,
                minDateTime: null,
                maxDateTime: null,
                maxTime: null,
                minTime: null,
                onSelect: null,
                hourGrid: 0,
                minuteGrid: 0,
                secondGrid: 0,
                millisecGrid: 0,
                microsecGrid: 0,
                alwaysSetTime: !0,
                separator: " ",
                altFieldTimeOnly: !0,
                altTimeFormat: null,
                altSeparator: null,
                altTimeSuffix: null,
                altRedirectFocus: !0,
                pickerTimeFormat: null,
                pickerTimeSuffix: null,
                showTimepicker: !0,
                timezoneList: null,
                addSliderAccess: !1,
                sliderAccessArgs: null,
                controlType: "slider",
                defaultValue: null,
                parse: "strict"
            }, $.extend(this._defaults, this.regional[""]);
        };
        $.extend(Timepicker.prototype, {
            $input: null,
            $altInput: null,
            $timeObj: null,
            inst: null,
            hour_slider: null,
            minute_slider: null,
            second_slider: null,
            millisec_slider: null,
            microsec_slider: null,
            timezone_select: null,
            maxTime: null,
            minTime: null,
            hour: 0,
            minute: 0,
            second: 0,
            millisec: 0,
            microsec: 0,
            timezone: null,
            hourMinOriginal: null,
            minuteMinOriginal: null,
            secondMinOriginal: null,
            millisecMinOriginal: null,
            microsecMinOriginal: null,
            hourMaxOriginal: null,
            minuteMaxOriginal: null,
            secondMaxOriginal: null,
            millisecMaxOriginal: null,
            microsecMaxOriginal: null,
            ampm: "",
            formattedDate: "",
            formattedTime: "",
            formattedDateTime: "",
            timezoneList: null,
            units: [ "hour", "minute", "second", "millisec", "microsec" ],
            support: {},
            control: null,
            /* 
		* Override the default settings for all instances of the time picker.
		* @param  {Object} settings  object - the new settings to use as defaults (anonymous object)
		* @return {Object} the manager object
		*/
            setDefaults: function(settings) {
                return extendRemove(this._defaults, settings || {}), this;
            },
            /*
		* Create a new Timepicker instance
		*/
            _newInst: function($input, opts) {
                var tp_inst = new Timepicker(), inlineSettings = {}, fns = {}, overrides, i;
                for (var attrName in this._defaults) if (this._defaults.hasOwnProperty(attrName)) {
                    var attrValue = $input.attr("time:" + attrName);
                    if (attrValue) try {
                        inlineSettings[attrName] = eval(attrValue);
                    } catch (err) {
                        inlineSettings[attrName] = attrValue;
                    }
                }
                overrides = {
                    beforeShow: function(input, dp_inst) {
                        return $.isFunction(tp_inst._defaults.evnts.beforeShow) ? tp_inst._defaults.evnts.beforeShow.call($input[0], input, dp_inst, tp_inst) : void 0;
                    },
                    onChangeMonthYear: function(year, month, dp_inst) {
                        // Update the time as well : this prevents the time from disappearing from the $input field.
                        tp_inst._updateDateTime(dp_inst), $.isFunction(tp_inst._defaults.evnts.onChangeMonthYear) && tp_inst._defaults.evnts.onChangeMonthYear.call($input[0], year, month, dp_inst, tp_inst);
                    },
                    onClose: function(dateText, dp_inst) {
                        tp_inst.timeDefined === !0 && "" !== $input.val() && tp_inst._updateDateTime(dp_inst), 
                        $.isFunction(tp_inst._defaults.evnts.onClose) && tp_inst._defaults.evnts.onClose.call($input[0], dateText, dp_inst, tp_inst);
                    }
                };
                for (i in overrides) overrides.hasOwnProperty(i) && (fns[i] = opts[i] || null);
                tp_inst._defaults = $.extend({}, this._defaults, inlineSettings, opts, overrides, {
                    evnts: fns,
                    timepicker: tp_inst
                }), tp_inst.amNames = $.map(tp_inst._defaults.amNames, function(val) {
                    return val.toUpperCase();
                }), tp_inst.pmNames = $.map(tp_inst._defaults.pmNames, function(val) {
                    return val.toUpperCase();
                }), // detect which units are supported
                tp_inst.support = detectSupport(tp_inst._defaults.timeFormat + (tp_inst._defaults.pickerTimeFormat ? tp_inst._defaults.pickerTimeFormat : "") + (tp_inst._defaults.altTimeFormat ? tp_inst._defaults.altTimeFormat : "")), 
                // controlType is string - key to our this._controls
                "string" == typeof tp_inst._defaults.controlType ? ("slider" === tp_inst._defaults.controlType && "undefined" == typeof $.ui.slider && (tp_inst._defaults.controlType = "select"), 
                tp_inst.control = tp_inst._controls[tp_inst._defaults.controlType]) : tp_inst.control = tp_inst._defaults.controlType;
                // prep the timezone options
                var timezoneList = [ -720, -660, -600, -570, -540, -480, -420, -360, -300, -270, -240, -210, -180, -120, -60, 0, 60, 120, 180, 210, 240, 270, 300, 330, 345, 360, 390, 420, 480, 525, 540, 570, 600, 630, 660, 690, 720, 765, 780, 840 ];
                null !== tp_inst._defaults.timezoneList && (timezoneList = tp_inst._defaults.timezoneList);
                var tzl = timezoneList.length, tzi = 0, tzv = null;
                if (tzl > 0 && "object" != typeof timezoneList[0]) for (;tzl > tzi; tzi++) tzv = timezoneList[tzi], 
                timezoneList[tzi] = {
                    value: tzv,
                    label: $.timepicker.timezoneOffsetString(tzv, tp_inst.support.iso8601)
                };
                // set the default units
                // datepicker needs minDate/maxDate, timepicker needs minDateTime/maxDateTime..
                return tp_inst._defaults.timezoneList = timezoneList, tp_inst.timezone = null !== tp_inst._defaults.timezone ? $.timepicker.timezoneOffsetNumber(tp_inst._defaults.timezone) : -1 * new Date().getTimezoneOffset(), 
                tp_inst.hour = tp_inst._defaults.hour < tp_inst._defaults.hourMin ? tp_inst._defaults.hourMin : tp_inst._defaults.hour > tp_inst._defaults.hourMax ? tp_inst._defaults.hourMax : tp_inst._defaults.hour, 
                tp_inst.minute = tp_inst._defaults.minute < tp_inst._defaults.minuteMin ? tp_inst._defaults.minuteMin : tp_inst._defaults.minute > tp_inst._defaults.minuteMax ? tp_inst._defaults.minuteMax : tp_inst._defaults.minute, 
                tp_inst.second = tp_inst._defaults.second < tp_inst._defaults.secondMin ? tp_inst._defaults.secondMin : tp_inst._defaults.second > tp_inst._defaults.secondMax ? tp_inst._defaults.secondMax : tp_inst._defaults.second, 
                tp_inst.millisec = tp_inst._defaults.millisec < tp_inst._defaults.millisecMin ? tp_inst._defaults.millisecMin : tp_inst._defaults.millisec > tp_inst._defaults.millisecMax ? tp_inst._defaults.millisecMax : tp_inst._defaults.millisec, 
                tp_inst.microsec = tp_inst._defaults.microsec < tp_inst._defaults.microsecMin ? tp_inst._defaults.microsecMin : tp_inst._defaults.microsec > tp_inst._defaults.microsecMax ? tp_inst._defaults.microsecMax : tp_inst._defaults.microsec, 
                tp_inst.ampm = "", tp_inst.$input = $input, tp_inst._defaults.altField && (tp_inst.$altInput = $(tp_inst._defaults.altField), 
                tp_inst._defaults.altRedirectFocus === !0 && tp_inst.$altInput.css({
                    cursor: "pointer"
                }).focus(function() {
                    $input.trigger("focus");
                })), (0 === tp_inst._defaults.minDate || 0 === tp_inst._defaults.minDateTime) && (tp_inst._defaults.minDate = new Date()), 
                (0 === tp_inst._defaults.maxDate || 0 === tp_inst._defaults.maxDateTime) && (tp_inst._defaults.maxDate = new Date()), 
                void 0 !== tp_inst._defaults.minDate && tp_inst._defaults.minDate instanceof Date && (tp_inst._defaults.minDateTime = new Date(tp_inst._defaults.minDate.getTime())), 
                void 0 !== tp_inst._defaults.minDateTime && tp_inst._defaults.minDateTime instanceof Date && (tp_inst._defaults.minDate = new Date(tp_inst._defaults.minDateTime.getTime())), 
                void 0 !== tp_inst._defaults.maxDate && tp_inst._defaults.maxDate instanceof Date && (tp_inst._defaults.maxDateTime = new Date(tp_inst._defaults.maxDate.getTime())), 
                void 0 !== tp_inst._defaults.maxDateTime && tp_inst._defaults.maxDateTime instanceof Date && (tp_inst._defaults.maxDate = new Date(tp_inst._defaults.maxDateTime.getTime())), 
                tp_inst.$input.bind("focus", function() {
                    tp_inst._onFocus();
                }), tp_inst;
            },
            /*
		* add our sliders to the calendar
		*/
            _addTimePicker: function(dp_inst) {
                var currDT = this.$altInput && this._defaults.altFieldTimeOnly ? this.$input.val() + " " + this.$altInput.val() : this.$input.val();
                this.timeDefined = this._parseTime(currDT), this._limitMinMaxDateTime(dp_inst, !1), 
                this._injectTimePicker();
            },
            /*
		* parse the time string from input value or _setTime
		*/
            _parseTime: function(timeString, withDate) {
                if (this.inst || (this.inst = $.datepicker._getInst(this.$input[0])), withDate || !this._defaults.timeOnly) {
                    var dp_dateFormat = $.datepicker._get(this.inst, "dateFormat");
                    try {
                        var parseRes = parseDateTimeInternal(dp_dateFormat, this._defaults.timeFormat, timeString, $.datepicker._getFormatConfig(this.inst), this._defaults);
                        if (!parseRes.timeObj) return !1;
                        $.extend(this, parseRes.timeObj);
                    } catch (err) {
                        return $.timepicker.log("Error parsing the date/time string: " + err + "\ndate/time string = " + timeString + "\ntimeFormat = " + this._defaults.timeFormat + "\ndateFormat = " + dp_dateFormat), 
                        !1;
                    }
                    return !0;
                }
                var timeObj = $.datepicker.parseTime(this._defaults.timeFormat, timeString, this._defaults);
                return timeObj ? ($.extend(this, timeObj), !0) : !1;
            },
            /*
		* generate and inject html for timepicker into ui datepicker
		*/
            _injectTimePicker: function() {
                var $dp = this.inst.dpDiv, o = this.inst.settings, tp_inst = this, litem = "", uitem = "", show = null, max = {}, gridSize = {}, size = null, i = 0, l = 0;
                // Prevent displaying twice
                if (0 === $dp.find("div.ui-timepicker-div").length && o.showTimepicker) {
                    var noDisplay = ' style="display:none;"', html = '<div class="ui-timepicker-div' + (o.isRTL ? " ui-timepicker-rtl" : "") + '"><dl><dt class="ui_tpicker_time_label"' + (o.showTime ? "" : noDisplay) + ">" + o.timeText + '</dt><dd class="ui_tpicker_time"' + (o.showTime ? "" : noDisplay) + "></dd>";
                    // Create the markup
                    for (i = 0, l = this.units.length; l > i; i++) {
                        if (litem = this.units[i], uitem = litem.substr(0, 1).toUpperCase() + litem.substr(1), 
                        show = null !== o["show" + uitem] ? o["show" + uitem] : this.support[litem], max[litem] = parseInt(o[litem + "Max"] - (o[litem + "Max"] - o[litem + "Min"]) % o["step" + uitem], 10), 
                        gridSize[litem] = 0, html += '<dt class="ui_tpicker_' + litem + '_label"' + (show ? "" : noDisplay) + ">" + o[litem + "Text"] + '</dt><dd class="ui_tpicker_' + litem + '"><div class="ui_tpicker_' + litem + '_slider"' + (show ? "" : noDisplay) + "></div>", 
                        show && o[litem + "Grid"] > 0) {
                            if (html += '<div style="padding-left: 1px"><table class="ui-tpicker-grid-label"><tr>', 
                            "hour" === litem) for (var h = o[litem + "Min"]; h <= max[litem]; h += parseInt(o[litem + "Grid"], 10)) {
                                gridSize[litem]++;
                                var tmph = $.datepicker.formatTime(this.support.ampm ? "hht" : "HH", {
                                    hour: h
                                }, o);
                                html += '<td data-for="' + litem + '">' + tmph + "</td>";
                            } else for (var m = o[litem + "Min"]; m <= max[litem]; m += parseInt(o[litem + "Grid"], 10)) gridSize[litem]++, 
                            html += '<td data-for="' + litem + '">' + (10 > m ? "0" : "") + m + "</td>";
                            html += "</tr></table></div>";
                        }
                        html += "</dd>";
                    }
                    // Timezone
                    var showTz = null !== o.showTimezone ? o.showTimezone : this.support.timezone;
                    html += '<dt class="ui_tpicker_timezone_label"' + (showTz ? "" : noDisplay) + ">" + o.timezoneText + "</dt>", 
                    html += '<dd class="ui_tpicker_timezone" ' + (showTz ? "" : noDisplay) + "></dd>", 
                    // Create the elements from string
                    html += "</dl></div>";
                    var $tp = $(html);
                    // add sliders, adjust grids, add events
                    for (// if we only want time picker...
                    o.timeOnly === !0 && ($tp.prepend('<div class="ui-widget-header ui-helper-clearfix ui-corner-all"><div class="ui-datepicker-title">' + o.timeOnlyTitle + "</div></div>"), 
                    $dp.find(".ui-datepicker-header, .ui-datepicker-calendar").hide()), i = 0, l = tp_inst.units.length; l > i; i++) litem = tp_inst.units[i], 
                    uitem = litem.substr(0, 1).toUpperCase() + litem.substr(1), show = null !== o["show" + uitem] ? o["show" + uitem] : this.support[litem], 
                    tp_inst[litem + "_slider"] = tp_inst.control.create(tp_inst, $tp.find(".ui_tpicker_" + litem + "_slider"), litem, tp_inst[litem], o[litem + "Min"], max[litem], o["step" + uitem]), 
                    show && o[litem + "Grid"] > 0 && (size = 100 * gridSize[litem] * o[litem + "Grid"] / (max[litem] - o[litem + "Min"]), 
                    $tp.find(".ui_tpicker_" + litem + " table").css({
                        width: size + "%",
                        marginLeft: o.isRTL ? "0" : size / (-2 * gridSize[litem]) + "%",
                        marginRight: o.isRTL ? size / (-2 * gridSize[litem]) + "%" : "0",
                        borderCollapse: "collapse"
                    }).find("td").click(function(e) {
                        var $t = $(this), h = $t.html(), n = parseInt(h.replace(/[^0-9]/g), 10), ap = h.replace(/[^apm]/gi), f = $t.data("for");
                        "hour" === f && (-1 !== ap.indexOf("p") && 12 > n ? n += 12 : -1 !== ap.indexOf("a") && 12 === n && (n = 0)), 
                        tp_inst.control.value(tp_inst, tp_inst[f + "_slider"], litem, n), tp_inst._onTimeChange(), 
                        tp_inst._onSelectHandler();
                    }).css({
                        cursor: "pointer",
                        width: 100 / gridSize[litem] + "%",
                        textAlign: "center",
                        overflow: "hidden"
                    }));
                    if (// end for loop
                    // Add timezone options
                    this.timezone_select = $tp.find(".ui_tpicker_timezone").append("<select></select>").find("select"), 
                    $.fn.append.apply(this.timezone_select, $.map(o.timezoneList, function(val, idx) {
                        return $("<option />").val("object" == typeof val ? val.value : val).text("object" == typeof val ? val.label : val);
                    })), "undefined" != typeof this.timezone && null !== this.timezone && "" !== this.timezone) {
                        var local_timezone = -1 * new Date(this.inst.selectedYear, this.inst.selectedMonth, this.inst.selectedDay, 12).getTimezoneOffset();
                        local_timezone === this.timezone ? selectLocalTimezone(tp_inst) : this.timezone_select.val(this.timezone);
                    } else "undefined" != typeof this.hour && null !== this.hour && "" !== this.hour ? this.timezone_select.val(o.timezone) : selectLocalTimezone(tp_inst);
                    this.timezone_select.change(function() {
                        tp_inst._onTimeChange(), tp_inst._onSelectHandler();
                    });
                    // End timezone options
                    // inject timepicker into datepicker
                    var $buttonPanel = $dp.find(".ui-datepicker-buttonpane");
                    if ($buttonPanel.length ? $buttonPanel.before($tp) : $dp.append($tp), this.$timeObj = $tp.find(".ui_tpicker_time"), 
                    null !== this.inst) {
                        var timeDefined = this.timeDefined;
                        this._onTimeChange(), this.timeDefined = timeDefined;
                    }
                    // slideAccess integration: http://trentrichardson.com/2011/11/11/jquery-ui-sliders-and-touch-accessibility/
                    if (this._defaults.addSliderAccess) {
                        var sliderAccessArgs = this._defaults.sliderAccessArgs, rtl = this._defaults.isRTL;
                        sliderAccessArgs.isRTL = rtl, setTimeout(function() {
                            // fix for inline mode
                            if (0 === $tp.find(".ui-slider-access").length) {
                                $tp.find(".ui-slider:visible").sliderAccess(sliderAccessArgs);
                                // fix any grids since sliders are shorter
                                var sliderAccessWidth = $tp.find(".ui-slider-access:eq(0)").outerWidth(!0);
                                sliderAccessWidth && $tp.find("table:visible").each(function() {
                                    var $g = $(this), oldWidth = $g.outerWidth(), oldMarginLeft = $g.css(rtl ? "marginRight" : "marginLeft").toString().replace("%", ""), newWidth = oldWidth - sliderAccessWidth, newMarginLeft = oldMarginLeft * newWidth / oldWidth + "%", css = {
                                        width: newWidth,
                                        marginRight: 0,
                                        marginLeft: 0
                                    };
                                    css[rtl ? "marginRight" : "marginLeft"] = newMarginLeft, $g.css(css);
                                });
                            }
                        }, 10);
                    }
                    // end slideAccess integration
                    tp_inst._limitMinMaxDateTime(this.inst, !0);
                }
            },
            /*
		* This function tries to limit the ability to go outside the
		* min/max date range
		*/
            _limitMinMaxDateTime: function(dp_inst, adjustSliders) {
                var o = this._defaults, dp_date = new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay);
                if (this._defaults.showTimepicker) {
                    // No time so nothing to check here
                    if (null !== $.datepicker._get(dp_inst, "minDateTime") && void 0 !== $.datepicker._get(dp_inst, "minDateTime") && dp_date) {
                        var minDateTime = $.datepicker._get(dp_inst, "minDateTime"), minDateTimeDate = new Date(minDateTime.getFullYear(), minDateTime.getMonth(), minDateTime.getDate(), 0, 0, 0, 0);
                        (null === this.hourMinOriginal || null === this.minuteMinOriginal || null === this.secondMinOriginal || null === this.millisecMinOriginal || null === this.microsecMinOriginal) && (this.hourMinOriginal = o.hourMin, 
                        this.minuteMinOriginal = o.minuteMin, this.secondMinOriginal = o.secondMin, this.millisecMinOriginal = o.millisecMin, 
                        this.microsecMinOriginal = o.microsecMin), dp_inst.settings.timeOnly || minDateTimeDate.getTime() === dp_date.getTime() ? (this._defaults.hourMin = minDateTime.getHours(), 
                        this.hour <= this._defaults.hourMin ? (this.hour = this._defaults.hourMin, this._defaults.minuteMin = minDateTime.getMinutes(), 
                        this.minute <= this._defaults.minuteMin ? (this.minute = this._defaults.minuteMin, 
                        this._defaults.secondMin = minDateTime.getSeconds(), this.second <= this._defaults.secondMin ? (this.second = this._defaults.secondMin, 
                        this._defaults.millisecMin = minDateTime.getMilliseconds(), this.millisec <= this._defaults.millisecMin ? (this.millisec = this._defaults.millisecMin, 
                        this._defaults.microsecMin = minDateTime.getMicroseconds()) : (this.microsec < this._defaults.microsecMin && (this.microsec = this._defaults.microsecMin), 
                        this._defaults.microsecMin = this.microsecMinOriginal)) : (this._defaults.millisecMin = this.millisecMinOriginal, 
                        this._defaults.microsecMin = this.microsecMinOriginal)) : (this._defaults.secondMin = this.secondMinOriginal, 
                        this._defaults.millisecMin = this.millisecMinOriginal, this._defaults.microsecMin = this.microsecMinOriginal)) : (this._defaults.minuteMin = this.minuteMinOriginal, 
                        this._defaults.secondMin = this.secondMinOriginal, this._defaults.millisecMin = this.millisecMinOriginal, 
                        this._defaults.microsecMin = this.microsecMinOriginal)) : (this._defaults.hourMin = this.hourMinOriginal, 
                        this._defaults.minuteMin = this.minuteMinOriginal, this._defaults.secondMin = this.secondMinOriginal, 
                        this._defaults.millisecMin = this.millisecMinOriginal, this._defaults.microsecMin = this.microsecMinOriginal);
                    }
                    if (null !== $.datepicker._get(dp_inst, "maxDateTime") && void 0 !== $.datepicker._get(dp_inst, "maxDateTime") && dp_date) {
                        var maxDateTime = $.datepicker._get(dp_inst, "maxDateTime"), maxDateTimeDate = new Date(maxDateTime.getFullYear(), maxDateTime.getMonth(), maxDateTime.getDate(), 0, 0, 0, 0);
                        (null === this.hourMaxOriginal || null === this.minuteMaxOriginal || null === this.secondMaxOriginal || null === this.millisecMaxOriginal) && (this.hourMaxOriginal = o.hourMax, 
                        this.minuteMaxOriginal = o.minuteMax, this.secondMaxOriginal = o.secondMax, this.millisecMaxOriginal = o.millisecMax, 
                        this.microsecMaxOriginal = o.microsecMax), dp_inst.settings.timeOnly || maxDateTimeDate.getTime() === dp_date.getTime() ? (this._defaults.hourMax = maxDateTime.getHours(), 
                        this.hour >= this._defaults.hourMax ? (this.hour = this._defaults.hourMax, this._defaults.minuteMax = maxDateTime.getMinutes(), 
                        this.minute >= this._defaults.minuteMax ? (this.minute = this._defaults.minuteMax, 
                        this._defaults.secondMax = maxDateTime.getSeconds(), this.second >= this._defaults.secondMax ? (this.second = this._defaults.secondMax, 
                        this._defaults.millisecMax = maxDateTime.getMilliseconds(), this.millisec >= this._defaults.millisecMax ? (this.millisec = this._defaults.millisecMax, 
                        this._defaults.microsecMax = maxDateTime.getMicroseconds()) : (this.microsec > this._defaults.microsecMax && (this.microsec = this._defaults.microsecMax), 
                        this._defaults.microsecMax = this.microsecMaxOriginal)) : (this._defaults.millisecMax = this.millisecMaxOriginal, 
                        this._defaults.microsecMax = this.microsecMaxOriginal)) : (this._defaults.secondMax = this.secondMaxOriginal, 
                        this._defaults.millisecMax = this.millisecMaxOriginal, this._defaults.microsecMax = this.microsecMaxOriginal)) : (this._defaults.minuteMax = this.minuteMaxOriginal, 
                        this._defaults.secondMax = this.secondMaxOriginal, this._defaults.millisecMax = this.millisecMaxOriginal, 
                        this._defaults.microsecMax = this.microsecMaxOriginal)) : (this._defaults.hourMax = this.hourMaxOriginal, 
                        this._defaults.minuteMax = this.minuteMaxOriginal, this._defaults.secondMax = this.secondMaxOriginal, 
                        this._defaults.millisecMax = this.millisecMaxOriginal, this._defaults.microsecMax = this.microsecMaxOriginal);
                    }
                    if (null !== dp_inst.settings.minTime) {
                        var tempMinTime = new Date("01/01/1970 " + dp_inst.settings.minTime);
                        this.hour < tempMinTime.getHours() ? (this.hour = this._defaults.hourMin = tempMinTime.getHours(), 
                        this.minute = this._defaults.minuteMin = tempMinTime.getMinutes()) : this.hour === tempMinTime.getHours() && this.minute < tempMinTime.getMinutes() ? this.minute = this._defaults.minuteMin = tempMinTime.getMinutes() : this._defaults.hourMin < tempMinTime.getHours() ? (this._defaults.hourMin = tempMinTime.getHours(), 
                        this._defaults.minuteMin = tempMinTime.getMinutes()) : this._defaults.hourMin === tempMinTime.getHours() === this.hour && this._defaults.minuteMin < tempMinTime.getMinutes() ? this._defaults.minuteMin = tempMinTime.getMinutes() : this._defaults.minuteMin = 0;
                    }
                    if (null !== dp_inst.settings.maxTime) {
                        var tempMaxTime = new Date("01/01/1970 " + dp_inst.settings.maxTime);
                        this.hour > tempMaxTime.getHours() ? (this.hour = this._defaults.hourMax = tempMaxTime.getHours(), 
                        this.minute = this._defaults.minuteMax = tempMaxTime.getMinutes()) : this.hour === tempMaxTime.getHours() && this.minute > tempMaxTime.getMinutes() ? this.minute = this._defaults.minuteMax = tempMaxTime.getMinutes() : this._defaults.hourMax > tempMaxTime.getHours() ? (this._defaults.hourMax = tempMaxTime.getHours(), 
                        this._defaults.minuteMax = tempMaxTime.getMinutes()) : this._defaults.hourMax === tempMaxTime.getHours() === this.hour && this._defaults.minuteMax > tempMaxTime.getMinutes() ? this._defaults.minuteMax = tempMaxTime.getMinutes() : this._defaults.minuteMax = 59;
                    }
                    if (void 0 !== adjustSliders && adjustSliders === !0) {
                        var hourMax = parseInt(this._defaults.hourMax - (this._defaults.hourMax - this._defaults.hourMin) % this._defaults.stepHour, 10), minMax = parseInt(this._defaults.minuteMax - (this._defaults.minuteMax - this._defaults.minuteMin) % this._defaults.stepMinute, 10), secMax = parseInt(this._defaults.secondMax - (this._defaults.secondMax - this._defaults.secondMin) % this._defaults.stepSecond, 10), millisecMax = parseInt(this._defaults.millisecMax - (this._defaults.millisecMax - this._defaults.millisecMin) % this._defaults.stepMillisec, 10), microsecMax = parseInt(this._defaults.microsecMax - (this._defaults.microsecMax - this._defaults.microsecMin) % this._defaults.stepMicrosec, 10);
                        this.hour_slider && (this.control.options(this, this.hour_slider, "hour", {
                            min: this._defaults.hourMin,
                            max: hourMax,
                            step: this._defaults.stepHour
                        }), this.control.value(this, this.hour_slider, "hour", this.hour - this.hour % this._defaults.stepHour)), 
                        this.minute_slider && (this.control.options(this, this.minute_slider, "minute", {
                            min: this._defaults.minuteMin,
                            max: minMax,
                            step: this._defaults.stepMinute
                        }), this.control.value(this, this.minute_slider, "minute", this.minute - this.minute % this._defaults.stepMinute)), 
                        this.second_slider && (this.control.options(this, this.second_slider, "second", {
                            min: this._defaults.secondMin,
                            max: secMax,
                            step: this._defaults.stepSecond
                        }), this.control.value(this, this.second_slider, "second", this.second - this.second % this._defaults.stepSecond)), 
                        this.millisec_slider && (this.control.options(this, this.millisec_slider, "millisec", {
                            min: this._defaults.millisecMin,
                            max: millisecMax,
                            step: this._defaults.stepMillisec
                        }), this.control.value(this, this.millisec_slider, "millisec", this.millisec - this.millisec % this._defaults.stepMillisec)), 
                        this.microsec_slider && (this.control.options(this, this.microsec_slider, "microsec", {
                            min: this._defaults.microsecMin,
                            max: microsecMax,
                            step: this._defaults.stepMicrosec
                        }), this.control.value(this, this.microsec_slider, "microsec", this.microsec - this.microsec % this._defaults.stepMicrosec));
                    }
                }
            },
            /*
		* when a slider moves, set the internal time...
		* on time change is also called when the time is updated in the text field
		*/
            _onTimeChange: function() {
                if (this._defaults.showTimepicker) {
                    var hour = this.hour_slider ? this.control.value(this, this.hour_slider, "hour") : !1, minute = this.minute_slider ? this.control.value(this, this.minute_slider, "minute") : !1, second = this.second_slider ? this.control.value(this, this.second_slider, "second") : !1, millisec = this.millisec_slider ? this.control.value(this, this.millisec_slider, "millisec") : !1, microsec = this.microsec_slider ? this.control.value(this, this.microsec_slider, "microsec") : !1, timezone = this.timezone_select ? this.timezone_select.val() : !1, o = this._defaults, pickerTimeFormat = o.pickerTimeFormat || o.timeFormat, pickerTimeSuffix = o.pickerTimeSuffix || o.timeSuffix;
                    "object" == typeof hour && (hour = !1), "object" == typeof minute && (minute = !1), 
                    "object" == typeof second && (second = !1), "object" == typeof millisec && (millisec = !1), 
                    "object" == typeof microsec && (microsec = !1), "object" == typeof timezone && (timezone = !1), 
                    hour !== !1 && (hour = parseInt(hour, 10)), minute !== !1 && (minute = parseInt(minute, 10)), 
                    second !== !1 && (second = parseInt(second, 10)), millisec !== !1 && (millisec = parseInt(millisec, 10)), 
                    microsec !== !1 && (microsec = parseInt(microsec, 10)), timezone !== !1 && (timezone = timezone.toString());
                    var ampm = o[12 > hour ? "amNames" : "pmNames"][0], hasChanged = hour !== parseInt(this.hour, 10) || minute !== parseInt(this.minute, 10) || second !== parseInt(this.second, 10) || millisec !== parseInt(this.millisec, 10) || microsec !== parseInt(this.microsec, 10) || this.ampm.length > 0 && 12 > hour != (-1 !== $.inArray(this.ampm.toUpperCase(), this.amNames)) || null !== this.timezone && timezone !== this.timezone.toString();
                    hasChanged && (hour !== !1 && (this.hour = hour), minute !== !1 && (this.minute = minute), 
                    second !== !1 && (this.second = second), millisec !== !1 && (this.millisec = millisec), 
                    microsec !== !1 && (this.microsec = microsec), timezone !== !1 && (this.timezone = timezone), 
                    this.inst || (this.inst = $.datepicker._getInst(this.$input[0])), this._limitMinMaxDateTime(this.inst, !0)), 
                    this.support.ampm && (this.ampm = ampm), // Updates the time within the timepicker
                    this.formattedTime = $.datepicker.formatTime(o.timeFormat, this, o), this.$timeObj && (pickerTimeFormat === o.timeFormat ? this.$timeObj.text(this.formattedTime + pickerTimeSuffix) : this.$timeObj.text($.datepicker.formatTime(pickerTimeFormat, this, o) + pickerTimeSuffix)), 
                    this.timeDefined = !0, hasChanged && this._updateDateTime();
                }
            },
            /*
		* call custom onSelect.
		* bind to sliders slidestop, and grid click.
		*/
            _onSelectHandler: function() {
                var onSelect = this._defaults.onSelect || this.inst.settings.onSelect, inputEl = this.$input ? this.$input[0] : null;
                onSelect && inputEl && onSelect.apply(inputEl, [ this.formattedDateTime, this ]);
            },
            /*
		* update our input with the new date time..
		*/
            _updateDateTime: function(dp_inst) {
                dp_inst = this.inst || dp_inst;
                var dtTmp = dp_inst.currentYear > 0 ? new Date(dp_inst.currentYear, dp_inst.currentMonth, dp_inst.currentDay) : new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay), dt = $.datepicker._daylightSavingAdjust(dtTmp), //dt = $.datepicker._daylightSavingAdjust(new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay)),
                //dt = $.datepicker._daylightSavingAdjust(new Date(dp_inst.currentYear, dp_inst.currentMonth, dp_inst.currentDay)),
                dateFmt = $.datepicker._get(dp_inst, "dateFormat"), formatCfg = $.datepicker._getFormatConfig(dp_inst), timeAvailable = null !== dt && this.timeDefined;
                this.formattedDate = $.datepicker.formatDate(dateFmt, null === dt ? new Date() : dt, formatCfg);
                var formattedDateTime = this.formattedDate;
                if (// if a slider was changed but datepicker doesn't have a value yet, set it
                "" === dp_inst.lastVal && (dp_inst.currentYear = dp_inst.selectedYear, dp_inst.currentMonth = dp_inst.selectedMonth, 
                dp_inst.currentDay = dp_inst.selectedDay), /*
			* remove following lines to force every changes in date picker to change the input value
			* Bug descriptions: when an input field has a default value, and click on the field to pop up the date picker. 
			* If the user manually empty the value in the input field, the date picker will never change selected value.
			*/
                //if (dp_inst.lastVal !== undefined && (dp_inst.lastVal.length > 0 && this.$input.val().length === 0)) {
                //	return;
                //}
                this._defaults.timeOnly === !0 && this._defaults.timeOnlyShowDate === !1 ? formattedDateTime = this.formattedTime : (this._defaults.timeOnly !== !0 && (this._defaults.alwaysSetTime || timeAvailable) || this._defaults.timeOnly === !0 && this._defaults.timeOnlyShowDate === !0) && (formattedDateTime += this._defaults.separator + this.formattedTime + this._defaults.timeSuffix), 
                this.formattedDateTime = formattedDateTime, this._defaults.showTimepicker) if (this.$altInput && this._defaults.timeOnly === !1 && this._defaults.altFieldTimeOnly === !0) this.$altInput.val(this.formattedTime), 
                this.$input.val(this.formattedDate); else if (this.$altInput) {
                    this.$input.val(formattedDateTime);
                    var altFormattedDateTime = "", altSeparator = null !== this._defaults.altSeparator ? this._defaults.altSeparator : this._defaults.separator, altTimeSuffix = null !== this._defaults.altTimeSuffix ? this._defaults.altTimeSuffix : this._defaults.timeSuffix;
                    this._defaults.timeOnly || (altFormattedDateTime = this._defaults.altFormat ? $.datepicker.formatDate(this._defaults.altFormat, null === dt ? new Date() : dt, formatCfg) : this.formattedDate, 
                    altFormattedDateTime && (altFormattedDateTime += altSeparator)), altFormattedDateTime += null !== this._defaults.altTimeFormat ? $.datepicker.formatTime(this._defaults.altTimeFormat, this, this._defaults) + altTimeSuffix : this.formattedTime + altTimeSuffix, 
                    this.$altInput.val(altFormattedDateTime);
                } else this.$input.val(formattedDateTime); else this.$input.val(this.formattedDate);
                this.$input.trigger("change");
            },
            _onFocus: function() {
                if (!this.$input.val() && this._defaults.defaultValue) {
                    this.$input.val(this._defaults.defaultValue);
                    var inst = $.datepicker._getInst(this.$input.get(0)), tp_inst = $.datepicker._get(inst, "timepicker");
                    if (tp_inst && tp_inst._defaults.timeOnly && inst.input.val() !== inst.lastVal) try {
                        $.datepicker._updateDatepicker(inst);
                    } catch (err) {
                        $.timepicker.log(err);
                    }
                }
            },
            /*
		* Small abstraction to control types
		* We can add more, just be sure to follow the pattern: create, options, value
		*/
            _controls: {
                // slider methods
                slider: {
                    create: function(tp_inst, obj, unit, val, min, max, step) {
                        var rtl = tp_inst._defaults.isRTL;
                        // if rtl go -60->0 instead of 0->60
                        return obj.prop("slide", null).slider({
                            orientation: "horizontal",
                            value: rtl ? -1 * val : val,
                            min: rtl ? -1 * max : min,
                            max: rtl ? -1 * min : max,
                            step: step,
                            slide: function(event, ui) {
                                tp_inst.control.value(tp_inst, $(this), unit, rtl ? -1 * ui.value : ui.value), tp_inst._onTimeChange();
                            },
                            stop: function(event, ui) {
                                tp_inst._onSelectHandler();
                            }
                        });
                    },
                    options: function(tp_inst, obj, unit, opts, val) {
                        if (tp_inst._defaults.isRTL) {
                            if ("string" == typeof opts) return "min" === opts || "max" === opts ? void 0 !== val ? obj.slider(opts, -1 * val) : Math.abs(obj.slider(opts)) : obj.slider(opts);
                            var min = opts.min, max = opts.max;
                            return opts.min = opts.max = null, void 0 !== min && (opts.max = -1 * min), void 0 !== max && (opts.min = -1 * max), 
                            obj.slider(opts);
                        }
                        return "string" == typeof opts && void 0 !== val ? obj.slider(opts, val) : obj.slider(opts);
                    },
                    value: function(tp_inst, obj, unit, val) {
                        return tp_inst._defaults.isRTL ? void 0 !== val ? obj.slider("value", -1 * val) : Math.abs(obj.slider("value")) : void 0 !== val ? obj.slider("value", val) : obj.slider("value");
                    }
                },
                // select methods
                select: {
                    create: function(tp_inst, obj, unit, val, min, max, step) {
                        for (var sel = '<select class="ui-timepicker-select ui-state-default ui-corner-all" data-unit="' + unit + '" data-min="' + min + '" data-max="' + max + '" data-step="' + step + '">', format = tp_inst._defaults.pickerTimeFormat || tp_inst._defaults.timeFormat, i = min; max >= i; i += step) sel += '<option value="' + i + '"' + (i === val ? " selected" : "") + ">", 
                        sel += "hour" === unit ? $.datepicker.formatTime($.trim(format.replace(/[^ht ]/gi, "")), {
                            hour: i
                        }, tp_inst._defaults) : "millisec" === unit || "microsec" === unit || i >= 10 ? i : "0" + i.toString(), 
                        sel += "</option>";
                        return sel += "</select>", obj.children("select").remove(), $(sel).appendTo(obj).change(function(e) {
                            tp_inst._onTimeChange(), tp_inst._onSelectHandler();
                        }), obj;
                    },
                    options: function(tp_inst, obj, unit, opts, val) {
                        var o = {}, $t = obj.children("select");
                        if ("string" == typeof opts) {
                            if (void 0 === val) return $t.data(opts);
                            o[opts] = val;
                        } else o = opts;
                        return tp_inst.control.create(tp_inst, obj, $t.data("unit"), $t.val(), o.min || $t.data("min"), o.max || $t.data("max"), o.step || $t.data("step"));
                    },
                    value: function(tp_inst, obj, unit, val) {
                        var $t = obj.children("select");
                        return void 0 !== val ? $t.val(val) : $t.val();
                    }
                }
            }
        }), $.fn.extend({
            /*
		* shorthand just to use timepicker.
		*/
            timepicker: function(o) {
                o = o || {};
                var tmp_args = Array.prototype.slice.call(arguments);
                return "object" == typeof o && (tmp_args[0] = $.extend(o, {
                    timeOnly: !0
                })), $(this).each(function() {
                    $.fn.datetimepicker.apply($(this), tmp_args);
                });
            },
            /*
		* extend timepicker to datepicker
		*/
            datetimepicker: function(o) {
                o = o || {};
                var tmp_args = arguments;
                return "string" == typeof o ? "getDate" === o || "option" === o && 2 === tmp_args.length && "string" == typeof tmp_args[1] ? $.fn.datepicker.apply($(this[0]), tmp_args) : this.each(function() {
                    var $t = $(this);
                    $t.datepicker.apply($t, tmp_args);
                }) : this.each(function() {
                    var $t = $(this);
                    $t.datepicker($.timepicker._newInst($t, o)._defaults);
                });
            }
        }), /*
	* Public Utility to parse date and time
	*/
        $.datepicker.parseDateTime = function(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
            var parseRes = parseDateTimeInternal(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings);
            if (parseRes.timeObj) {
                var t = parseRes.timeObj;
                parseRes.date.setHours(t.hour, t.minute, t.second, t.millisec), parseRes.date.setMicroseconds(t.microsec);
            }
            return parseRes.date;
        }, /*
	* Public utility to parse time
	*/
        $.datepicker.parseTime = function(timeFormat, timeString, options) {
            var o = extendRemove(extendRemove({}, $.timepicker._defaults), options || {}), strictParse = (-1 !== timeFormat.replace(/\'.*?\'/g, "").indexOf("Z"), 
            function(f, s, o) {
                // pattern for standard and localized AM/PM markers
                var treg, getPatternAmpm = function(amNames, pmNames) {
                    var markers = [];
                    return amNames && $.merge(markers, amNames), pmNames && $.merge(markers, pmNames), 
                    markers = $.map(markers, function(val) {
                        return val.replace(/[.*+?|()\[\]{}\\]/g, "\\$&");
                    }), "(" + markers.join("|") + ")?";
                }, getFormatPositions = function(timeFormat) {
                    var finds = timeFormat.toLowerCase().match(/(h{1,2}|m{1,2}|s{1,2}|l{1}|c{1}|t{1,2}|z|'.*?')/g), orders = {
                        h: -1,
                        m: -1,
                        s: -1,
                        l: -1,
                        c: -1,
                        t: -1,
                        z: -1
                    };
                    if (finds) for (var i = 0; i < finds.length; i++) -1 === orders[finds[i].toString().charAt(0)] && (orders[finds[i].toString().charAt(0)] = i + 1);
                    return orders;
                }, regstr = "^" + f.toString().replace(/([hH]{1,2}|mm?|ss?|[tT]{1,2}|[zZ]|[lc]|'.*?')/g, function(match) {
                    var ml = match.length;
                    switch (match.charAt(0).toLowerCase()) {
                      case "h":
                        return 1 === ml ? "(\\d?\\d)" : "(\\d{" + ml + "})";

                      case "m":
                        return 1 === ml ? "(\\d?\\d)" : "(\\d{" + ml + "})";

                      case "s":
                        return 1 === ml ? "(\\d?\\d)" : "(\\d{" + ml + "})";

                      case "l":
                        return "(\\d?\\d?\\d)";

                      case "c":
                        return "(\\d?\\d?\\d)";

                      case "z":
                        return "(z|[-+]\\d\\d:?\\d\\d|\\S+)?";

                      case "t":
                        return getPatternAmpm(o.amNames, o.pmNames);

                      default:
                        // literal escaped in quotes
                        return "(" + match.replace(/\'/g, "").replace(/(\.|\$|\^|\\|\/|\(|\)|\[|\]|\?|\+|\*)/g, function(m) {
                            return "\\" + m;
                        }) + ")?";
                    }
                }).replace(/\s/g, "\\s?") + o.timeSuffix + "$", order = getFormatPositions(f), ampm = "";
                treg = s.match(new RegExp(regstr, "i"));
                var resTime = {
                    hour: 0,
                    minute: 0,
                    second: 0,
                    millisec: 0,
                    microsec: 0
                };
                return treg ? (-1 !== order.t && (void 0 === treg[order.t] || 0 === treg[order.t].length ? (ampm = "", 
                resTime.ampm = "") : (ampm = -1 !== $.inArray(treg[order.t].toUpperCase(), o.amNames) ? "AM" : "PM", 
                resTime.ampm = o["AM" === ampm ? "amNames" : "pmNames"][0])), -1 !== order.h && ("AM" === ampm && "12" === treg[order.h] ? resTime.hour = 0 : "PM" === ampm && "12" !== treg[order.h] ? resTime.hour = parseInt(treg[order.h], 10) + 12 : resTime.hour = Number(treg[order.h])), 
                -1 !== order.m && (resTime.minute = Number(treg[order.m])), -1 !== order.s && (resTime.second = Number(treg[order.s])), 
                -1 !== order.l && (resTime.millisec = Number(treg[order.l])), -1 !== order.c && (resTime.microsec = Number(treg[order.c])), 
                -1 !== order.z && void 0 !== treg[order.z] && (resTime.timezone = $.timepicker.timezoneOffsetNumber(treg[order.z])), 
                resTime) : !1;
            }), looseParse = function(f, s, o) {
                try {
                    var d = new Date("2012-01-01 " + s);
                    if (isNaN(d.getTime()) && (d = new Date("2012-01-01T" + s), isNaN(d.getTime()) && (d = new Date("01/01/2012 " + s), 
                    isNaN(d.getTime())))) throw "Unable to parse time with native Date: " + s;
                    return {
                        hour: d.getHours(),
                        minute: d.getMinutes(),
                        second: d.getSeconds(),
                        millisec: d.getMilliseconds(),
                        microsec: d.getMicroseconds(),
                        timezone: -1 * d.getTimezoneOffset()
                    };
                } catch (err) {
                    try {
                        return strictParse(f, s, o);
                    } catch (err2) {
                        $.timepicker.log("Unable to parse \ntimeString: " + s + "\ntimeFormat: " + f);
                    }
                }
                return !1;
            };
            // end looseParse
            // end looseParse
            return "function" == typeof o.parse ? o.parse(timeFormat, timeString, o) : "loose" === o.parse ? looseParse(timeFormat, timeString, o) : strictParse(timeFormat, timeString, o);
        }, /**
	 * Public utility to format the time
	 * @param {string} format format of the time
	 * @param {Object} time Object not a Date for timezones
	 * @param {Object} [options] essentially the regional[].. amNames, pmNames, ampm
	 * @returns {string} the formatted time
	 */
        $.datepicker.formatTime = function(format, time, options) {
            options = options || {}, options = $.extend({}, $.timepicker._defaults, options), 
            time = $.extend({
                hour: 0,
                minute: 0,
                second: 0,
                millisec: 0,
                microsec: 0,
                timezone: null
            }, time);
            var tmptime = format, ampmName = options.amNames[0], hour = parseInt(time.hour, 10);
            return hour > 11 && (ampmName = options.pmNames[0]), tmptime = tmptime.replace(/(?:HH?|hh?|mm?|ss?|[tT]{1,2}|[zZ]|[lc]|'.*?')/g, function(match) {
                switch (match) {
                  case "HH":
                    return ("0" + hour).slice(-2);

                  case "H":
                    return hour;

                  case "hh":
                    return ("0" + convert24to12(hour)).slice(-2);

                  case "h":
                    return convert24to12(hour);

                  case "mm":
                    return ("0" + time.minute).slice(-2);

                  case "m":
                    return time.minute;

                  case "ss":
                    return ("0" + time.second).slice(-2);

                  case "s":
                    return time.second;

                  case "l":
                    return ("00" + time.millisec).slice(-3);

                  case "c":
                    return ("00" + time.microsec).slice(-3);

                  case "z":
                    return $.timepicker.timezoneOffsetString(null === time.timezone ? options.timezone : time.timezone, !1);

                  case "Z":
                    return $.timepicker.timezoneOffsetString(null === time.timezone ? options.timezone : time.timezone, !0);

                  case "T":
                    return ampmName.charAt(0).toUpperCase();

                  case "TT":
                    return ampmName.toUpperCase();

                  case "t":
                    return ampmName.charAt(0).toLowerCase();

                  case "tt":
                    return ampmName.toLowerCase();

                  default:
                    return match.replace(/'/g, "");
                }
            });
        }, /*
	* the bad hack :/ override datepicker so it doesn't close on select
	// inspired: http://stackoverflow.com/questions/1252512/jquery-datepicker-prevent-closing-picker-when-clicking-a-date/1762378#1762378
	*/
        $.datepicker._base_selectDate = $.datepicker._selectDate, $.datepicker._selectDate = function(id, dateStr) {
            var was_inline, inst = this._getInst($(id)[0]), tp_inst = this._get(inst, "timepicker");
            tp_inst && inst.settings.showTimepicker ? (tp_inst._limitMinMaxDateTime(inst, !0), 
            was_inline = inst.inline, inst.inline = inst.stay_open = !0, this._base_selectDate(id, dateStr), 
            inst.inline = was_inline, inst.stay_open = !1, this._notifyChange(inst), this._updateDatepicker(inst)) : this._base_selectDate(id, dateStr);
        }, /*
	* second bad hack :/ override datepicker so it triggers an event when changing the input field
	* and does not redraw the datepicker on every selectDate event
	*/
        $.datepicker._base_updateDatepicker = $.datepicker._updateDatepicker, $.datepicker._updateDatepicker = function(inst) {
            // don't popup the datepicker if there is another instance already opened
            var input = inst.input[0];
            if (!($.datepicker._curInst && $.datepicker._curInst !== inst && $.datepicker._datepickerShowing && $.datepicker._lastInput !== input || "boolean" == typeof inst.stay_open && inst.stay_open !== !1)) {
                this._base_updateDatepicker(inst);
                // Reload the time control when changing something in the input text field.
                var tp_inst = this._get(inst, "timepicker");
                tp_inst && tp_inst._addTimePicker(inst);
            }
        }, /*
	* third bad hack :/ override datepicker so it allows spaces and colon in the input field
	*/
        $.datepicker._base_doKeyPress = $.datepicker._doKeyPress, $.datepicker._doKeyPress = function(event) {
            var inst = $.datepicker._getInst(event.target), tp_inst = $.datepicker._get(inst, "timepicker");
            if (tp_inst && $.datepicker._get(inst, "constrainInput")) {
                var ampm = tp_inst.support.ampm, tz = null !== tp_inst._defaults.showTimezone ? tp_inst._defaults.showTimezone : tp_inst.support.timezone, dateChars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat")), datetimeChars = tp_inst._defaults.timeFormat.toString().replace(/[hms]/g, "").replace(/TT/g, ampm ? "APM" : "").replace(/Tt/g, ampm ? "AaPpMm" : "").replace(/tT/g, ampm ? "AaPpMm" : "").replace(/T/g, ampm ? "AP" : "").replace(/tt/g, ampm ? "apm" : "").replace(/t/g, ampm ? "ap" : "") + " " + tp_inst._defaults.separator + tp_inst._defaults.timeSuffix + (tz ? tp_inst._defaults.timezoneList.join("") : "") + tp_inst._defaults.amNames.join("") + tp_inst._defaults.pmNames.join("") + dateChars, chr = String.fromCharCode(void 0 === event.charCode ? event.keyCode : event.charCode);
                return event.ctrlKey || " " > chr || !dateChars || datetimeChars.indexOf(chr) > -1;
            }
            return $.datepicker._base_doKeyPress(event);
        }, /*
	* Fourth bad hack :/ override _updateAlternate function used in inline mode to init altField
	* Update any alternate field to synchronise with the main field.
	*/
        $.datepicker._base_updateAlternate = $.datepicker._updateAlternate, $.datepicker._updateAlternate = function(inst) {
            var tp_inst = this._get(inst, "timepicker");
            if (tp_inst) {
                var altField = tp_inst._defaults.altField;
                if (altField) {
                    // update alternate field too
                    var date = (tp_inst._defaults.altFormat || tp_inst._defaults.dateFormat, this._getDate(inst)), formatCfg = $.datepicker._getFormatConfig(inst), altFormattedDateTime = "", altSeparator = tp_inst._defaults.altSeparator ? tp_inst._defaults.altSeparator : tp_inst._defaults.separator, altTimeSuffix = tp_inst._defaults.altTimeSuffix ? tp_inst._defaults.altTimeSuffix : tp_inst._defaults.timeSuffix, altTimeFormat = null !== tp_inst._defaults.altTimeFormat ? tp_inst._defaults.altTimeFormat : tp_inst._defaults.timeFormat;
                    altFormattedDateTime += $.datepicker.formatTime(altTimeFormat, tp_inst, tp_inst._defaults) + altTimeSuffix, 
                    tp_inst._defaults.timeOnly || tp_inst._defaults.altFieldTimeOnly || null === date || (altFormattedDateTime = tp_inst._defaults.altFormat ? $.datepicker.formatDate(tp_inst._defaults.altFormat, date, formatCfg) + altSeparator + altFormattedDateTime : tp_inst.formattedDate + altSeparator + altFormattedDateTime), 
                    $(altField).val(inst.input.val() ? altFormattedDateTime : "");
                }
            } else $.datepicker._base_updateAlternate(inst);
        }, /*
	* Override key up event to sync manual input changes.
	*/
        $.datepicker._base_doKeyUp = $.datepicker._doKeyUp, $.datepicker._doKeyUp = function(event) {
            var inst = $.datepicker._getInst(event.target), tp_inst = $.datepicker._get(inst, "timepicker");
            if (tp_inst && tp_inst._defaults.timeOnly && inst.input.val() !== inst.lastVal) try {
                $.datepicker._updateDatepicker(inst);
            } catch (err) {
                $.timepicker.log(err);
            }
            return $.datepicker._base_doKeyUp(event);
        }, /*
	* override "Today" button to also grab the time.
	*/
        $.datepicker._base_gotoToday = $.datepicker._gotoToday, $.datepicker._gotoToday = function(id) {
            var inst = this._getInst($(id)[0]);
            inst.dpDiv;
            this._base_gotoToday(id);
            var tp_inst = this._get(inst, "timepicker");
            selectLocalTimezone(tp_inst);
            var now = new Date();
            this._setTime(inst, now), this._setDate(inst, now);
        }, /*
	* Disable & enable the Time in the datetimepicker
	*/
        $.datepicker._disableTimepickerDatepicker = function(target) {
            var inst = this._getInst(target);
            if (inst) {
                var tp_inst = this._get(inst, "timepicker");
                $(target).datepicker("getDate"), // Init selected[Year|Month|Day]
                tp_inst && (inst.settings.showTimepicker = !1, tp_inst._defaults.showTimepicker = !1, 
                tp_inst._updateDateTime(inst));
            }
        }, $.datepicker._enableTimepickerDatepicker = function(target) {
            var inst = this._getInst(target);
            if (inst) {
                var tp_inst = this._get(inst, "timepicker");
                $(target).datepicker("getDate"), // Init selected[Year|Month|Day]
                tp_inst && (inst.settings.showTimepicker = !0, tp_inst._defaults.showTimepicker = !0, 
                tp_inst._addTimePicker(inst), // Could be disabled on page load
                tp_inst._updateDateTime(inst));
            }
        }, /*
	* Create our own set time function
	*/
        $.datepicker._setTime = function(inst, date) {
            var tp_inst = this._get(inst, "timepicker");
            if (tp_inst) {
                var defaults = tp_inst._defaults;
                // calling _setTime with no date sets time to defaults
                tp_inst.hour = date ? date.getHours() : defaults.hour, tp_inst.minute = date ? date.getMinutes() : defaults.minute, 
                tp_inst.second = date ? date.getSeconds() : defaults.second, tp_inst.millisec = date ? date.getMilliseconds() : defaults.millisec, 
                tp_inst.microsec = date ? date.getMicroseconds() : defaults.microsec, //check if within min/max times.. 
                tp_inst._limitMinMaxDateTime(inst, !0), tp_inst._onTimeChange(), tp_inst._updateDateTime(inst);
            }
        }, /*
	* Create new public method to set only time, callable as $().datepicker('setTime', date)
	*/
        $.datepicker._setTimeDatepicker = function(target, date, withDate) {
            var inst = this._getInst(target);
            if (inst) {
                var tp_inst = this._get(inst, "timepicker");
                if (tp_inst) {
                    this._setDateFromField(inst);
                    var tp_date;
                    date && ("string" == typeof date ? (tp_inst._parseTime(date, withDate), tp_date = new Date(), 
                    tp_date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec), 
                    tp_date.setMicroseconds(tp_inst.microsec)) : (tp_date = new Date(date.getTime()), 
                    tp_date.setMicroseconds(date.getMicroseconds())), "Invalid Date" === tp_date.toString() && (tp_date = void 0), 
                    this._setTime(inst, tp_date));
                }
            }
        }, /*
	* override setDate() to allow setting time too within Date object
	*/
        $.datepicker._base_setDateDatepicker = $.datepicker._setDateDatepicker, $.datepicker._setDateDatepicker = function(target, _date) {
            var inst = this._getInst(target), date = _date;
            if (inst) {
                "string" == typeof _date && (date = new Date(_date), date.getTime() || (this._base_setDateDatepicker.apply(this, arguments), 
                date = $(target).datepicker("getDate")));
                var tp_date, tp_inst = this._get(inst, "timepicker");
                date instanceof Date ? (tp_date = new Date(date.getTime()), tp_date.setMicroseconds(date.getMicroseconds())) : tp_date = date, 
                // This is important if you are using the timezone option, javascript's Date 
                // object will only return the timezone offset for the current locale, so we 
                // adjust it accordingly.  If not using timezone option this won't matter..
                // If a timezone is different in tp, keep the timezone as is
                tp_inst && tp_date && (// look out for DST if tz wasn't specified
                tp_inst.support.timezone || null !== tp_inst._defaults.timezone || (tp_inst.timezone = -1 * tp_date.getTimezoneOffset()), 
                date = $.timepicker.timezoneAdjust(date, tp_inst.timezone), tp_date = $.timepicker.timezoneAdjust(tp_date, tp_inst.timezone)), 
                this._updateDatepicker(inst), this._base_setDateDatepicker.apply(this, arguments), 
                this._setTimeDatepicker(target, tp_date, !0);
            }
        }, /*
	* override getDate() to allow getting time too within Date object
	*/
        $.datepicker._base_getDateDatepicker = $.datepicker._getDateDatepicker, $.datepicker._getDateDatepicker = function(target, noDefault) {
            var inst = this._getInst(target);
            if (inst) {
                var tp_inst = this._get(inst, "timepicker");
                if (tp_inst) {
                    // if it hasn't yet been defined, grab from field
                    void 0 === inst.lastVal && this._setDateFromField(inst, noDefault);
                    var date = this._getDate(inst);
                    // This is important if you are using the timezone option, javascript's Date 
                    // object will only return the timezone offset for the current locale, so we 
                    // adjust it accordingly.  If not using timezone option this won't matter..
                    // look out for DST if tz wasn't specified
                    return date && tp_inst._parseTime($(target).val(), tp_inst.timeOnly) && (date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec), 
                    date.setMicroseconds(tp_inst.microsec), null != tp_inst.timezone && (tp_inst.support.timezone || null !== tp_inst._defaults.timezone || (tp_inst.timezone = -1 * date.getTimezoneOffset()), 
                    date = $.timepicker.timezoneAdjust(date, tp_inst.timezone))), date;
                }
                return this._base_getDateDatepicker(target, noDefault);
            }
        }, /*
	* override parseDate() because UI 1.8.14 throws an error about "Extra characters"
	* An option in datapicker to ignore extra format characters would be nicer.
	*/
        $.datepicker._base_parseDate = $.datepicker.parseDate, $.datepicker.parseDate = function(format, value, settings) {
            var date;
            try {
                date = this._base_parseDate(format, value, settings);
            } catch (err) {
                // Hack!  The error message ends with a colon, a space, and
                // the "extra" characters.  We rely on that instead of
                // attempting to perfectly reproduce the parsing algorithm.
                if (!(err.indexOf(":") >= 0)) throw err;
                date = this._base_parseDate(format, value.substring(0, value.length - (err.length - err.indexOf(":") - 2)), settings), 
                $.timepicker.log("Error parsing the date string: " + err + "\ndate string = " + value + "\ndate format = " + format);
            }
            return date;
        }, /*
	* override formatDate to set date with time to the input
	*/
        $.datepicker._base_formatDate = $.datepicker._formatDate, $.datepicker._formatDate = function(inst, day, month, year) {
            var tp_inst = this._get(inst, "timepicker");
            return tp_inst ? (tp_inst._updateDateTime(inst), tp_inst.$input.val()) : this._base_formatDate(inst);
        }, /*
	* override options setter to add time to maxDate(Time) and minDate(Time). MaxDate
	*/
        $.datepicker._base_optionDatepicker = $.datepicker._optionDatepicker, $.datepicker._optionDatepicker = function(target, name, value) {
            var name_clone, inst = this._getInst(target);
            if (!inst) return null;
            var tp_inst = this._get(inst, "timepicker");
            if (tp_inst) {
                var prop, ret, oldVal, $target, min = null, max = null, onselect = null, overrides = tp_inst._defaults.evnts, fns = {};
                if ("string" == typeof name) {
                    // if min/max was set with the string
                    if ("minDate" === name || "minDateTime" === name) min = value; else if ("maxDate" === name || "maxDateTime" === name) max = value; else if ("onSelect" === name) onselect = value; else if (overrides.hasOwnProperty(name)) {
                        if ("undefined" == typeof value) return overrides[name];
                        fns[name] = value, name_clone = {};
                    }
                } else if ("object" == typeof name) {
                    //if min/max was set with the JSON
                    name.minDate ? min = name.minDate : name.minDateTime ? min = name.minDateTime : name.maxDate ? max = name.maxDate : name.maxDateTime && (max = name.maxDateTime);
                    for (prop in overrides) overrides.hasOwnProperty(prop) && name[prop] && (fns[prop] = name[prop]);
                }
                for (prop in fns) fns.hasOwnProperty(prop) && (overrides[prop] = fns[prop], name_clone || (name_clone = $.extend({}, name)), 
                delete name_clone[prop]);
                if (name_clone && isEmptyObject(name_clone)) return;
                // Datepicker will override our date when we call _base_optionDatepicker when 
                // calling minDate/maxDate, so we will first grab the value, call 
                // _base_optionDatepicker, then set our value back.
                if (min ? (//if min was set
                min = 0 === min ? new Date() : new Date(min), tp_inst._defaults.minDate = min, tp_inst._defaults.minDateTime = min) : max ? (//if max was set
                max = 0 === max ? new Date() : new Date(max), tp_inst._defaults.maxDate = max, tp_inst._defaults.maxDateTime = max) : onselect && (tp_inst._defaults.onSelect = onselect), 
                min || max) return $target = $(target), oldVal = $target.datetimepicker("getDate"), 
                ret = this._base_optionDatepicker.call($.datepicker, target, name_clone || name, value), 
                $target.datetimepicker("setDate", oldVal), ret;
            }
            return void 0 === value ? this._base_optionDatepicker.call($.datepicker, target, name) : this._base_optionDatepicker.call($.datepicker, target, name_clone || name, value);
        };
        /*
	* jQuery isEmptyObject does not check hasOwnProperty - if someone has added to the object prototype,
	* it will return false for all objects
	*/
        var isEmptyObject = function(obj) {
            var prop;
            for (prop in obj) if (obj.hasOwnProperty(prop)) return !1;
            return !0;
        }, extendRemove = function(target, props) {
            $.extend(target, props);
            for (var name in props) (null === props[name] || void 0 === props[name]) && (target[name] = props[name]);
            return target;
        }, detectSupport = function(timeFormat) {
            var tf = timeFormat.replace(/'.*?'/g, "").toLowerCase(), // removes literals
            isIn = function(f, t) {
                // does the format contain the token?
                return -1 !== f.indexOf(t) ? !0 : !1;
            };
            return {
                hour: isIn(tf, "h"),
                minute: isIn(tf, "m"),
                second: isIn(tf, "s"),
                millisec: isIn(tf, "l"),
                microsec: isIn(tf, "c"),
                timezone: isIn(tf, "z"),
                ampm: isIn(tf, "t") && isIn(timeFormat, "h"),
                iso8601: isIn(timeFormat, "Z")
            };
        }, convert24to12 = function(hour) {
            return hour %= 12, 0 === hour && (hour = 12), String(hour);
        }, computeEffectiveSetting = function(settings, property) {
            return settings && settings[property] ? settings[property] : $.timepicker._defaults[property];
        }, splitDateTime = function(dateTimeString, timeSettings) {
            // The idea is to get the number separator occurrences in datetime and the time format requested (since time has
            // fewer unknowns, mostly numbers and am/pm). We will use the time pattern to split.
            var separator = computeEffectiveSetting(timeSettings, "separator"), format = computeEffectiveSetting(timeSettings, "timeFormat"), timeParts = format.split(separator), // how many occurrences of separator may be in our format?
            timePartsLen = timeParts.length, allParts = dateTimeString.split(separator), allPartsLen = allParts.length;
            return allPartsLen > 1 ? {
                dateString: allParts.splice(0, allPartsLen - timePartsLen).join(separator),
                timeString: allParts.splice(0, timePartsLen).join(separator)
            } : {
                dateString: dateTimeString,
                timeString: ""
            };
        }, parseDateTimeInternal = function(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
            var date, parts, parsedTime;
            if (parts = splitDateTime(dateTimeString, timeSettings), date = $.datepicker._base_parseDate(dateFormat, parts.dateString, dateSettings), 
            "" === parts.timeString) return {
                date: date
            };
            if (parsedTime = $.datepicker.parseTime(timeFormat, parts.timeString, timeSettings), 
            !parsedTime) throw "Wrong time format";
            return {
                date: date,
                timeObj: parsedTime
            };
        }, selectLocalTimezone = function(tp_inst, date) {
            if (tp_inst && tp_inst.timezone_select) {
                var now = date || new Date();
                tp_inst.timezone_select.val(-now.getTimezoneOffset());
            }
        };
        /*
	* Create a Singleton Instance
	*/
        $.timepicker = new Timepicker(), /**
	 * Get the timezone offset as string from a date object (eg '+0530' for UTC+5.5)
	 * @param {number} tzMinutes if not a number, less than -720 (-1200), or greater than 840 (+1400) this value is returned
	 * @param {boolean} iso8601 if true formats in accordance to iso8601 "+12:45"
	 * @return {string}
	 */
        $.timepicker.timezoneOffsetString = function(tzMinutes, iso8601) {
            if (isNaN(tzMinutes) || tzMinutes > 840 || -720 > tzMinutes) return tzMinutes;
            var off = tzMinutes, minutes = off % 60, hours = (off - minutes) / 60, iso = iso8601 ? ":" : "", tz = (off >= 0 ? "+" : "-") + ("0" + Math.abs(hours)).slice(-2) + iso + ("0" + Math.abs(minutes)).slice(-2);
            return "+00:00" === tz ? "Z" : tz;
        }, /**
	 * Get the number in minutes that represents a timezone string
	 * @param  {string} tzString formatted like "+0500", "-1245", "Z"
	 * @return {number} the offset minutes or the original string if it doesn't match expectations
	 */
        $.timepicker.timezoneOffsetNumber = function(tzString) {
            var normalized = tzString.toString().replace(":", "");
            // excuse any iso8601, end up with "+1245"
            // excuse any iso8601, end up with "+1245"
            // plus or minus
            // hours (converted to minutes)
            return "Z" === normalized.toUpperCase() ? 0 : /^(\-|\+)\d{4}$/.test(normalized) ? ("-" === normalized.substr(0, 1) ? -1 : 1) * (60 * parseInt(normalized.substr(1, 2), 10) + parseInt(normalized.substr(3, 2), 10)) : tzString;
        }, /**
	 * No way to set timezone in js Date, so we must adjust the minutes to compensate. (think setDate, getDate)
	 * @param  {Date} date
	 * @param  {string} toTimezone formatted like "+0500", "-1245"
	 * @return {Date}
	 */
        $.timepicker.timezoneAdjust = function(date, toTimezone) {
            var toTz = $.timepicker.timezoneOffsetNumber(toTimezone);
            return isNaN(toTz) || date.setMinutes(date.getMinutes() + -date.getTimezoneOffset() - toTz), 
            date;
        }, /**
	 * Calls `timepicker()` on the `startTime` and `endTime` elements, and configures them to
	 * enforce date range limits.
	 * n.b. The input value must be correctly formatted (reformatting is not supported)
	 * @param  {Element} startTime
	 * @param  {Element} endTime
	 * @param  {Object} options Options for the timepicker() call
	 * @return {jQuery}
	 */
        $.timepicker.timeRange = function(startTime, endTime, options) {
            return $.timepicker.handleRange("timepicker", startTime, endTime, options);
        }, /**
	 * Calls `datetimepicker` on the `startTime` and `endTime` elements, and configures them to
	 * enforce date range limits.
	 * @param  {Element} startTime
	 * @param  {Element} endTime
	 * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
	 *   a boolean value that can be used to reformat the input values to the `dateFormat`.
	 * @param  {string} method Can be used to specify the type of picker to be added
	 * @return {jQuery}
	 */
        $.timepicker.datetimeRange = function(startTime, endTime, options) {
            $.timepicker.handleRange("datetimepicker", startTime, endTime, options);
        }, /**
	 * Calls `datepicker` on the `startTime` and `endTime` elements, and configures them to
	 * enforce date range limits.
	 * @param  {Element} startTime
	 * @param  {Element} endTime
	 * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
	 *   a boolean value that can be used to reformat the input values to the `dateFormat`.
	 * @return {jQuery}
	 */
        $.timepicker.dateRange = function(startTime, endTime, options) {
            $.timepicker.handleRange("datepicker", startTime, endTime, options);
        }, /**
	 * Calls `method` on the `startTime` and `endTime` elements, and configures them to
	 * enforce date range limits.
	 * @param  {string} method Can be used to specify the type of picker to be added
	 * @param  {Element} startTime
	 * @param  {Element} endTime
	 * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
	 *   a boolean value that can be used to reformat the input values to the `dateFormat`.
	 * @return {jQuery}
	 */
        $.timepicker.handleRange = function(method, startTime, endTime, options) {
            function checkDates(changed, other) {
                var startdt = startTime[method]("getDate"), enddt = endTime[method]("getDate"), changeddt = changed[method]("getDate");
                if (null !== startdt) {
                    var minDate = new Date(startdt.getTime()), maxDate = new Date(startdt.getTime());
                    minDate.setMilliseconds(minDate.getMilliseconds() + options.minInterval), maxDate.setMilliseconds(maxDate.getMilliseconds() + options.maxInterval), 
                    options.minInterval > 0 && minDate > enddt ? // minInterval check
                    endTime[method]("setDate", minDate) : options.maxInterval > 0 && enddt > maxDate ? // max interval check
                    endTime[method]("setDate", maxDate) : startdt > enddt && other[method]("setDate", changeddt);
                }
            }
            function selected(changed, other, option) {
                if (changed.val()) {
                    var date = changed[method].call(changed, "getDate");
                    null !== date && options.minInterval > 0 && ("minDate" === option && date.setMilliseconds(date.getMilliseconds() + options.minInterval), 
                    "maxDate" === option && date.setMilliseconds(date.getMilliseconds() - options.minInterval)), 
                    date.getTime && other[method].call(other, "option", option, date);
                }
            }
            options = $.extend({}, {
                minInterval: 0,
                // min allowed interval in milliseconds
                maxInterval: 0,
                // max allowed interval in milliseconds
                start: {},
                // options for start picker
                end: {}
            }, options);
            // for the mean time this fixes an issue with calling getDate with timepicker()
            var timeOnly = !1;
            return "timepicker" === method && (timeOnly = !0, method = "datetimepicker"), $.fn[method].call(startTime, $.extend({
                timeOnly: timeOnly,
                onClose: function(dateText, inst) {
                    checkDates($(this), endTime);
                },
                onSelect: function(selectedDateTime) {
                    selected($(this), endTime, "minDate");
                }
            }, options, options.start)), $.fn[method].call(endTime, $.extend({
                timeOnly: timeOnly,
                onClose: function(dateText, inst) {
                    checkDates($(this), startTime);
                },
                onSelect: function(selectedDateTime) {
                    selected($(this), startTime, "maxDate");
                }
            }, options, options.end)), checkDates(startTime, endTime), selected(startTime, endTime, "minDate"), 
            selected(endTime, startTime, "maxDate"), $([ startTime.get(0), endTime.get(0) ]);
        }, /**
	 * Log error or data to the console during error or debugging
	 * @param  {Object} err pass any type object to log to the console during error or debugging
	 * @return {void}
	 */
        $.timepicker.log = function() {
            window.console && window.console.log.apply(window.console, Array.prototype.slice.call(arguments));
        }, /*
	 * Add util object to allow access to private methods for testability.
	 */
        $.timepicker._util = {
            _extendRemove: extendRemove,
            _isEmptyObject: isEmptyObject,
            _convert24to12: convert24to12,
            _detectSupport: detectSupport,
            _selectLocalTimezone: selectLocalTimezone,
            _computeEffectiveSetting: computeEffectiveSetting,
            _splitDateTime: splitDateTime,
            _parseDateTimeInternal: parseDateTimeInternal
        }, /*
	* Microsecond support
	*/
        Date.prototype.getMicroseconds || (Date.prototype.microseconds = 0, Date.prototype.getMicroseconds = function() {
            return this.microseconds;
        }, Date.prototype.setMicroseconds = function(m) {
            return this.setMilliseconds(this.getMilliseconds() + Math.floor(m / 1e3)), this.microseconds = m % 1e3, 
            this;
        }), /*
	* Keep up with the version
	*/
        $.timepicker.version = "1.5.0";
    }
}(jQuery);

/**
 * NetteForms - simple form validation.
 *
 * This file is part of the Nette Framework (http://nette.org)
 * Copyright (c) 2004 David Grudl (http://davidgrudl.com)
 */
var Nette = Nette || {};

/**
 * Attaches a handler to an event for the element.
 */
Nette.addEvent = function(element, on, callback) {
    var original = element["on" + on];
    element["on" + on] = function() {
        return "function" == typeof original && original.apply(element, arguments) === !1 ? !1 : callback.apply(element, arguments);
    };
}, /**
 * Returns the value of form element.
 */
Nette.getValue = function(elem) {
    var i;
    if (elem) {
        if (elem.tagName) {
            if ("radio" === elem.type) {
                var elements = elem.form.elements;
                // prevents problem with name 'item' or 'namedItem'
                for (i = 0; i < elements.length; i++) if (elements[i].name === elem.name && elements[i].checked) return elements[i].value;
                return null;
            }
            if ("file" === elem.type) return elem.files || elem.value;
            if ("select" === elem.tagName.toLowerCase()) {
                var index = elem.selectedIndex, options = elem.options, values = [];
                if ("select-one" === elem.type) return 0 > index ? null : options[index].value;
                for (i = 0; i < options.length; i++) options[i].selected && values.push(options[i].value);
                return values;
            }
            if (elem.name && elem.name.match(/\[\]$/)) {
                // multiple elements []
                var elements = elem.form.elements[elem.name].tagName ? [ elem ] : elem.form.elements[elem.name], values = [];
                for (i = 0; i < elements.length; i++) ("checkbox" !== elements[i].type || elements[i].checked) && values.push(elements[i].value);
                return values;
            }
            return "checkbox" === elem.type ? elem.checked : "textarea" === elem.tagName.toLowerCase() ? elem.value.replace("\r", "") : elem.value.replace("\r", "").replace(/^\s+|\s+$/g, "");
        }
        // RadioNodeList, HTMLCollection, array
        return elem[0] ? Nette.getValue(elem[0]) : null;
    }
    return null;
}, /**
 * Returns the effective value of form element.
 */
Nette.getEffectiveValue = function(elem) {
    var val = Nette.getValue(elem);
    return elem.getAttribute && val === elem.getAttribute("data-nette-empty-value") && (val = ""), 
    val;
}, /**
 * Validates form element against given rules.
 */
Nette.validateControl = function(elem, rules, onlyCheck, value) {
    elem = elem.tagName ? elem : elem[0], rules = rules || Nette.parseJSON(elem.getAttribute("data-nette-rules")), 
    value = void 0 === value ? {
        value: Nette.getEffectiveValue(elem)
    } : value;
    for (var id = 0, len = rules.length; len > id; id++) {
        var rule = rules[id], op = rule.op.match(/(~)?([^?]+)/), curElem = rule.control ? elem.form.elements.namedItem(rule.control) : elem;
        if (curElem) {
            rule.neg = op[1], rule.op = op[2], rule.condition = !!rule.rules, curElem = curElem.tagName ? curElem : curElem[0];
            // RadioNodeList
            var curValue = elem === curElem ? value : {
                value: Nette.getEffectiveValue(curElem)
            }, success = Nette.validateRule(curElem, rule.op, rule.arg, curValue);
            if (null !== success) if (rule.neg && (success = !success), rule.condition && success) {
                if (!Nette.validateControl(elem, rule.rules, onlyCheck, value)) return !1;
            } else if (!rule.condition && !success) {
                if (Nette.isDisabled(curElem)) continue;
                if (!onlyCheck) {
                    var arr = Nette.isArray(rule.arg) ? rule.arg : [ rule.arg ], message = rule.msg.replace(/%(value|\d+)/g, function(foo, m) {
                        return Nette.getValue("value" === m ? curElem : elem.form.elements.namedItem(arr[m].control));
                    });
                    Nette.addError(curElem, message);
                }
                return !1;
            }
        }
    }
    return !0;
}, /**
 * Validates whole form.
 */
Nette.validateForm = function(sender) {
    var form = sender.form || sender, scope = !1;
    if (form["nette-submittedBy"] && null !== form["nette-submittedBy"].getAttribute("formnovalidate")) {
        var scopeArr = Nette.parseJSON(form["nette-submittedBy"].getAttribute("data-nette-validation-scope"));
        if (!scopeArr.length) return !0;
        scope = new RegExp("^(" + scopeArr.join("-|") + "-)");
    }
    var i, elem, radios = {};
    for (i = 0; i < form.elements.length; i++) if (elem = form.elements[i], !elem.tagName || elem.tagName.toLowerCase() in {
        input: 1,
        select: 1,
        textarea: 1,
        button: 1
    }) {
        if ("radio" === elem.type) {
            if (radios[elem.name]) continue;
            radios[elem.name] = !0;
        }
        if (!(scope && !elem.name.replace(/]\[|\[|]|$/g, "-").match(scope) || Nette.isDisabled(elem) || Nette.validateControl(elem))) return !1;
    }
    return !0;
}, /**
 * Check if input is disabled.
 */
Nette.isDisabled = function(elem) {
    if ("radio" === elem.type) {
        for (var i = 0, elements = elem.form.elements; i < elements.length; i++) if (elements[i].name === elem.name && !elements[i].disabled) return !1;
        return !0;
    }
    return elem.disabled;
}, /**
 * Display error message.
 */
Nette.addError = function(elem, message) {
    message && alert(message), elem.focus && elem.focus();
}, /**
 * Expand rule argument.
 */
Nette.expandRuleArgument = function(form, arg) {
    return arg && arg.control && (arg = Nette.getEffectiveValue(form.elements.namedItem(arg.control))), 
    arg;
}, /**
 * Validates single rule.
 */
Nette.validateRule = function(elem, op, arg, value) {
    value = void 0 === value ? {
        value: Nette.getEffectiveValue(elem)
    } : value, ":" === op.charAt(0) && (op = op.substr(1)), op = op.replace("::", "_"), 
    op = op.replace(/\\/g, "");
    for (var arr = Nette.isArray(arg) ? arg.slice(0) : [ arg ], i = 0, len = arr.length; len > i; i++) arr[i] = Nette.expandRuleArgument(elem.form, arr[i]);
    return Nette.validators[op] ? Nette.validators[op](elem, Nette.isArray(arg) ? arr : arr[0], value.value, value) : null;
}, Nette.validators = {
    filled: function(elem, arg, val) {
        return "" !== val && val !== !1 && null !== val && (!Nette.isArray(val) || !!val.length) && (!window.FileList || !(val instanceof FileList) || val.length);
    },
    blank: function(elem, arg, val) {
        return !Nette.validators.filled(elem, arg, val);
    },
    valid: function(elem, arg, val) {
        return Nette.validateControl(elem, null, !0);
    },
    equal: function(elem, arg, val) {
        if (void 0 === arg) return null;
        val = Nette.isArray(val) ? val : [ val ], arg = Nette.isArray(arg) ? arg : [ arg ];
        loop: for (var i1 = 0, len1 = val.length; len1 > i1; i1++) {
            for (var i2 = 0, len2 = arg.length; len2 > i2; i2++) /* jshint eqeqeq: false */
            if (val[i1] == arg[i2]) continue loop;
            return !1;
        }
        return !0;
    },
    notEqual: function(elem, arg, val) {
        return void 0 === arg ? null : !Nette.validators.equal(elem, arg, val);
    },
    minLength: function(elem, arg, val) {
        return val.length >= arg;
    },
    maxLength: function(elem, arg, val) {
        return val.length <= arg;
    },
    length: function(elem, arg, val) {
        return arg = Nette.isArray(arg) ? arg : [ arg, arg ], (null === arg[0] || val.length >= arg[0]) && (null === arg[1] || val.length <= arg[1]);
    },
    email: function(elem, arg, val) {
        return /^("([ !\x23-\x5B\x5D-\x7E]*|\\[ -~])+"|[-a-z0-9!#$%&'*+\/=?^_`{|}~]+(\.[-a-z0-9!#$%&'*+\/=?^_`{|}~]+)*)@([0-9a-z\u00C0-\u02FF\u0370-\u1EFF]([-0-9a-z\u00C0-\u02FF\u0370-\u1EFF]{0,61}[0-9a-z\u00C0-\u02FF\u0370-\u1EFF])?\.)+[a-z\u00C0-\u02FF\u0370-\u1EFF][-0-9a-z\u00C0-\u02FF\u0370-\u1EFF]{0,17}[a-z\u00C0-\u02FF\u0370-\u1EFF]$/i.test(val);
    },
    url: function(elem, arg, val, value) {
        return /^[a-z\d+.-]+:/.test(val) || (val = "http://" + val), /^https?:\/\/([0-9a-z\u00C0-\u02FF\u0370-\u1EFF](([-0-9a-z\u00C0-\u02FF\u0370-\u1EFF]{0,61}[0-9a-z\u00C0-\u02FF\u0370-\u1EFF])?\.)*[a-z\u00C0-\u02FF\u0370-\u1EFF][-0-9a-z\u00C0-\u02FF\u0370-\u1EFF]{0,17}[a-z\u00C0-\u02FF\u0370-\u1EFF]|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|\[[0-9a-f:]{3,39}\])(:\d{1,5})?(\/\S*)?$/i.test(val) ? (value.value = val, 
        !0) : !1;
    },
    regexp: function(elem, arg, val) {
        var parts = "string" == typeof arg ? arg.match(/^\/(.*)\/([imu]*)$/) : !1;
        try {
            return parts && new RegExp(parts[1], parts[2].replace("u", "")).test(val);
        } catch (e) {}
    },
    pattern: function(elem, arg, val) {
        try {
            return "string" == typeof arg ? new RegExp("^(" + arg + ")$").test(val) : null;
        } catch (e) {}
    },
    integer: function(elem, arg, val) {
        return /^-?[0-9]+$/.test(val);
    },
    "float": function(elem, arg, val, value) {
        return val = val.replace(" ", "").replace(",", "."), /^-?[0-9]*[.,]?[0-9]+$/.test(val) ? (value.value = val, 
        !0) : !1;
    },
    min: function(elem, arg, val) {
        return Nette.validators.range(elem, [ arg, null ], val);
    },
    max: function(elem, arg, val) {
        return Nette.validators.range(elem, [ null, arg ], val);
    },
    range: function(elem, arg, val) {
        return Nette.isArray(arg) ? (null === arg[0] || parseFloat(val) >= arg[0]) && (null === arg[1] || parseFloat(val) <= arg[1]) : null;
    },
    submitted: function(elem, arg, val) {
        return elem.form["nette-submittedBy"] === elem;
    },
    fileSize: function(elem, arg, val) {
        if (window.FileList) for (var i = 0; i < val.length; i++) if (val[i].size > arg) return !1;
        return !0;
    },
    image: function(elem, arg, val) {
        if (window.FileList && val instanceof FileList) for (var i = 0; i < val.length; i++) {
            var type = val[i].type;
            if (type && "image/gif" !== type && "image/png" !== type && "image/jpeg" !== type) return !1;
        }
        return !0;
    }
}, /**
 * Process all toggles in form.
 */
Nette.toggleForm = function(form, elem) {
    var i;
    for (Nette.toggles = {}, i = 0; i < form.elements.length; i++) form.elements[i].tagName.toLowerCase() in {
        input: 1,
        select: 1,
        textarea: 1,
        button: 1
    } && Nette.toggleControl(form.elements[i], null, null, !elem);
    for (i in Nette.toggles) Nette.toggle(i, Nette.toggles[i], elem);
}, /**
 * Process toggles on form element.
 */
Nette.toggleControl = function(elem, rules, success, firsttime, value) {
    rules = rules || Nette.parseJSON(elem.getAttribute("data-nette-rules")), value = void 0 === value ? {
        value: Nette.getEffectiveValue(elem)
    } : value;
    for (var curSuccess, has = !1, handled = [], handler = function() {
        Nette.toggleForm(elem.form, elem);
    }, id = 0, len = rules.length; len > id; id++) {
        var rule = rules[id], op = rule.op.match(/(~)?([^?]+)/), curElem = rule.control ? elem.form.elements.namedItem(rule.control) : elem;
        if (curElem) {
            if (curSuccess = success, success !== !1) {
                rule.neg = op[1], rule.op = op[2];
                var curValue = elem === curElem ? value : {
                    value: Nette.getEffectiveValue(curElem)
                };
                if (curSuccess = Nette.validateRule(curElem, rule.op, rule.arg, curValue), null === curSuccess) continue;
                rule.neg && (curSuccess = !curSuccess), rule.rules || (success = curSuccess);
            }
            if (rule.rules && Nette.toggleControl(elem, rule.rules, curSuccess, firsttime, value) || rule.toggle) {
                if (has = !0, firsttime) for (var oldIE = !document.addEventListener, // IE < 9
                name = curElem.tagName ? curElem.name : curElem[0].name, els = curElem.tagName ? curElem.form.elements : curElem, i = 0; i < els.length; i++) els[i].name !== name || Nette.inArray(handled, els[i]) || (Nette.addEvent(els[i], oldIE && els[i].type in {
                    checkbox: 1,
                    radio: 1
                } ? "click" : "change", handler), handled.push(els[i]));
                for (var id2 in rule.toggle || []) Object.prototype.hasOwnProperty.call(rule.toggle, id2) && (Nette.toggles[id2] = Nette.toggles[id2] || (rule.toggle[id2] ? curSuccess : !curSuccess));
            }
        }
    }
    return has;
}, Nette.parseJSON = function(s) {
    return s = s || "[]", "{op" === s.substr(0, 3) ? eval("[" + s + "]") : window.JSON && window.JSON.parse ? JSON.parse(s) : eval(s);
}, /**
 * Displays or hides HTML element.
 */
Nette.toggle = function(id, visible, srcElement) {
    var elem = document.getElementById(id);
    elem && (elem.style.display = visible ? "" : "none");
}, /**
 * Setup handlers.
 */
Nette.initForm = function(form) {
    form.noValidate = "novalidate", Nette.addEvent(form, "submit", function(e) {
        return Nette.validateForm(form) ? void 0 : (e && e.stopPropagation ? e.stopPropagation() : window.event && (event.cancelBubble = !0), 
        !1);
    }), Nette.addEvent(form, "click", function(e) {
        e = e || event;
        var target = e.target || e.srcElement;
        form["nette-submittedBy"] = target.type in {
            submit: 1,
            image: 1
        } ? target : null;
    }), Nette.toggleForm(form);
}, /**
 * Determines whether the argument is an array.
 */
Nette.isArray = function(arg) {
    return "[object Array]" === Object.prototype.toString.call(arg);
}, /**
 * Search for a specified value within an array.
 */
Nette.inArray = function(arr, val) {
    if ([].indexOf) return arr.indexOf(val) > -1;
    for (var i = 0; i < arr.length; i++) if (arr[i] === val) return !0;
    return !1;
}, Nette.addEvent(window, "load", function() {
    for (var i = 0; i < document.forms.length; i++) Nette.initForm(document.forms[i]);
}), /**
 * Converts string to web safe characters [a-z0-9-] text.
 */
Nette.webalize = function(s) {
    s = s.toLowerCase();
    var i, ch, res = "";
    for (i = 0; i < s.length; i++) ch = Nette.webalizeTable[s.charAt(i)], res += ch ? ch : s.charAt(i);
    return res.replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
}, Nette.webalizeTable = {
    "": "a",
    "": "a",
    "": "c",
    "": "d",
    "": "e",
    "": "e",
    "": "i",
    "": "l",
    "": "n",
    "": "o",
    "": "o",
    "": "r",
    "": "s",
    "": "t",
    "": "u",
    "": "u",
    "": "y",
    "": "z"
}, /**
 * AJAX Nette Framework plugin for jQuery
 *
 * @copyright Copyright (c) 2009, 2010 Jan Marek
 * @copyright Copyright (c) 2009, 2010 David Grudl
 * @copyright Copyright (c) 2012 Vojtch Dobe
 * @license MIT
 *
 * @version 1.2.2
 */
function(window, $, undefined) {
    if ("function" != typeof $) return console.error("nette.ajax.js: jQuery is missing, load it please");
    var nette = function() {
        var inner = {
            self: this,
            initialized: !1,
            contexts: {},
            on: {
                init: {},
                load: {},
                prepare: {},
                before: {},
                start: {},
                success: {},
                complete: {},
                error: {}
            },
            fire: function() {
                var result = !0, args = Array.prototype.slice.call(arguments), props = args.shift(), name = "string" == typeof props ? props : props.name, off = "object" == typeof props ? props.off || {} : {};
                return args.push(inner.self), $.each(inner.on[name], function(index, reaction) {
                    if (reaction === undefined || -1 !== $.inArray(index, off)) return !0;
                    var temp = reaction.apply(inner.contexts[index], args);
                    return result = temp === undefined || temp;
                }), result;
            },
            requestHandler: function(e) {
                var xhr = inner.self.ajax({}, this, e);
                return xhr && xhr._returnFalse ? !1 : void 0;
            },
            ext: function(callbacks, context, name) {
                for (;!name; ) name = "ext_" + Math.random(), inner.contexts[name] && (name = undefined);
                $.each(callbacks, function(event, callback) {
                    inner.on[event][name] = callback;
                }), inner.contexts[name] = $.extend(context ? context : {}, {
                    name: function() {
                        return name;
                    },
                    ext: function(name, force) {
                        var ext = inner.contexts[name];
                        if (!ext && force) throw "Extension '" + this.name() + "' depends on disabled extension '" + name + "'.";
                        return ext;
                    }
                });
            }
        };
        /**
	 * Allows manipulation with extensions.
	 * When called with 1. argument only, it returns extension with given name.
	 * When called with 2. argument equal to false, it removes extension entirely.
	 * When called with 2. argument equal to hash of event callbacks, it adds new extension.
	 *
	 * @param  {string} Name of extension
	 * @param  {bool|object|null} Set of callbacks for any events OR false for removing extension.
	 * @param  {object|null} Context for added extension
	 * @return {$.nette|object} Provides a fluent interface OR returns extensions with given name
	 */
        this.ext = function(name, callbacks, context) {
            if ("object" == typeof name) inner.ext(name, callbacks); else {
                if (callbacks === undefined) return inner.contexts[name];
                if (callbacks) {
                    if ("string" == typeof name && inner.contexts[name] !== undefined) throw "Cannot override already registered nette-ajax extension '" + name + "'.";
                    inner.ext(callbacks, context, name);
                } else $.each([ "init", "load", "prepare", "before", "start", "success", "complete", "error" ], function(index, event) {
                    inner.on[event][name] = undefined;
                }), inner.contexts[name] = undefined;
            }
            return this;
        }, /**
	 * Initializes the plugin:
	 * - fires 'init' event, then 'load' event
	 * - when called with any arguments, it will override default 'init' extension
	 *   with provided callbacks
	 *
	 * @param  {function|object|null} Callback for 'load' event or entire set of callbacks for any events
	 * @param  {object|null} Context provided for callbacks in first argument
	 * @return {$.nette} Provides a fluent interface
	 */
        this.init = function(load, loadContext) {
            if (inner.initialized) throw "Cannot initialize nette-ajax twice.";
            if ("function" == typeof load) this.ext("init", null), this.ext("init", {
                load: load
            }, loadContext); else if ("object" == typeof load) this.ext("init", null), this.ext("init", load, loadContext); else if (load !== undefined) throw "Argument of init() can be function or function-hash only.";
            return inner.initialized = !0, inner.fire("init"), this.load(), this;
        }, /**
	 * Fires 'load' event
	 *
	 * @return {$.nette} Provides a fluent interface
	 */
        this.load = function() {
            return inner.fire("load", inner.requestHandler), this;
        }, /**
	 * Executes AJAX request. Attaches listeners and events.
	 *
	 * @param  {object} settings
	 * @param  {Element|null} ussually Anchor or Form
	 * @param  {event|null} event causing the request
	 * @return {jqXHR|null}
	 */
        this.ajax = function(settings, ui, e) {
            if (!settings.nette && ui && e) {
                var originalBeforeSend, $el = $(ui), analyze = settings.nette = {
                    e: e,
                    ui: ui,
                    el: $el,
                    isForm: $el.is("form"),
                    isSubmit: $el.is("input[type=submit]") || $el.is("button[type=submit]"),
                    isImage: $el.is("input[type=image]"),
                    form: null
                };
                if (analyze.isSubmit || analyze.isImage ? analyze.form = analyze.el.closest("form") : analyze.isForm && (analyze.form = analyze.el), 
                settings.url || (settings.url = analyze.form ? analyze.form.attr("action") : ui.href), 
                settings.type || (settings.type = analyze.form ? analyze.form.attr("method") : "get"), 
                $el.is("[data-ajax-off]")) {
                    var rawOff = $el.attr("data-ajax-off");
                    0 === rawOff.indexOf("[") ? settings.off = $el.data("ajaxOff") : -1 !== rawOff.indexOf(",") ? settings.off = rawOff.split(",") : -1 !== rawOff.indexOf(" ") ? settings.off = rawOff.split(" ") : settings.off = rawOff, 
                    "string" == typeof settings.off && (settings.off = [ settings.off ]), settings.off = $.grep($.each(settings.off, function(off) {
                        return $.trim(off);
                    }), function(off) {
                        return off.length;
                    });
                }
            }
            return inner.fire({
                name: "prepare",
                off: settings.off || {}
            }, settings), settings.prepare && settings.prepare(settings), originalBeforeSend = settings.beforeSend, 
            settings.beforeSend = function(xhr, settings) {
                var result = inner.fire({
                    name: "before",
                    off: settings.off || {}
                }, xhr, settings);
                return (result || result === undefined) && originalBeforeSend && (result = originalBeforeSend(xhr, settings)), 
                result;
            }, this.handleXHR($.ajax(settings), settings);
        }, /**
	 * Binds extension callbacks to existing XHR object
	 *
	 * @param  {jqXHR|null}
	 * @param  {object} settings
	 * @return {jqXHR|null}
	 */
        this.handleXHR = function(xhr, settings) {
            return settings = settings || {}, !xhr || "undefined" != typeof xhr.statusText && "canceled" === xhr.statusText || (xhr.done(function(payload, status, xhr) {
                inner.fire({
                    name: "success",
                    off: settings.off || {}
                }, payload, status, xhr, settings);
            }).fail(function(xhr, status, error) {
                inner.fire({
                    name: "error",
                    off: settings.off || {}
                }, xhr, status, error, settings);
            }).always(function(xhr, status) {
                inner.fire({
                    name: "complete",
                    off: settings.off || {}
                }, xhr, status, settings);
            }), inner.fire({
                name: "start",
                off: settings.off || {}
            }, xhr, settings), settings.start && settings.start(xhr, settings)), xhr;
        };
    };
    $.nette = new ($.extend(nette, $.nette ? $.nette : {}))(), $.fn.netteAjax = function(e, options) {
        return $.nette.ajax(options || {}, this[0], e);
    }, $.fn.netteAjaxOff = function() {
        return this.off(".nette");
    }, $.nette.ext("validation", {
        before: function(xhr, settings) {
            if (!settings.nette) return !0;
            var analyze = settings.nette, e = analyze.e, validate = $.extend({
                keys: !0,
                url: !0,
                form: !0
            }, settings.validate || function() {
                if (analyze.el.is("[data-ajax-validate]")) {
                    var attr = analyze.el.data("ajaxValidate");
                    return attr === !1 ? {
                        keys: !1,
                        url: !1,
                        form: !1
                    } : "object" == typeof attr ? attr : void 0;
                }
            }() || {}), passEvent = !1;
            if (analyze.el.attr("data-ajax-pass") !== undefined && (passEvent = analyze.el.data("ajaxPass"), 
            passEvent = "bool" == typeof passEvent ? passEvent : !0), validate.keys) {
                // thx to @vrana
                var explicitNoAjax = e.button || e.ctrlKey || e.shiftKey || e.altKey || e.metaKey;
                if (analyze.form) {
                    if (explicitNoAjax && analyze.isSubmit) return this.explicitNoAjax = !0, !1;
                    if (analyze.isForm && this.explicitNoAjax) return this.explicitNoAjax = !1, !1;
                } else if (explicitNoAjax) return !1;
            }
            return validate.form && analyze.form && (!analyze.isSubmit && !analyze.isImage || analyze.el.attr("formnovalidate") === undefined) && analyze.form.get(0).onsubmit && analyze.form.get(0).onsubmit(e) === !1 ? (e.stopImmediatePropagation(), 
            e.preventDefault(), !1) : validate.url && /:|^#/.test(analyze.form ? settings.url : analyze.el.attr("href")) ? !1 : (passEvent || (e.stopPropagation(), 
            e.preventDefault(), xhr._returnFalse = !0), !0);
        }
    }, {
        explicitNoAjax: !1
    }), $.nette.ext("forms", {
        init: function() {
            var snippets;
            window.Nette && (snippets = this.ext("snippets")) && snippets.after(function($el) {
                $el.find("form").each(function() {
                    window.Nette.initForm(this);
                });
            });
        },
        prepare: function(settings) {
            var analyze = settings.nette;
            if (analyze && analyze.form) {
                var e = analyze.e, originalData = settings.data || {}, formData = {};
                if (analyze.isSubmit) formData[analyze.el.attr("name")] = analyze.el.val() || ""; else if (analyze.isImage) {
                    var offset = analyze.el.offset(), name = analyze.el.attr("name"), dataOffset = [ Math.max(0, e.pageX - offset.left), Math.max(0, e.pageY - offset.top) ];
                    -1 !== name.indexOf("[", 0) ? // inside a container
                    formData[name] = dataOffset : (formData[name + ".x"] = dataOffset[0], formData[name + ".y"] = dataOffset[1]);
                }
                "string" != typeof originalData && (originalData = $.param(originalData)), formData = $.param(formData), 
                settings.data = analyze.form.serialize() + (formData ? "&" + formData : "") + "&" + originalData;
            }
        }
    }), // default snippet handler
    $.nette.ext("snippets", {
        success: function(payload) {
            payload.snippets && this.updateSnippets(payload.snippets);
        }
    }, {
        beforeQueue: $.Callbacks(),
        afterQueue: $.Callbacks(),
        completeQueue: $.Callbacks(),
        before: function(callback) {
            this.beforeQueue.add(callback);
        },
        after: function(callback) {
            this.afterQueue.add(callback);
        },
        complete: function(callback) {
            this.completeQueue.add(callback);
        },
        updateSnippets: function(snippets, back) {
            var that = this, elements = [];
            for (var i in snippets) {
                var $el = this.getElement(i);
                $el.get(0) && elements.push($el.get(0)), this.updateSnippet($el, snippets[i], back);
            }
            $(elements).promise().done(function() {
                that.completeQueue.fire();
            });
        },
        updateSnippet: function($el, html, back) {
            // Fix for setting document title in IE
            $el.is("title") ? document.title = html : (this.beforeQueue.fire($el), this.applySnippet($el, html, back), 
            this.afterQueue.fire($el));
        },
        getElement: function(id) {
            return $("#" + this.escapeSelector(id));
        },
        applySnippet: function($el, html, back) {
            !back && $el.is("[data-ajax-append]") ? $el.append(html) : $el.html(html);
        },
        escapeSelector: function(selector) {
            // thx to @uestla (https://github.com/uestla)
            return selector.replace(/[\!"#\$%&'\(\)\*\+,\.\/:;<=>\?@\[\\\]\^`\{\|\}~]/g, "\\$&");
        }
    }), // support $this->redirect()
    $.nette.ext("redirect", {
        success: function(payload) {
            return payload.redirect ? (window.location.href = payload.redirect, !1) : void 0;
        }
    }), // current page state
    $.nette.ext("state", {
        success: function(payload) {
            payload.state && (this.state = payload.state);
        }
    }, {
        state: null
    }), // abort last request if new started
    $.nette.ext("unique", {
        start: function(xhr) {
            this.xhr && this.xhr.abort(), this.xhr = xhr;
        },
        complete: function() {
            this.xhr = null;
        }
    }, {
        xhr: null
    }), // option to abort by ESC (thx to @vrana)
    $.nette.ext("abort", {
        init: function() {
            $("body").keydown($.proxy(function(e) {
                this.xhr && "27" === e.keyCode.toString() && !(e.ctrlKey || e.shiftKey || e.altKey || e.metaKey) && this.xhr.abort();
            }, this));
        },
        start: function(xhr) {
            this.xhr = xhr;
        },
        complete: function() {
            this.xhr = null;
        }
    }, {
        xhr: null
    }), $.nette.ext("load", {
        success: function() {
            $.nette.load();
        }
    }), // default ajaxification (can be overridden in init())
    $.nette.ext("init", {
        load: function(rh) {
            $(this.linkSelector).off("click.nette", rh).on("click.nette", rh), $(this.formSelector).off("submit.nette", rh).on("submit.nette", rh).off("click.nette", ":image", rh).on("click.nette", ":image", rh).off("click.nette", ":submit", rh).on("click.nette", ":submit", rh), 
            $(this.buttonSelector).closest("form").off("click.nette", this.buttonSelector, rh).on("click.nette", this.buttonSelector, rh);
        }
    }, {
        linkSelector: "a.ajax",
        formSelector: "form.ajax",
        buttonSelector: 'input.ajax[type="submit"], button.ajax[type="submit"], input.ajax[type="image"]'
    });
}(window, window.jQuery), /*
 * Author: Ondej Vodek <ondrej.vodacek@gmail.com>
 * License: New BSD License
 *
 * Copyright (c) 2011, Ondej Vodek
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Ondej Vodek nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL Ondej Vodek BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Sources:
 * http://stackoverflow.com/questions/2208480/jquery-date-picker-to-show-month-year-only
 * http://stackoverflow.com/questions/2224135/can-i-highlight-an-entire-week-in-the-standard-jquery-ui-date-picker
 * http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
 */
function($, Nette) {
    "use strict";
    /***************************************************************************
	 * override datepicker formatDate method for week formating support
	 **************************************************************************/
    var proxied = $.datepicker.formatDate;
    $.datepicker.formatDate = function(format, date, settings) {
        // mostly from jquery.ui.datepicker.js
        if (!date) return "";
        for (var lookAhead = function(match) {
            var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
            return matches && iFormat++, matches;
        }, formatNumber = function(match, value, len) {
            var num = "" + value;
            if (lookAhead(match)) for (;num.length < len; ) num = "0" + num;
            return num;
        }, output = "", literal = !1, iFormat = 0; iFormat < format.length; iFormat++) if (literal) "'" === format.charAt(iFormat) && (literal = !1), 
        output += format.charAt(iFormat); else switch (format.charAt(iFormat)) {
          case "w":
            output += formatNumber("w", $.datepicker.iso8601Week(date), 2);
            break;

          case "'":
            output += "'", literal = !0;
            break;

          default:
            output += format.charAt(iFormat);
        }
        return arguments[0] = output, proxied.apply(this, arguments);
    };
    /* *************************************************************************
	 * date parsing functions
	 **************************************************************************/
    var parseWeek = function(date) {
        // 2011-W05
        if (8 !== date.length) return null;
        var year = parseInt(date.substr(0, 4), 10), week = parseInt(date.substr(6, 2), 10), correctionDate = new Date(year, 0, 4), correction = correctionDate.getDay();
        0 === correction && (correction = 7);
        // let the Date object do the math for calculating the correct month and day
        var day = new Date(year, 0, 7 * week + 1 - correction);
        return day;
    }, parseTime = function(time) {
        // 12:12[:12]
        if (time.length < 5) return null;
        var d = new Date();
        //hour
        //minute
        return d.setHours(parseInt(time.substr(0, 2), 10), parseInt(time.substr(3, 2), 10), time.length >= 8 ? parseInt(time.substr(6, 2), 10) : 0), 
        d;
    }, parseDate = function(datetime) {
        // 2011-05-08
        // 2011-05-08
        //year
        //month
        return datetime.length < 10 ? null : new Date(parseInt(datetime.substr(0, 4), 10), parseInt(datetime.substr(5, 2), 10) - 1, parseInt(datetime.substr(8, 2), 10));
    }, parseDateTime = function(datetime) {
        // 2011-05-08T12:12[:12]
        if (datetime.length < 19) return null;
        var date = parseDate(datetime), time = parseTime(datetime.substr(11));
        return date.setHours(time.getHours(), time.getMinutes(), time.getSeconds()), date;
    }, parseMonth = function(date) {
        // 2011-05
        return parseDate(date + "-01");
    }, globalSettings = {
        datetime: {
            parseFunction: parseDateTime,
            create: function(object, settings) {
                return object.datetimepicker(settings);
            },
            dateFormat: "yy-mm-dd",
            timeFormat: "HH:mm",
            validFormat: "\\d{4}-\\d{2}-\\d{2}"
        },
        date: {
            parseFunction: parseDate,
            create: function(object, settings) {
                return object.datepicker(settings);
            },
            dateFormat: "yy-mm-dd",
            validFormat: "\\d{4}-\\d{2}-\\d{2}"
        },
        month: {
            parseFunction: parseMonth,
            create: function(object, settings) {
                return object.datepicker(settings);
            },
            dateFormat: "yy-mm",
            validFormat: "\\d{4}-\\d{2}"
        },
        week: {
            parseFunction: parseWeek,
            create: function(object, settings) {
                return object.datepicker(settings);
            },
            dateFormat: "yy-Www",
            validFormat: "\\d{4}-W\\d{2}"
        },
        time: {
            parseFunction: parseTime,
            create: function(object, settings) {
                return object.timepicker(settings);
            },
            timeFormat: "HH:mm",
            validFormat: "\\d{2}:\\d{2}"
        }
    };
    globalSettings["datetime-local"] = globalSettings.datetime, globalSettings["datetime-local"].validFormat += ".*", 
    // timezone
    $.fn.dateinput = function(userSettings) {
        return this.each(function() {
            var t = $(this);
            if (!t.data("altField")) {
                var type = t.attr("data-dateinput-type"), settings = globalSettings[type], pickerSettings = {
                    onClose: function(date) {
                        "" === date && alt.val("");
                    }
                };
                userSettings = userSettings || {}, userSettings.options && $.extend(pickerSettings, userSettings.options), 
                userSettings[type] && ($.extend(settings, userSettings[type]), userSettings[type].options && $.extend(pickerSettings, userSettings[type].options)), 
                // create alt field
                this.type = "text";
                var alt = t.clone().removeAttr("id");
                try {
                    alt.get(0).type = "hidden";
                } catch (exception) {
                    // fix for: http://webbugtrack.blogspot.com/2007/09/bug-237-type-is-readonly-attribute-in.html
                    alt = $(alt.get(0).outerHTML.replace(/ type=(['"]?)[a-z-]+\1/, ' type="hidden"'));
                }
                alt.attr("data-dateinput-type", null), alt.attr("data-nette-rules", null), t.val(null), 
                t.after(alt), t.data("altField", alt);
                // min and max date
                var min = alt.attr("min");
                min && (pickerSettings.minDate = settings.parseFunction(min));
                var max = alt.attr("max");
                max && (pickerSettings.maxDate = settings.parseFunction(max));
                var selectedDate = null, date = alt.val();
                //
                switch (date && (selectedDate = settings.parseFunction(date)), settings.dateFormat && (pickerSettings.dateFormat = settings.dateFormat), 
                settings.timeFormat && (pickerSettings.timeFormat = settings.timeFormat, pickerSettings.pickerTimeFormat = settings.timeFormat), 
                type) {
                  case "datetime":
                  case "datetime-local":
                    $.extend(pickerSettings, {
                        altFieldTimeOnly: !1,
                        altField: alt,
                        altFormat: "yy-mm-dd",
                        altSeparator: "T",
                        altTimeFormat: "HH:mm:ss",
                        altTimeSuffix: "datetime" === type ? "Z" : "",
                        stepHour: 1,
                        stepMinute: 1,
                        showButtonPanel: !0
                    });
                    break;

                  case "date":
                    $.extend(pickerSettings, {
                        altField: alt,
                        altFormat: "yy-mm-dd",
                        showButtonPanel: !0,
                        showOtherMonths: !0
                    });
                    break;

                  case "month":
                    $.extend(pickerSettings, {
                        altField: alt,
                        altFormat: "yy-mm",
                        showButtonPanel: !0,
                        showOtherMonths: !0,
                        beforeShow: function() {
                            selectedDate && ($(this).datepicker("option", "defaultDate", selectedDate), $(this).datepicker("setDate", selectedDate));
                        },
                        beforeShowDay: function(day) {
                            var c = "ui-datepicker-month";
                            selectedDate && selectedDate.getFullYear() === day.getFullYear() && selectedDate.getMonth() === day.getMonth() && (c += " ui-datepicker-month-selected");
                            var now = new Date();
                            return day.getFullYear() === now.getFullYear() && day.getMonth() === now.getMonth() && (c += " ui-datepicker-month-current"), 
                            [ !0, c ];
                        },
                        onSelect: function(day, inst) {
                            selectedDate = new Date(inst.selectedYear, inst.selectedMonth, 1), t.datepicker("setDate", selectedDate), 
                            inst.input.blur();
                        }
                    }), pickerSettings.maxDate && pickerSettings.maxDate.setMonth(pickerSettings.maxDate.getMonth() + 1, 0);
                    break;

                  case "week":
                    $.extend(pickerSettings, {
                        altField: alt,
                        altFormat: "yy-Www",
                        showButtonPanel: !0,
                        showOtherMonths: !0,
                        showWeek: !0,
                        beforeShow: function() {
                            selectedDate && (t.datepicker("option", "defaultDate", selectedDate), t.datepicker("setDate", selectedDate));
                        },
                        beforeShowDay: function(day) {
                            var c = "ui-datepicker-week";
                            selectedDate && $.datepicker.iso8601Week(selectedDate) === $.datepicker.iso8601Week(day) && selectedDate.getFullYear() === day.getFullYear() && (c += " ui-datepicker-week-selected");
                            var now = new Date();
                            return $.datepicker.iso8601Week(day) === $.datepicker.iso8601Week(now) && day.getFullYear() === now.getFullYear() && (c += " ui-datepicker-week-current"), 
                            [ !0, c ];
                        },
                        onSelect: function(day, inst) {
                            selectedDate = new Date(inst.selectedYear, inst.selectedMonth, inst.selectedDay), 
                            selectedDate.setDate(selectedDate.getDate() - (selectedDate.getDay() + 6) % 7 + 3), 
                            t.datepicker("setDate", selectedDate), inst.input.blur();
                        }
                    }), pickerSettings.maxDate && pickerSettings.maxDate.setDate(pickerSettings.maxDate.getDate() + 6);
                    break;

                  case "time":
                    $.extend(pickerSettings, {
                        altFieldTimeOnly: !1,
                        altField: alt,
                        altFormat: "",
                        dateFormat: "",
                        altSeparator: "",
                        separator: "",
                        altTimeFormat: "HH:mm:ss",
                        stepHour: 1,
                        stepMinute: 1,
                        showButtonPanel: !0
                    });
                }
                settings.create(t, pickerSettings), selectedDate && t.datepicker("setDate", selectedDate);
            }
        }), this;
    }, // Nette validators
    Nette.validators.VodacekFormsControlsDateInput_validateDateInputValid = function(elem, arg, val) {
        var el = $(elem), type = el.attr("data-dateinput-type"), format = globalSettings[type].validFormat;
        return val = el.data("altField").val(), new RegExp("^(" + format + ")$").test(val);
    }, Nette.validators.VodacekFormsControlsDateInput_validateDateInputRange = function(elem, arg, val) {
        var el = $(elem);
        return val = el.data("altField").val(), Nette.isArray(arg) ? (null === arg[0] || val >= arg[0]) && (null === arg[1] || val <= arg[1]) : null;
    };
}(jQuery, Nette), /*!
 * typeahead.js 0.10.5
 * https://github.com/twitter/typeahead.js
 * Copyright 2013-2014 Twitter, Inc. and other contributors; Licensed MIT
 */
function($) {
    var _ = function() {
        "use strict";
        return {
            isMsie: function() {
                return /(msie|trident)/i.test(navigator.userAgent) ? navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2] : !1;
            },
            isBlankString: function(str) {
                return !str || /^\s*$/.test(str);
            },
            escapeRegExChars: function(str) {
                return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
            },
            isString: function(obj) {
                return "string" == typeof obj;
            },
            isNumber: function(obj) {
                return "number" == typeof obj;
            },
            isArray: $.isArray,
            isFunction: $.isFunction,
            isObject: $.isPlainObject,
            isUndefined: function(obj) {
                return "undefined" == typeof obj;
            },
            toStr: function(s) {
                return _.isUndefined(s) || null === s ? "" : s + "";
            },
            bind: $.proxy,
            each: function(collection, cb) {
                function reverseArgs(index, value) {
                    return cb(value, index);
                }
                $.each(collection, reverseArgs);
            },
            map: $.map,
            filter: $.grep,
            every: function(obj, test) {
                var result = !0;
                return obj ? ($.each(obj, function(key, val) {
                    return (result = test.call(null, val, key, obj)) ? void 0 : !1;
                }), !!result) : result;
            },
            some: function(obj, test) {
                var result = !1;
                return obj ? ($.each(obj, function(key, val) {
                    return (result = test.call(null, val, key, obj)) ? !1 : void 0;
                }), !!result) : result;
            },
            mixin: $.extend,
            getUniqueId: function() {
                var counter = 0;
                return function() {
                    return counter++;
                };
            }(),
            templatify: function(obj) {
                function template() {
                    return String(obj);
                }
                return $.isFunction(obj) ? obj : template;
            },
            defer: function(fn) {
                setTimeout(fn, 0);
            },
            debounce: function(func, wait, immediate) {
                var timeout, result;
                return function() {
                    var later, callNow, context = this, args = arguments;
                    return later = function() {
                        timeout = null, immediate || (result = func.apply(context, args));
                    }, callNow = immediate && !timeout, clearTimeout(timeout), timeout = setTimeout(later, wait), 
                    callNow && (result = func.apply(context, args)), result;
                };
            },
            throttle: function(func, wait) {
                var context, args, timeout, result, previous, later;
                return previous = 0, later = function() {
                    previous = new Date(), timeout = null, result = func.apply(context, args);
                }, function() {
                    var now = new Date(), remaining = wait - (now - previous);
                    return context = this, args = arguments, 0 >= remaining ? (clearTimeout(timeout), 
                    timeout = null, previous = now, result = func.apply(context, args)) : timeout || (timeout = setTimeout(later, remaining)), 
                    result;
                };
            },
            noop: function() {}
        };
    }(), VERSION = "0.10.5", tokenizers = function() {
        "use strict";
        function whitespace(str) {
            return str = _.toStr(str), str ? str.split(/\s+/) : [];
        }
        function nonword(str) {
            return str = _.toStr(str), str ? str.split(/\W+/) : [];
        }
        function getObjTokenizer(tokenizer) {
            return function() {
                var args = [].slice.call(arguments, 0);
                return function(o) {
                    var tokens = [];
                    return _.each(args, function(k) {
                        tokens = tokens.concat(tokenizer(_.toStr(o[k])));
                    }), tokens;
                };
            };
        }
        return {
            nonword: nonword,
            whitespace: whitespace,
            obj: {
                nonword: getObjTokenizer(nonword),
                whitespace: getObjTokenizer(whitespace)
            }
        };
    }(), LruCache = function() {
        "use strict";
        function LruCache(maxSize) {
            this.maxSize = _.isNumber(maxSize) ? maxSize : 100, this.reset(), this.maxSize <= 0 && (this.set = this.get = $.noop);
        }
        function List() {
            this.head = this.tail = null;
        }
        function Node(key, val) {
            this.key = key, this.val = val, this.prev = this.next = null;
        }
        return _.mixin(LruCache.prototype, {
            set: function(key, val) {
                var node, tailItem = this.list.tail;
                this.size >= this.maxSize && (this.list.remove(tailItem), delete this.hash[tailItem.key]), 
                (node = this.hash[key]) ? (node.val = val, this.list.moveToFront(node)) : (node = new Node(key, val), 
                this.list.add(node), this.hash[key] = node, this.size++);
            },
            get: function(key) {
                var node = this.hash[key];
                return node ? (this.list.moveToFront(node), node.val) : void 0;
            },
            reset: function() {
                this.size = 0, this.hash = {}, this.list = new List();
            }
        }), _.mixin(List.prototype, {
            add: function(node) {
                this.head && (node.next = this.head, this.head.prev = node), this.head = node, this.tail = this.tail || node;
            },
            remove: function(node) {
                node.prev ? node.prev.next = node.next : this.head = node.next, node.next ? node.next.prev = node.prev : this.tail = node.prev;
            },
            moveToFront: function(node) {
                this.remove(node), this.add(node);
            }
        }), LruCache;
    }(), PersistentStorage = function() {
        "use strict";
        function PersistentStorage(namespace) {
            this.prefix = [ "__", namespace, "__" ].join(""), this.ttlKey = "__ttl__", this.keyMatcher = new RegExp("^" + _.escapeRegExChars(this.prefix));
        }
        function now() {
            return new Date().getTime();
        }
        function encode(val) {
            return JSON.stringify(_.isUndefined(val) ? null : val);
        }
        function decode(val) {
            return JSON.parse(val);
        }
        var ls, methods;
        try {
            ls = window.localStorage, ls.setItem("~~~", "!"), ls.removeItem("~~~");
        } catch (err) {
            ls = null;
        }
        return methods = ls && window.JSON ? {
            _prefix: function(key) {
                return this.prefix + key;
            },
            _ttlKey: function(key) {
                return this._prefix(key) + this.ttlKey;
            },
            get: function(key) {
                return this.isExpired(key) && this.remove(key), decode(ls.getItem(this._prefix(key)));
            },
            set: function(key, val, ttl) {
                return _.isNumber(ttl) ? ls.setItem(this._ttlKey(key), encode(now() + ttl)) : ls.removeItem(this._ttlKey(key)), 
                ls.setItem(this._prefix(key), encode(val));
            },
            remove: function(key) {
                return ls.removeItem(this._ttlKey(key)), ls.removeItem(this._prefix(key)), this;
            },
            clear: function() {
                var i, key, keys = [], len = ls.length;
                for (i = 0; len > i; i++) (key = ls.key(i)).match(this.keyMatcher) && keys.push(key.replace(this.keyMatcher, ""));
                for (i = keys.length; i--; ) this.remove(keys[i]);
                return this;
            },
            isExpired: function(key) {
                var ttl = decode(ls.getItem(this._ttlKey(key)));
                return _.isNumber(ttl) && now() > ttl ? !0 : !1;
            }
        } : {
            get: _.noop,
            set: _.noop,
            remove: _.noop,
            clear: _.noop,
            isExpired: _.noop
        }, _.mixin(PersistentStorage.prototype, methods), PersistentStorage;
    }(), Transport = function() {
        "use strict";
        function Transport(o) {
            o = o || {}, this.cancelled = !1, this.lastUrl = null, this._send = o.transport ? callbackToDeferred(o.transport) : $.ajax, 
            this._get = o.rateLimiter ? o.rateLimiter(this._get) : this._get, this._cache = o.cache === !1 ? new LruCache(0) : sharedCache;
        }
        function callbackToDeferred(fn) {
            return function(url, o) {
                function onSuccess(resp) {
                    _.defer(function() {
                        deferred.resolve(resp);
                    });
                }
                function onError(err) {
                    _.defer(function() {
                        deferred.reject(err);
                    });
                }
                var deferred = $.Deferred();
                return fn(url, o, onSuccess, onError), deferred;
            };
        }
        var pendingRequestsCount = 0, pendingRequests = {}, maxPendingRequests = 6, sharedCache = new LruCache(10);
        return Transport.setMaxPendingRequests = function(num) {
            maxPendingRequests = num;
        }, Transport.resetCache = function() {
            sharedCache.reset();
        }, _.mixin(Transport.prototype, {
            _get: function(url, o, cb) {
                function done(resp) {
                    cb && cb(null, resp), that._cache.set(url, resp);
                }
                function fail() {
                    cb && cb(!0);
                }
                function always() {
                    pendingRequestsCount--, delete pendingRequests[url], that.onDeckRequestArgs && (that._get.apply(that, that.onDeckRequestArgs), 
                    that.onDeckRequestArgs = null);
                }
                var jqXhr, that = this;
                this.cancelled || url !== this.lastUrl || ((jqXhr = pendingRequests[url]) ? jqXhr.done(done).fail(fail) : maxPendingRequests > pendingRequestsCount ? (pendingRequestsCount++, 
                pendingRequests[url] = this._send(url, o).done(done).fail(fail).always(always)) : this.onDeckRequestArgs = [].slice.call(arguments, 0));
            },
            get: function(url, o, cb) {
                var resp;
                return _.isFunction(o) && (cb = o, o = {}), this.cancelled = !1, this.lastUrl = url, 
                (resp = this._cache.get(url)) ? _.defer(function() {
                    cb && cb(null, resp);
                }) : this._get(url, o, cb), !!resp;
            },
            cancel: function() {
                this.cancelled = !0;
            }
        }), Transport;
    }(), SearchIndex = function() {
        "use strict";
        function SearchIndex(o) {
            o = o || {}, o.datumTokenizer && o.queryTokenizer || $.error("datumTokenizer and queryTokenizer are both required"), 
            this.datumTokenizer = o.datumTokenizer, this.queryTokenizer = o.queryTokenizer, 
            this.reset();
        }
        function normalizeTokens(tokens) {
            return tokens = _.filter(tokens, function(token) {
                return !!token;
            }), tokens = _.map(tokens, function(token) {
                return token.toLowerCase();
            });
        }
        function newNode() {
            return {
                ids: [],
                children: {}
            };
        }
        function unique(array) {
            for (var seen = {}, uniques = [], i = 0, len = array.length; len > i; i++) seen[array[i]] || (seen[array[i]] = !0, 
            uniques.push(array[i]));
            return uniques;
        }
        function getIntersection(arrayA, arrayB) {
            function compare(a, b) {
                return a - b;
            }
            var ai = 0, bi = 0, intersection = [];
            arrayA = arrayA.sort(compare), arrayB = arrayB.sort(compare);
            for (var lenArrayA = arrayA.length, lenArrayB = arrayB.length; lenArrayA > ai && lenArrayB > bi; ) arrayA[ai] < arrayB[bi] ? ai++ : arrayA[ai] > arrayB[bi] ? bi++ : (intersection.push(arrayA[ai]), 
            ai++, bi++);
            return intersection;
        }
        return _.mixin(SearchIndex.prototype, {
            bootstrap: function(o) {
                this.datums = o.datums, this.trie = o.trie;
            },
            add: function(data) {
                var that = this;
                data = _.isArray(data) ? data : [ data ], _.each(data, function(datum) {
                    var id, tokens;
                    id = that.datums.push(datum) - 1, tokens = normalizeTokens(that.datumTokenizer(datum)), 
                    _.each(tokens, function(token) {
                        var node, chars, ch;
                        for (node = that.trie, chars = token.split(""); ch = chars.shift(); ) node = node.children[ch] || (node.children[ch] = newNode()), 
                        node.ids.push(id);
                    });
                });
            },
            get: function(query) {
                var tokens, matches, that = this;
                return tokens = normalizeTokens(this.queryTokenizer(query)), _.each(tokens, function(token) {
                    var node, chars, ch, ids;
                    if (matches && 0 === matches.length) return !1;
                    for (node = that.trie, chars = token.split(""); node && (ch = chars.shift()); ) node = node.children[ch];
                    return node && 0 === chars.length ? (ids = node.ids.slice(0), void (matches = matches ? getIntersection(matches, ids) : ids)) : (matches = [], 
                    !1);
                }), matches ? _.map(unique(matches), function(id) {
                    return that.datums[id];
                }) : [];
            },
            reset: function() {
                this.datums = [], this.trie = newNode();
            },
            serialize: function() {
                return {
                    datums: this.datums,
                    trie: this.trie
                };
            }
        }), SearchIndex;
    }(), oParser = function() {
        "use strict";
        function getLocal(o) {
            return o.local || null;
        }
        function getPrefetch(o) {
            var prefetch, defaults;
            return defaults = {
                url: null,
                thumbprint: "",
                ttl: 864e5,
                filter: null,
                ajax: {}
            }, (prefetch = o.prefetch || null) && (prefetch = _.isString(prefetch) ? {
                url: prefetch
            } : prefetch, prefetch = _.mixin(defaults, prefetch), prefetch.thumbprint = VERSION + prefetch.thumbprint, 
            prefetch.ajax.type = prefetch.ajax.type || "GET", prefetch.ajax.dataType = prefetch.ajax.dataType || "json", 
            !prefetch.url && $.error("prefetch requires url to be set")), prefetch;
        }
        function getRemote(o) {
            function byDebounce(wait) {
                return function(fn) {
                    return _.debounce(fn, wait);
                };
            }
            function byThrottle(wait) {
                return function(fn) {
                    return _.throttle(fn, wait);
                };
            }
            var remote, defaults;
            return defaults = {
                url: null,
                cache: !0,
                wildcard: "%QUERY",
                replace: null,
                rateLimitBy: "debounce",
                rateLimitWait: 300,
                send: null,
                filter: null,
                ajax: {}
            }, (remote = o.remote || null) && (remote = _.isString(remote) ? {
                url: remote
            } : remote, remote = _.mixin(defaults, remote), remote.rateLimiter = /^throttle$/i.test(remote.rateLimitBy) ? byThrottle(remote.rateLimitWait) : byDebounce(remote.rateLimitWait), 
            remote.ajax.type = remote.ajax.type || "GET", remote.ajax.dataType = remote.ajax.dataType || "json", 
            delete remote.rateLimitBy, delete remote.rateLimitWait, !remote.url && $.error("remote requires url to be set")), 
            remote;
        }
        return {
            local: getLocal,
            prefetch: getPrefetch,
            remote: getRemote
        };
    }();
    !function(root) {
        "use strict";
        function Bloodhound(o) {
            o && (o.local || o.prefetch || o.remote) || $.error("one of local, prefetch, or remote is required"), 
            this.limit = o.limit || 5, this.sorter = getSorter(o.sorter), this.dupDetector = o.dupDetector || ignoreDuplicates, 
            this.local = oParser.local(o), this.prefetch = oParser.prefetch(o), this.remote = oParser.remote(o), 
            this.cacheKey = this.prefetch ? this.prefetch.cacheKey || this.prefetch.url : null, 
            this.index = new SearchIndex({
                datumTokenizer: o.datumTokenizer,
                queryTokenizer: o.queryTokenizer
            }), this.storage = this.cacheKey ? new PersistentStorage(this.cacheKey) : null;
        }
        function getSorter(sortFn) {
            function sort(array) {
                return array.sort(sortFn);
            }
            function noSort(array) {
                return array;
            }
            return _.isFunction(sortFn) ? sort : noSort;
        }
        function ignoreDuplicates() {
            return !1;
        }
        var old, keys;
        return old = root.Bloodhound, keys = {
            data: "data",
            protocol: "protocol",
            thumbprint: "thumbprint"
        }, root.Bloodhound = Bloodhound, Bloodhound.noConflict = function() {
            return root.Bloodhound = old, Bloodhound;
        }, Bloodhound.tokenizers = tokenizers, _.mixin(Bloodhound.prototype, {
            _loadPrefetch: function(o) {
                function handlePrefetchResponse(resp) {
                    that.clear(), that.add(o.filter ? o.filter(resp) : resp), that._saveToStorage(that.index.serialize(), o.thumbprint, o.ttl);
                }
                var serialized, deferred, that = this;
                return (serialized = this._readFromStorage(o.thumbprint)) ? (this.index.bootstrap(serialized), 
                deferred = $.Deferred().resolve()) : deferred = $.ajax(o.url, o.ajax).done(handlePrefetchResponse), 
                deferred;
            },
            _getFromRemote: function(query, cb) {
                function handleRemoteResponse(err, resp) {
                    cb(err ? [] : that.remote.filter ? that.remote.filter(resp) : resp);
                }
                var url, uriEncodedQuery, that = this;
                if (this.transport) return query = query || "", uriEncodedQuery = encodeURIComponent(query), 
                url = this.remote.replace ? this.remote.replace(this.remote.url, query) : this.remote.url.replace(this.remote.wildcard, uriEncodedQuery), 
                this.transport.get(url, this.remote.ajax, handleRemoteResponse);
            },
            _cancelLastRemoteRequest: function() {
                this.transport && this.transport.cancel();
            },
            _saveToStorage: function(data, thumbprint, ttl) {
                this.storage && (this.storage.set(keys.data, data, ttl), this.storage.set(keys.protocol, location.protocol, ttl), 
                this.storage.set(keys.thumbprint, thumbprint, ttl));
            },
            _readFromStorage: function(thumbprint) {
                var isExpired, stored = {};
                return this.storage && (stored.data = this.storage.get(keys.data), stored.protocol = this.storage.get(keys.protocol), 
                stored.thumbprint = this.storage.get(keys.thumbprint)), isExpired = stored.thumbprint !== thumbprint || stored.protocol !== location.protocol, 
                stored.data && !isExpired ? stored.data : null;
            },
            _initialize: function() {
                function addLocalToIndex() {
                    that.add(_.isFunction(local) ? local() : local);
                }
                var deferred, that = this, local = this.local;
                return deferred = this.prefetch ? this._loadPrefetch(this.prefetch) : $.Deferred().resolve(), 
                local && deferred.done(addLocalToIndex), this.transport = this.remote ? new Transport(this.remote) : null, 
                this.initPromise = deferred.promise();
            },
            initialize: function(force) {
                return !this.initPromise || force ? this._initialize() : this.initPromise;
            },
            add: function(data) {
                this.index.add(data);
            },
            get: function(query, cb) {
                function returnRemoteMatches(remoteMatches) {
                    var matchesWithBackfill = matches.slice(0);
                    _.each(remoteMatches, function(remoteMatch) {
                        var isDuplicate;
                        return isDuplicate = _.some(matchesWithBackfill, function(match) {
                            return that.dupDetector(remoteMatch, match);
                        }), !isDuplicate && matchesWithBackfill.push(remoteMatch), matchesWithBackfill.length < that.limit;
                    }), cb && cb(that.sorter(matchesWithBackfill));
                }
                var that = this, matches = [], cacheHit = !1;
                matches = this.index.get(query), matches = this.sorter(matches).slice(0, this.limit), 
                matches.length < this.limit ? cacheHit = this._getFromRemote(query, returnRemoteMatches) : this._cancelLastRemoteRequest(), 
                cacheHit || (matches.length > 0 || !this.transport) && cb && cb(matches);
            },
            clear: function() {
                this.index.reset();
            },
            clearPrefetchCache: function() {
                this.storage && this.storage.clear();
            },
            clearRemoteCache: function() {
                this.transport && Transport.resetCache();
            },
            ttAdapter: function() {
                return _.bind(this.get, this);
            }
        }), Bloodhound;
    }(this);
    var html = function() {
        return {
            wrapper: '<span class="twitter-typeahead"></span>',
            dropdown: '<span class="tt-dropdown-menu"></span>',
            dataset: '<div class="tt-dataset-%CLASS%"></div>',
            suggestions: '<span class="tt-suggestions"></span>',
            suggestion: '<div class="tt-suggestion"></div>'
        };
    }(), css = function() {
        "use strict";
        var css = {
            wrapper: {
                position: "relative",
                display: "inline-block"
            },
            hint: {
                position: "absolute",
                top: "0",
                left: "0",
                borderColor: "transparent",
                boxShadow: "none",
                opacity: "1"
            },
            input: {
                position: "relative",
                verticalAlign: "top",
                backgroundColor: "transparent"
            },
            inputWithNoHint: {
                position: "relative",
                verticalAlign: "top"
            },
            dropdown: {
                position: "absolute",
                top: "100%",
                left: "0",
                zIndex: "100",
                display: "none"
            },
            suggestions: {
                display: "block"
            },
            suggestion: {
                whiteSpace: "nowrap",
                cursor: "pointer"
            },
            suggestionChild: {
                whiteSpace: "normal"
            },
            ltr: {
                left: "0",
                right: "auto"
            },
            rtl: {
                left: "auto",
                right: " 0"
            }
        };
        return _.isMsie() && _.mixin(css.input, {
            backgroundImage: "url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)"
        }), _.isMsie() && _.isMsie() <= 7 && _.mixin(css.input, {
            marginTop: "-1px"
        }), css;
    }(), EventBus = function() {
        "use strict";
        function EventBus(o) {
            o && o.el || $.error("EventBus initialized without el"), this.$el = $(o.el);
        }
        var namespace = "typeahead:";
        return _.mixin(EventBus.prototype, {
            trigger: function(type) {
                var args = [].slice.call(arguments, 1);
                this.$el.trigger(namespace + type, args);
            }
        }), EventBus;
    }(), EventEmitter = function() {
        "use strict";
        function on(method, types, cb, context) {
            var type;
            if (!cb) return this;
            for (types = types.split(splitter), cb = context ? bindContext(cb, context) : cb, 
            this._callbacks = this._callbacks || {}; type = types.shift(); ) this._callbacks[type] = this._callbacks[type] || {
                sync: [],
                async: []
            }, this._callbacks[type][method].push(cb);
            return this;
        }
        function onAsync(types, cb, context) {
            return on.call(this, "async", types, cb, context);
        }
        function onSync(types, cb, context) {
            return on.call(this, "sync", types, cb, context);
        }
        function off(types) {
            var type;
            if (!this._callbacks) return this;
            for (types = types.split(splitter); type = types.shift(); ) delete this._callbacks[type];
            return this;
        }
        function trigger(types) {
            var type, callbacks, args, syncFlush, asyncFlush;
            if (!this._callbacks) return this;
            for (types = types.split(splitter), args = [].slice.call(arguments, 1); (type = types.shift()) && (callbacks = this._callbacks[type]); ) syncFlush = getFlush(callbacks.sync, this, [ type ].concat(args)), 
            asyncFlush = getFlush(callbacks.async, this, [ type ].concat(args)), syncFlush() && nextTick(asyncFlush);
            return this;
        }
        function getFlush(callbacks, context, args) {
            function flush() {
                for (var cancelled, i = 0, len = callbacks.length; !cancelled && len > i; i += 1) cancelled = callbacks[i].apply(context, args) === !1;
                return !cancelled;
            }
            return flush;
        }
        function getNextTick() {
            var nextTickFn;
            return nextTickFn = window.setImmediate ? function(fn) {
                setImmediate(function() {
                    fn();
                });
            } : function(fn) {
                setTimeout(function() {
                    fn();
                }, 0);
            };
        }
        function bindContext(fn, context) {
            return fn.bind ? fn.bind(context) : function() {
                fn.apply(context, [].slice.call(arguments, 0));
            };
        }
        var splitter = /\s+/, nextTick = getNextTick();
        return {
            onSync: onSync,
            onAsync: onAsync,
            off: off,
            trigger: trigger
        };
    }(), highlight = function(doc) {
        "use strict";
        function getRegex(patterns, caseSensitive, wordsOnly) {
            for (var regexStr, escapedPatterns = [], i = 0, len = patterns.length; len > i; i++) escapedPatterns.push(_.escapeRegExChars(patterns[i]));
            return regexStr = wordsOnly ? "\\b(" + escapedPatterns.join("|") + ")\\b" : "(" + escapedPatterns.join("|") + ")", 
            caseSensitive ? new RegExp(regexStr) : new RegExp(regexStr, "i");
        }
        var defaults = {
            node: null,
            pattern: null,
            tagName: "strong",
            className: null,
            wordsOnly: !1,
            caseSensitive: !1
        };
        return function(o) {
            function hightlightTextNode(textNode) {
                var match, patternNode, wrapperNode;
                return (match = regex.exec(textNode.data)) && (wrapperNode = doc.createElement(o.tagName), 
                o.className && (wrapperNode.className = o.className), patternNode = textNode.splitText(match.index), 
                patternNode.splitText(match[0].length), wrapperNode.appendChild(patternNode.cloneNode(!0)), 
                textNode.parentNode.replaceChild(wrapperNode, patternNode)), !!match;
            }
            function traverse(el, hightlightTextNode) {
                for (var childNode, TEXT_NODE_TYPE = 3, i = 0; i < el.childNodes.length; i++) childNode = el.childNodes[i], 
                childNode.nodeType === TEXT_NODE_TYPE ? i += hightlightTextNode(childNode) ? 1 : 0 : traverse(childNode, hightlightTextNode);
            }
            var regex;
            o = _.mixin({}, defaults, o), o.node && o.pattern && (o.pattern = _.isArray(o.pattern) ? o.pattern : [ o.pattern ], 
            regex = getRegex(o.pattern, o.caseSensitive, o.wordsOnly), traverse(o.node, hightlightTextNode));
        };
    }(window.document), Input = function() {
        "use strict";
        function Input(o) {
            var onBlur, onFocus, onKeydown, onInput, that = this;
            o = o || {}, o.input || $.error("input is missing"), onBlur = _.bind(this._onBlur, this), 
            onFocus = _.bind(this._onFocus, this), onKeydown = _.bind(this._onKeydown, this), 
            onInput = _.bind(this._onInput, this), this.$hint = $(o.hint), this.$input = $(o.input).on("blur.tt", onBlur).on("focus.tt", onFocus).on("keydown.tt", onKeydown), 
            0 === this.$hint.length && (this.setHint = this.getHint = this.clearHint = this.clearHintIfInvalid = _.noop), 
            _.isMsie() ? this.$input.on("keydown.tt keypress.tt cut.tt paste.tt", function($e) {
                specialKeyCodeMap[$e.which || $e.keyCode] || _.defer(_.bind(that._onInput, that, $e));
            }) : this.$input.on("input.tt", onInput), this.query = this.$input.val(), this.$overflowHelper = buildOverflowHelper(this.$input);
        }
        function buildOverflowHelper($input) {
            return $('<pre aria-hidden="true"></pre>').css({
                position: "absolute",
                visibility: "hidden",
                whiteSpace: "pre",
                fontFamily: $input.css("font-family"),
                fontSize: $input.css("font-size"),
                fontStyle: $input.css("font-style"),
                fontVariant: $input.css("font-variant"),
                fontWeight: $input.css("font-weight"),
                wordSpacing: $input.css("word-spacing"),
                letterSpacing: $input.css("letter-spacing"),
                textIndent: $input.css("text-indent"),
                textRendering: $input.css("text-rendering"),
                textTransform: $input.css("text-transform")
            }).insertAfter($input);
        }
        function areQueriesEquivalent(a, b) {
            return Input.normalizeQuery(a) === Input.normalizeQuery(b);
        }
        function withModifier($e) {
            return $e.altKey || $e.ctrlKey || $e.metaKey || $e.shiftKey;
        }
        var specialKeyCodeMap;
        return specialKeyCodeMap = {
            9: "tab",
            27: "esc",
            37: "left",
            39: "right",
            13: "enter",
            38: "up",
            40: "down"
        }, Input.normalizeQuery = function(str) {
            return (str || "").replace(/^\s*/g, "").replace(/\s{2,}/g, " ");
        }, _.mixin(Input.prototype, EventEmitter, {
            _onBlur: function() {
                this.resetInputValue(), this.trigger("blurred");
            },
            _onFocus: function() {
                this.trigger("focused");
            },
            _onKeydown: function($e) {
                var keyName = specialKeyCodeMap[$e.which || $e.keyCode];
                this._managePreventDefault(keyName, $e), keyName && this._shouldTrigger(keyName, $e) && this.trigger(keyName + "Keyed", $e);
            },
            _onInput: function() {
                this._checkInputValue();
            },
            _managePreventDefault: function(keyName, $e) {
                var preventDefault, hintValue, inputValue;
                switch (keyName) {
                  case "tab":
                    hintValue = this.getHint(), inputValue = this.getInputValue(), preventDefault = hintValue && hintValue !== inputValue && !withModifier($e);
                    break;

                  case "up":
                  case "down":
                    preventDefault = !withModifier($e);
                    break;

                  default:
                    preventDefault = !1;
                }
                preventDefault && $e.preventDefault();
            },
            _shouldTrigger: function(keyName, $e) {
                var trigger;
                switch (keyName) {
                  case "tab":
                    trigger = !withModifier($e);
                    break;

                  default:
                    trigger = !0;
                }
                return trigger;
            },
            _checkInputValue: function() {
                var inputValue, areEquivalent, hasDifferentWhitespace;
                inputValue = this.getInputValue(), areEquivalent = areQueriesEquivalent(inputValue, this.query), 
                hasDifferentWhitespace = areEquivalent ? this.query.length !== inputValue.length : !1, 
                this.query = inputValue, areEquivalent ? hasDifferentWhitespace && this.trigger("whitespaceChanged", this.query) : this.trigger("queryChanged", this.query);
            },
            focus: function() {
                this.$input.focus();
            },
            blur: function() {
                this.$input.blur();
            },
            getQuery: function() {
                return this.query;
            },
            setQuery: function(query) {
                this.query = query;
            },
            getInputValue: function() {
                return this.$input.val();
            },
            setInputValue: function(value, silent) {
                this.$input.val(value), silent ? this.clearHint() : this._checkInputValue();
            },
            resetInputValue: function() {
                this.setInputValue(this.query, !0);
            },
            getHint: function() {
                return this.$hint.val();
            },
            setHint: function(value) {
                this.$hint.val(value);
            },
            clearHint: function() {
                this.setHint("");
            },
            clearHintIfInvalid: function() {
                var val, hint, valIsPrefixOfHint, isValid;
                val = this.getInputValue(), hint = this.getHint(), valIsPrefixOfHint = val !== hint && 0 === hint.indexOf(val), 
                isValid = "" !== val && valIsPrefixOfHint && !this.hasOverflow(), !isValid && this.clearHint();
            },
            getLanguageDirection: function() {
                return (this.$input.css("direction") || "ltr").toLowerCase();
            },
            hasOverflow: function() {
                var constraint = this.$input.width() - 2;
                return this.$overflowHelper.text(this.getInputValue()), this.$overflowHelper.width() >= constraint;
            },
            isCursorAtEnd: function() {
                var valueLength, selectionStart, range;
                return valueLength = this.$input.val().length, selectionStart = this.$input[0].selectionStart, 
                _.isNumber(selectionStart) ? selectionStart === valueLength : document.selection ? (range = document.selection.createRange(), 
                range.moveStart("character", -valueLength), valueLength === range.text.length) : !0;
            },
            destroy: function() {
                this.$hint.off(".tt"), this.$input.off(".tt"), this.$hint = this.$input = this.$overflowHelper = null;
            }
        }), Input;
    }(), Dataset = function() {
        "use strict";
        function Dataset(o) {
            o = o || {}, o.templates = o.templates || {}, o.source || $.error("missing source"), 
            o.name && !isValidName(o.name) && $.error("invalid dataset name: " + o.name), this.query = null, 
            this.highlight = !!o.highlight, this.name = o.name || _.getUniqueId(), this.source = o.source, 
            this.displayFn = getDisplayFn(o.display || o.displayKey), this.templates = getTemplates(o.templates, this.displayFn), 
            this.$el = $(html.dataset.replace("%CLASS%", this.name));
        }
        function getDisplayFn(display) {
            function displayFn(obj) {
                return obj[display];
            }
            return display = display || "value", _.isFunction(display) ? display : displayFn;
        }
        function getTemplates(templates, displayFn) {
            function suggestionTemplate(context) {
                return "<p>" + displayFn(context) + "</p>";
            }
            return {
                empty: templates.empty && _.templatify(templates.empty),
                header: templates.header && _.templatify(templates.header),
                footer: templates.footer && _.templatify(templates.footer),
                suggestion: templates.suggestion || suggestionTemplate
            };
        }
        function isValidName(str) {
            return /^[_a-zA-Z0-9-]+$/.test(str);
        }
        var datasetKey = "ttDataset", valueKey = "ttValue", datumKey = "ttDatum";
        return Dataset.extractDatasetName = function(el) {
            return $(el).data(datasetKey);
        }, Dataset.extractValue = function(el) {
            return $(el).data(valueKey);
        }, Dataset.extractDatum = function(el) {
            return $(el).data(datumKey);
        }, _.mixin(Dataset.prototype, EventEmitter, {
            _render: function(query, suggestions) {
                function getEmptyHtml() {
                    return that.templates.empty({
                        query: query,
                        isEmpty: !0
                    });
                }
                function getSuggestionsHtml() {
                    function getSuggestionNode(suggestion) {
                        var $el;
                        return $el = $(html.suggestion).append(that.templates.suggestion(suggestion)).data(datasetKey, that.name).data(valueKey, that.displayFn(suggestion)).data(datumKey, suggestion), 
                        $el.children().each(function() {
                            $(this).css(css.suggestionChild);
                        }), $el;
                    }
                    var $suggestions, nodes;
                    return $suggestions = $(html.suggestions).css(css.suggestions), nodes = _.map(suggestions, getSuggestionNode), 
                    $suggestions.append.apply($suggestions, nodes), that.highlight && highlight({
                        className: "tt-highlight",
                        node: $suggestions[0],
                        pattern: query
                    }), $suggestions;
                }
                function getHeaderHtml() {
                    return that.templates.header({
                        query: query,
                        isEmpty: !hasSuggestions
                    });
                }
                function getFooterHtml() {
                    return that.templates.footer({
                        query: query,
                        isEmpty: !hasSuggestions
                    });
                }
                if (this.$el) {
                    var hasSuggestions, that = this;
                    this.$el.empty(), hasSuggestions = suggestions && suggestions.length, !hasSuggestions && this.templates.empty ? this.$el.html(getEmptyHtml()).prepend(that.templates.header ? getHeaderHtml() : null).append(that.templates.footer ? getFooterHtml() : null) : hasSuggestions && this.$el.html(getSuggestionsHtml()).prepend(that.templates.header ? getHeaderHtml() : null).append(that.templates.footer ? getFooterHtml() : null), 
                    this.trigger("rendered");
                }
            },
            getRoot: function() {
                return this.$el;
            },
            update: function(query) {
                function render(suggestions) {
                    that.canceled || query !== that.query || that._render(query, suggestions);
                }
                var that = this;
                this.query = query, this.canceled = !1, this.source(query, render);
            },
            cancel: function() {
                this.canceled = !0;
            },
            clear: function() {
                this.cancel(), this.$el.empty(), this.trigger("rendered");
            },
            isEmpty: function() {
                return this.$el.is(":empty");
            },
            destroy: function() {
                this.$el = null;
            }
        }), Dataset;
    }(), Dropdown = function() {
        "use strict";
        function Dropdown(o) {
            var onSuggestionClick, onSuggestionMouseEnter, onSuggestionMouseLeave, that = this;
            o = o || {}, o.menu || $.error("menu is required"), this.isOpen = !1, this.isEmpty = !0, 
            this.datasets = _.map(o.datasets, initializeDataset), onSuggestionClick = _.bind(this._onSuggestionClick, this), 
            onSuggestionMouseEnter = _.bind(this._onSuggestionMouseEnter, this), onSuggestionMouseLeave = _.bind(this._onSuggestionMouseLeave, this), 
            this.$menu = $(o.menu).on("click.tt", ".tt-suggestion", onSuggestionClick).on("mouseenter.tt", ".tt-suggestion", onSuggestionMouseEnter).on("mouseleave.tt", ".tt-suggestion", onSuggestionMouseLeave), 
            _.each(this.datasets, function(dataset) {
                that.$menu.append(dataset.getRoot()), dataset.onSync("rendered", that._onRendered, that);
            });
        }
        function initializeDataset(oDataset) {
            return new Dataset(oDataset);
        }
        return _.mixin(Dropdown.prototype, EventEmitter, {
            _onSuggestionClick: function($e) {
                this.trigger("suggestionClicked", $($e.currentTarget));
            },
            _onSuggestionMouseEnter: function($e) {
                this._removeCursor(), this._setCursor($($e.currentTarget), !0);
            },
            _onSuggestionMouseLeave: function() {
                this._removeCursor();
            },
            _onRendered: function() {
                function isDatasetEmpty(dataset) {
                    return dataset.isEmpty();
                }
                this.isEmpty = _.every(this.datasets, isDatasetEmpty), this.isEmpty ? this._hide() : this.isOpen && this._show(), 
                this.trigger("datasetRendered");
            },
            _hide: function() {
                this.$menu.hide();
            },
            _show: function() {
                this.$menu.css("display", "block");
            },
            _getSuggestions: function() {
                return this.$menu.find(".tt-suggestion");
            },
            _getCursor: function() {
                return this.$menu.find(".tt-cursor").first();
            },
            _setCursor: function($el, silent) {
                $el.first().addClass("tt-cursor"), !silent && this.trigger("cursorMoved");
            },
            _removeCursor: function() {
                this._getCursor().removeClass("tt-cursor");
            },
            _moveCursor: function(increment) {
                var $suggestions, $oldCursor, newCursorIndex, $newCursor;
                if (this.isOpen) {
                    if ($oldCursor = this._getCursor(), $suggestions = this._getSuggestions(), this._removeCursor(), 
                    newCursorIndex = $suggestions.index($oldCursor) + increment, newCursorIndex = (newCursorIndex + 1) % ($suggestions.length + 1) - 1, 
                    -1 === newCursorIndex) return void this.trigger("cursorRemoved");
                    -1 > newCursorIndex && (newCursorIndex = $suggestions.length - 1), this._setCursor($newCursor = $suggestions.eq(newCursorIndex)), 
                    this._ensureVisible($newCursor);
                }
            },
            _ensureVisible: function($el) {
                var elTop, elBottom, menuScrollTop, menuHeight;
                elTop = $el.position().top, elBottom = elTop + $el.outerHeight(!0), menuScrollTop = this.$menu.scrollTop(), 
                menuHeight = this.$menu.height() + parseInt(this.$menu.css("paddingTop"), 10) + parseInt(this.$menu.css("paddingBottom"), 10), 
                0 > elTop ? this.$menu.scrollTop(menuScrollTop + elTop) : elBottom > menuHeight && this.$menu.scrollTop(menuScrollTop + (elBottom - menuHeight));
            },
            close: function() {
                this.isOpen && (this.isOpen = !1, this._removeCursor(), this._hide(), this.trigger("closed"));
            },
            open: function() {
                this.isOpen || (this.isOpen = !0, !this.isEmpty && this._show(), this.trigger("opened"));
            },
            setLanguageDirection: function(dir) {
                this.$menu.css("ltr" === dir ? css.ltr : css.rtl);
            },
            moveCursorUp: function() {
                this._moveCursor(-1);
            },
            moveCursorDown: function() {
                this._moveCursor(1);
            },
            getDatumForSuggestion: function($el) {
                var datum = null;
                return $el.length && (datum = {
                    raw: Dataset.extractDatum($el),
                    value: Dataset.extractValue($el),
                    datasetName: Dataset.extractDatasetName($el)
                }), datum;
            },
            getDatumForCursor: function() {
                return this.getDatumForSuggestion(this._getCursor().first());
            },
            getDatumForTopSuggestion: function() {
                return this.getDatumForSuggestion(this._getSuggestions().first());
            },
            update: function(query) {
                function updateDataset(dataset) {
                    dataset.update(query);
                }
                _.each(this.datasets, updateDataset);
            },
            empty: function() {
                function clearDataset(dataset) {
                    dataset.clear();
                }
                _.each(this.datasets, clearDataset), this.isEmpty = !0;
            },
            isVisible: function() {
                return this.isOpen && !this.isEmpty;
            },
            destroy: function() {
                function destroyDataset(dataset) {
                    dataset.destroy();
                }
                this.$menu.off(".tt"), this.$menu = null, _.each(this.datasets, destroyDataset);
            }
        }), Dropdown;
    }(), Typeahead = function() {
        "use strict";
        function Typeahead(o) {
            var $menu, $input, $hint;
            o = o || {}, o.input || $.error("missing input"), this.isActivated = !1, this.autoselect = !!o.autoselect, 
            this.minLength = _.isNumber(o.minLength) ? o.minLength : 1, this.$node = buildDom(o.input, o.withHint), 
            $menu = this.$node.find(".tt-dropdown-menu"), $input = this.$node.find(".tt-input"), 
            $hint = this.$node.find(".tt-hint"), $input.on("blur.tt", function($e) {
                var active, isActive, hasActive;
                active = document.activeElement, isActive = $menu.is(active), hasActive = $menu.has(active).length > 0, 
                _.isMsie() && (isActive || hasActive) && ($e.preventDefault(), $e.stopImmediatePropagation(), 
                _.defer(function() {
                    $input.focus();
                }));
            }), $menu.on("mousedown.tt", function($e) {
                $e.preventDefault();
            }), this.eventBus = o.eventBus || new EventBus({
                el: $input
            }), this.dropdown = new Dropdown({
                menu: $menu,
                datasets: o.datasets
            }).onSync("suggestionClicked", this._onSuggestionClicked, this).onSync("cursorMoved", this._onCursorMoved, this).onSync("cursorRemoved", this._onCursorRemoved, this).onSync("opened", this._onOpened, this).onSync("closed", this._onClosed, this).onAsync("datasetRendered", this._onDatasetRendered, this), 
            this.input = new Input({
                input: $input,
                hint: $hint
            }).onSync("focused", this._onFocused, this).onSync("blurred", this._onBlurred, this).onSync("enterKeyed", this._onEnterKeyed, this).onSync("tabKeyed", this._onTabKeyed, this).onSync("escKeyed", this._onEscKeyed, this).onSync("upKeyed", this._onUpKeyed, this).onSync("downKeyed", this._onDownKeyed, this).onSync("leftKeyed", this._onLeftKeyed, this).onSync("rightKeyed", this._onRightKeyed, this).onSync("queryChanged", this._onQueryChanged, this).onSync("whitespaceChanged", this._onWhitespaceChanged, this), 
            this._setLanguageDirection();
        }
        function buildDom(input, withHint) {
            var $input, $wrapper, $dropdown, $hint;
            $input = $(input), $wrapper = $(html.wrapper).css(css.wrapper), $dropdown = $(html.dropdown).css(css.dropdown), 
            $hint = $input.clone().css(css.hint).css(getBackgroundStyles($input)), $hint.val("").removeData().addClass("tt-hint").removeAttr("id name placeholder required").prop("readonly", !0).attr({
                autocomplete: "off",
                spellcheck: "false",
                tabindex: -1
            }), $input.data(attrsKey, {
                dir: $input.attr("dir"),
                autocomplete: $input.attr("autocomplete"),
                spellcheck: $input.attr("spellcheck"),
                style: $input.attr("style")
            }), $input.addClass("tt-input").attr({
                autocomplete: "off",
                spellcheck: !1
            }).css(withHint ? css.input : css.inputWithNoHint);
            try {
                !$input.attr("dir") && $input.attr("dir", "auto");
            } catch (e) {}
            return $input.wrap($wrapper).parent().prepend(withHint ? $hint : null).append($dropdown);
        }
        function getBackgroundStyles($el) {
            return {
                backgroundAttachment: $el.css("background-attachment"),
                backgroundClip: $el.css("background-clip"),
                backgroundColor: $el.css("background-color"),
                backgroundImage: $el.css("background-image"),
                backgroundOrigin: $el.css("background-origin"),
                backgroundPosition: $el.css("background-position"),
                backgroundRepeat: $el.css("background-repeat"),
                backgroundSize: $el.css("background-size")
            };
        }
        function destroyDomStructure($node) {
            var $input = $node.find(".tt-input");
            _.each($input.data(attrsKey), function(val, key) {
                _.isUndefined(val) ? $input.removeAttr(key) : $input.attr(key, val);
            }), $input.detach().removeData(attrsKey).removeClass("tt-input").insertAfter($node), 
            $node.remove();
        }
        var attrsKey = "ttAttrs";
        return _.mixin(Typeahead.prototype, {
            _onSuggestionClicked: function(type, $el) {
                var datum;
                (datum = this.dropdown.getDatumForSuggestion($el)) && this._select(datum);
            },
            _onCursorMoved: function() {
                var datum = this.dropdown.getDatumForCursor();
                this.input.setInputValue(datum.value, !0), this.eventBus.trigger("cursorchanged", datum.raw, datum.datasetName);
            },
            _onCursorRemoved: function() {
                this.input.resetInputValue(), this._updateHint();
            },
            _onDatasetRendered: function() {
                this._updateHint();
            },
            _onOpened: function() {
                this._updateHint(), this.eventBus.trigger("opened");
            },
            _onClosed: function() {
                this.input.clearHint(), this.eventBus.trigger("closed");
            },
            _onFocused: function() {
                this.isActivated = !0, this.dropdown.open();
            },
            _onBlurred: function() {
                this.isActivated = !1, this.dropdown.empty(), this.dropdown.close();
            },
            _onEnterKeyed: function(type, $e) {
                var cursorDatum, topSuggestionDatum;
                cursorDatum = this.dropdown.getDatumForCursor(), topSuggestionDatum = this.dropdown.getDatumForTopSuggestion(), 
                cursorDatum ? (this._select(cursorDatum), $e.preventDefault()) : this.autoselect && topSuggestionDatum && (this._select(topSuggestionDatum), 
                $e.preventDefault());
            },
            _onTabKeyed: function(type, $e) {
                var datum;
                (datum = this.dropdown.getDatumForCursor()) ? (this._select(datum), $e.preventDefault()) : this._autocomplete(!0);
            },
            _onEscKeyed: function() {
                this.dropdown.close(), this.input.resetInputValue();
            },
            _onUpKeyed: function() {
                var query = this.input.getQuery();
                this.dropdown.isEmpty && query.length >= this.minLength ? this.dropdown.update(query) : this.dropdown.moveCursorUp(), 
                this.dropdown.open();
            },
            _onDownKeyed: function() {
                var query = this.input.getQuery();
                this.dropdown.isEmpty && query.length >= this.minLength ? this.dropdown.update(query) : this.dropdown.moveCursorDown(), 
                this.dropdown.open();
            },
            _onLeftKeyed: function() {
                "rtl" === this.dir && this._autocomplete();
            },
            _onRightKeyed: function() {
                "ltr" === this.dir && this._autocomplete();
            },
            _onQueryChanged: function(e, query) {
                this.input.clearHintIfInvalid(), query.length >= this.minLength ? this.dropdown.update(query) : this.dropdown.empty(), 
                this.dropdown.open(), this._setLanguageDirection();
            },
            _onWhitespaceChanged: function() {
                this._updateHint(), this.dropdown.open();
            },
            _setLanguageDirection: function() {
                var dir;
                this.dir !== (dir = this.input.getLanguageDirection()) && (this.dir = dir, this.$node.css("direction", dir), 
                this.dropdown.setLanguageDirection(dir));
            },
            _updateHint: function() {
                var datum, val, query, escapedQuery, frontMatchRegEx, match;
                datum = this.dropdown.getDatumForTopSuggestion(), datum && this.dropdown.isVisible() && !this.input.hasOverflow() ? (val = this.input.getInputValue(), 
                query = Input.normalizeQuery(val), escapedQuery = _.escapeRegExChars(query), frontMatchRegEx = new RegExp("^(?:" + escapedQuery + ")(.+$)", "i"), 
                match = frontMatchRegEx.exec(datum.value), match ? this.input.setHint(val + match[1]) : this.input.clearHint()) : this.input.clearHint();
            },
            _autocomplete: function(laxCursor) {
                var hint, query, isCursorAtEnd, datum;
                hint = this.input.getHint(), query = this.input.getQuery(), isCursorAtEnd = laxCursor || this.input.isCursorAtEnd(), 
                hint && query !== hint && isCursorAtEnd && (datum = this.dropdown.getDatumForTopSuggestion(), 
                datum && this.input.setInputValue(datum.value), this.eventBus.trigger("autocompleted", datum.raw, datum.datasetName));
            },
            _select: function(datum) {
                this.input.setQuery(datum.value), this.input.setInputValue(datum.value, !0), this._setLanguageDirection(), 
                this.eventBus.trigger("selected", datum.raw, datum.datasetName), this.dropdown.close(), 
                _.defer(_.bind(this.dropdown.empty, this.dropdown));
            },
            open: function() {
                this.dropdown.open();
            },
            close: function() {
                this.dropdown.close();
            },
            setVal: function(val) {
                val = _.toStr(val), this.isActivated ? this.input.setInputValue(val) : (this.input.setQuery(val), 
                this.input.setInputValue(val, !0)), this._setLanguageDirection();
            },
            getVal: function() {
                return this.input.getQuery();
            },
            destroy: function() {
                this.input.destroy(), this.dropdown.destroy(), destroyDomStructure(this.$node), 
                this.$node = null;
            }
        }), Typeahead;
    }();
    !function() {
        "use strict";
        var old, typeaheadKey, methods;
        old = $.fn.typeahead, typeaheadKey = "ttTypeahead", methods = {
            initialize: function(o, datasets) {
                function attach() {
                    var eventBus, typeahead, $input = $(this);
                    _.each(datasets, function(d) {
                        d.highlight = !!o.highlight;
                    }), typeahead = new Typeahead({
                        input: $input,
                        eventBus: eventBus = new EventBus({
                            el: $input
                        }),
                        withHint: _.isUndefined(o.hint) ? !0 : !!o.hint,
                        minLength: o.minLength,
                        autoselect: o.autoselect,
                        datasets: datasets
                    }), $input.data(typeaheadKey, typeahead);
                }
                return datasets = _.isArray(datasets) ? datasets : [].slice.call(arguments, 1), 
                o = o || {}, this.each(attach);
            },
            open: function() {
                function openTypeahead() {
                    var typeahead, $input = $(this);
                    (typeahead = $input.data(typeaheadKey)) && typeahead.open();
                }
                return this.each(openTypeahead);
            },
            close: function() {
                function closeTypeahead() {
                    var typeahead, $input = $(this);
                    (typeahead = $input.data(typeaheadKey)) && typeahead.close();
                }
                return this.each(closeTypeahead);
            },
            val: function(newVal) {
                function setVal() {
                    var typeahead, $input = $(this);
                    (typeahead = $input.data(typeaheadKey)) && typeahead.setVal(newVal);
                }
                function getVal($input) {
                    var typeahead, query;
                    return (typeahead = $input.data(typeaheadKey)) && (query = typeahead.getVal()), 
                    query;
                }
                return arguments.length ? this.each(setVal) : getVal(this.first());
            },
            destroy: function() {
                function unattach() {
                    var typeahead, $input = $(this);
                    (typeahead = $input.data(typeaheadKey)) && (typeahead.destroy(), $input.removeData(typeaheadKey));
                }
                return this.each(unattach);
            }
        }, $.fn.typeahead = function(method) {
            var tts;
            return methods[method] && "initialize" !== method ? (tts = this.filter(function() {
                return !!$(this).data(typeaheadKey);
            }), methods[method].apply(tts, [].slice.call(arguments, 1))) : methods.initialize.apply(this, arguments);
        }, $.fn.typeahead.noConflict = function() {
            return $.fn.typeahead = old, this;
        };
    }();
}(window.jQuery), function(root, factory) {
    "function" == typeof define && define.amd ? define(factory) : "object" == typeof exports ? module.exports = factory() : root.NProgress = factory();
}(this, function() {
    /**
   * Helpers
   */
    function clamp(n, min, max) {
        return min > n ? min : n > max ? max : n;
    }
    /**
   * (Internal) converts a percentage (`0..1`) to a bar translateX
   * percentage (`-100%..0%`).
   */
    function toBarPerc(n) {
        return 100 * (-1 + n);
    }
    /**
   * (Internal) returns the correct CSS for changing the bar's
   * position given an n percentage, and speed and ease from Settings
   */
    function barPositionCSS(n, speed, ease) {
        var barCSS;
        return barCSS = "translate3d" === Settings.positionUsing ? {
            transform: "translate3d(" + toBarPerc(n) + "%,0,0)"
        } : "translate" === Settings.positionUsing ? {
            transform: "translate(" + toBarPerc(n) + "%,0)"
        } : {
            "margin-left": toBarPerc(n) + "%"
        }, barCSS.transition = "all " + speed + "ms " + ease, barCSS;
    }
    /**
   * (Internal) Determines if an element or space separated list of class names contains a class name.
   */
    function hasClass(element, name) {
        var list = "string" == typeof element ? element : classList(element);
        return list.indexOf(" " + name + " ") >= 0;
    }
    /**
   * (Internal) Adds a class to an element.
   */
    function addClass(element, name) {
        var oldList = classList(element), newList = oldList + name;
        hasClass(oldList, name) || (// Trim the opening space.
        element.className = newList.substring(1));
    }
    /**
   * (Internal) Removes a class from an element.
   */
    function removeClass(element, name) {
        var newList, oldList = classList(element);
        hasClass(element, name) && (newList = oldList.replace(" " + name + " ", " "), element.className = newList.substring(1, newList.length - 1));
    }
    /**
   * (Internal) Gets a space separated list of the class names on the element. 
   * The list is wrapped with a single space on each end to facilitate finding 
   * matches within the list.
   */
    function classList(element) {
        return (" " + (element.className || "") + " ").replace(/\s+/gi, " ");
    }
    /**
   * (Internal) Removes an element from the DOM.
   */
    function removeElement(element) {
        element && element.parentNode && element.parentNode.removeChild(element);
    }
    var NProgress = {};
    NProgress.version = "0.1.6";
    var Settings = NProgress.settings = {
        minimum: .08,
        easing: "ease",
        positionUsing: "",
        speed: 200,
        trickle: !0,
        trickleRate: .02,
        trickleSpeed: 800,
        showSpinner: !0,
        barSelector: '[role="bar"]',
        spinnerSelector: '[role="spinner"]',
        parent: "body",
        template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
    };
    /**
   * Updates configuration.
   *
   *     NProgress.configure({
   *       minimum: 0.1
   *     });
   */
    NProgress.configure = function(options) {
        var key, value;
        for (key in options) value = options[key], void 0 !== value && options.hasOwnProperty(key) && (Settings[key] = value);
        return this;
    }, /**
   * Last number.
   */
    NProgress.status = null, /**
   * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.
   *
   *     NProgress.set(0.4);
   *     NProgress.set(1.0);
   */
    NProgress.set = function(n) {
        var started = NProgress.isStarted();
        n = clamp(n, Settings.minimum, 1), NProgress.status = 1 === n ? null : n;
        var progress = NProgress.render(!started), bar = progress.querySelector(Settings.barSelector), speed = Settings.speed, ease = Settings.easing;
        /* Repaint */
        return progress.offsetWidth, queue(function(next) {
            // Set positionUsing if it hasn't already been set
            "" === Settings.positionUsing && (Settings.positionUsing = NProgress.getPositioningCSS()), 
            // Add transition
            css(bar, barPositionCSS(n, speed, ease)), 1 === n ? (// Fade out
            css(progress, {
                transition: "none",
                opacity: 1
            }), progress.offsetWidth, /* Repaint */
            setTimeout(function() {
                css(progress, {
                    transition: "all " + speed + "ms linear",
                    opacity: 0
                }), setTimeout(function() {
                    NProgress.remove(), next();
                }, speed);
            }, speed)) : setTimeout(next, speed);
        }), this;
    }, NProgress.isStarted = function() {
        return "number" == typeof NProgress.status;
    }, /**
   * Shows the progress bar.
   * This is the same as setting the status to 0%, except that it doesn't go backwards.
   *
   *     NProgress.start();
   *
   */
    NProgress.start = function() {
        NProgress.status || NProgress.set(0);
        var work = function() {
            setTimeout(function() {
                NProgress.status && (NProgress.trickle(), work());
            }, Settings.trickleSpeed);
        };
        return Settings.trickle && work(), this;
    }, /**
   * Hides the progress bar.
   * This is the *sort of* the same as setting the status to 100%, with the
   * difference being `done()` makes some placebo effect of some realistic motion.
   *
   *     NProgress.done();
   *
   * If `true` is passed, it will show the progress bar even if its hidden.
   *
   *     NProgress.done(true);
   */
    NProgress.done = function(force) {
        return force || NProgress.status ? NProgress.inc(.3 + .5 * Math.random()).set(1) : this;
    }, /**
   * Increments by a random amount.
   */
    NProgress.inc = function(amount) {
        var n = NProgress.status;
        return n ? ("number" != typeof amount && (amount = (1 - n) * clamp(Math.random() * n, .1, .95)), 
        n = clamp(n + amount, 0, .994), NProgress.set(n)) : NProgress.start();
    }, NProgress.trickle = function() {
        return NProgress.inc(Math.random() * Settings.trickleRate);
    }, /**
   * Waits for all supplied jQuery promises and
   * increases the progress as the promises resolve.
   * 
   * @param $promise jQUery Promise
   */
    function() {
        var initial = 0, current = 0;
        NProgress.promise = function($promise) {
            return $promise && "resolved" != $promise.state() ? (0 == current && NProgress.start(), 
            initial++, current++, $promise.always(function() {
                current--, 0 == current ? (initial = 0, NProgress.done()) : NProgress.set((initial - current) / initial);
            }), this) : this;
        };
    }(), /**
   * (Internal) renders the progress bar markup based on the `template`
   * setting.
   */
    NProgress.render = function(fromStart) {
        if (NProgress.isRendered()) return document.getElementById("nprogress");
        addClass(document.documentElement, "nprogress-busy");
        var progress = document.createElement("div");
        progress.id = "nprogress", progress.innerHTML = Settings.template;
        var spinner, bar = progress.querySelector(Settings.barSelector), perc = fromStart ? "-100" : toBarPerc(NProgress.status || 0), parent = document.querySelector(Settings.parent);
        return css(bar, {
            transition: "all 0 linear",
            transform: "translate3d(" + perc + "%,0,0)"
        }), Settings.showSpinner || (spinner = progress.querySelector(Settings.spinnerSelector), 
        spinner && removeElement(spinner)), parent != document.body && addClass(parent, "nprogress-custom-parent"), 
        parent.appendChild(progress), progress;
    }, /**
   * Removes the element. Opposite of render().
   */
    NProgress.remove = function() {
        removeClass(document.documentElement, "nprogress-busy"), removeClass(document.querySelector(Settings.parent), "nprogress-custom-parent");
        var progress = document.getElementById("nprogress");
        progress && removeElement(progress);
    }, /**
   * Checks if the progress bar is rendered.
   */
    NProgress.isRendered = function() {
        return !!document.getElementById("nprogress");
    }, /**
   * Determine which positioning CSS rule to use.
   */
    NProgress.getPositioningCSS = function() {
        // Sniff on document.body.style
        var bodyStyle = document.body.style, vendorPrefix = "WebkitTransform" in bodyStyle ? "Webkit" : "MozTransform" in bodyStyle ? "Moz" : "msTransform" in bodyStyle ? "ms" : "OTransform" in bodyStyle ? "O" : "";
        return vendorPrefix + "Perspective" in bodyStyle ? "translate3d" : vendorPrefix + "Transform" in bodyStyle ? "translate" : "margin";
    };
    /**
   * (Internal) Queues a function to be executed.
   */
    var queue = function() {
        function next() {
            var fn = pending.shift();
            fn && fn(next);
        }
        var pending = [];
        return function(fn) {
            pending.push(fn), 1 == pending.length && next();
        };
    }(), css = function() {
        function camelCase(string) {
            return string.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function(match, letter) {
                return letter.toUpperCase();
            });
        }
        function getVendorProp(name) {
            var style = document.body.style;
            if (name in style) return name;
            for (var vendorName, i = cssPrefixes.length, capName = name.charAt(0).toUpperCase() + name.slice(1); i--; ) if (vendorName = cssPrefixes[i] + capName, 
            vendorName in style) return vendorName;
            return name;
        }
        function getStyleProp(name) {
            return name = camelCase(name), cssProps[name] || (cssProps[name] = getVendorProp(name));
        }
        function applyCss(element, prop, value) {
            prop = getStyleProp(prop), element.style[prop] = value;
        }
        var cssPrefixes = [ "Webkit", "O", "Moz", "ms" ], cssProps = {};
        return function(element, properties) {
            var prop, value, args = arguments;
            if (2 == args.length) for (prop in properties) value = properties[prop], void 0 !== value && properties.hasOwnProperty(prop) && applyCss(element, prop, value); else applyCss(element, args[1], args[2]);
        };
    }();
    return NProgress;
}), function($, window, document, location, navigator) {
    /*jshint laxbreak: true, expr: true */
    "use strict";
    var Grido = Grido || {};
    /**
     * Grid definition.
     * @param {jQuery} $element
     * @param {Object} options
     */
    Grido.Grid = function($element, options) {
        this.$element = $element, this.$table = $("table", $element), this.name = this.$table.attr("id"), 
        this.options = $.extend($.fn.grido.defaults, options, this.$table.data("grido-options") || {});
    }, Grido.Grid.prototype = {
        operation: null,
        onInit: [],
        /**
         * Initial function.
         */
        init: function() {
            this.ajax = new Grido.Ajax(this).init(), this.operation = new Grido.Operation(this).init(), 
            this.initFilters(), this.initItemsPerPage(), this.initActions(), this.initPagePrompt(), 
            this.initCheckNumeric(), this.initEditable();
            for (var i in this.onInit) this.onInit[i](this);
            return this;
        },
        /**
         * Attach a change handler to filter elements (select, checkbox).
         */
        initFilters: function() {
            $(".filter select, .filter [type=checkbox]", this.$element).off("change.grido").on("change.grido", $.proxy(this.sendFilterForm, this));
        },
        /**
         * Attach a change handler to items-per-page select.
         */
        initItemsPerPage: function() {
            $("[name=count]", this.$table).off("change.grido").on("change.grido", function() {
                $(this).next().trigger("click");
            });
        },
        /**
         * Attach a click handler to action anchors.
         */
        initActions: function() {
            var that = this;
            $(".actions a", this.$table).off("click.nette").off("click.grido").on("click.grido", function(event) {
                var isAjax = $(this).hasClass("ajax") && that.ajax, hasConfirm = $(this).data("grido-confirm"), stop = function(event) {
                    event.preventDefault(), event.stopImmediatePropagation();
                };
                hasConfirm && confirm(hasConfirm) ? isAjax && (that.ajax.doRequest(this.href, this, event) || stop(event)) : hasConfirm ? stop(event) : isAjax && (that.ajax.doRequest(this.href, this, event) || stop(event));
            });
        },
        /**
         * Attach a click handler to page prompt.
         */
        initPagePrompt: function() {
            var that = this;
            $(".paginator .prompt", this.$table).off("click.grido").on("click.grido", function() {
                var page = parseInt(prompt($(this).data("grido-prompt")), 10);
                if (page && page > 0 && page <= parseInt($(".paginator a.btn:last", that.element).prev().text(), 10)) {
                    var location = $(this).data("grido-link").replace("page=0", "page=" + page);
                    window.location = location;
                } else page && window.alert("Page is out of range.");
            });
        },
        /**
         * Checking numeric input.
         */
        initCheckNumeric: function() {
            $(".filter input.number", this.$element).off("keyup.grido").on("keyup.grido", function() {
                var value = $(this).val(), pattern = new RegExp(/[^<>=\\.\\,\-0-9]+/g);
                pattern.test(value) && $(this).val(value.replace(pattern, ""));
            });
        },
        initEditable: function() {
            var that = this;
            $('td[class*="grid-cell-"]', this.$element).off("dblclick.grido").on("dblclick.grido", function(event) {
                helpers.isCtrl(event) && !$(this).hasClass("edit") && (this.editable = new Grido.Editable(that).init($(this)));
            });
        },
        /**
         * Sending filter form.
         */
        sendFilterForm: function() {
            $('.filter [name="buttons[search]"]', this.$element).click();
        }
    }, /**
     * Operation definition.
     * @param {Grido} Grido
     */
    Grido.Operation = function(Grido) {
        this.grido = Grido;
    }, Grido.Operation.prototype = {
        selector: "td.checker [type=checkbox]",
        //storage for last selected row
        $last: null,
        init: function() {
            return $("th.checker", this.grido.$table).length ? (this.initSelectState(), this.bindClickOnCheckbox(), 
            this.bindClickOnRow(), this.bindClickOnInvertor(), this.bindChangeOnCheckbox(), 
            this.bindChangeOnSelect(), this.bindClickOnButton(), this) : null;
        },
        initSelectState: function() {
            0 === $(this.selector + ":checked", this.grido.$table).length && this.controlState("disabled");
        },
        /**
         * Click on checkbox with shift support.
         */
        bindClickOnCheckbox: function() {
            var that = this;
            $(this.selector, this.grido.$table).off("click.grido").on("click.grido", function(event, data) {
                if (event.shiftKey || data && data.shiftKey) {
                    var $boxes = $(that.selector, that.grido.$table), start = $boxes.index(this), end = $boxes.index(that.$last);
                    $boxes.slice(Math.min(start, end), Math.max(start, end)).attr("checked", that.$last.checked).trigger("change");
                }
                that.$last = this;
            });
        },
        bindClickOnRow: function() {
            var that = this;
            $("tbody td:not(.checker,.actions a)", this.grido.$table).off("click.grido").on("click.grido", function(event) {
                $(this).hasClass("edit") || (event.shiftKey && that.disableSelection.call(that), 
                $(that.selector, $(this).closest("tr")).click(), event.shiftKey && that.enableSelection.call(that));
            });
        },
        bindClickOnInvertor: function() {
            var that = this;
            $("th.checker [type=checkbox]", this.grido.$table).off("click.grido").on("click.grido", function() {
                return $(that.selector, that.grido.$table).each(function() {
                    var val = $(this).prop("checked");
                    $(this).prop("checked", !val), that.changeRow($(this).closest("tr"), !val);
                }), !1;
            });
        },
        bindChangeOnCheckbox: function() {
            var that = this;
            $(this.selector, this.grido.$table).off("change.grido").on("change.grido", function() {
                $.proxy(that.changeRow, that)($(this).closest("tr"), $(this).prop("checked"));
            });
        },
        bindChangeOnSelect: function() {
            var that = this;
            $('.operations [name="operations[operations]"]', this.grido.$table).off("change.grido").on("change.grido", function() {
                $(this).val() && $(".operations [type=submit]", that.grido.$table).click();
            });
        },
        bindClickOnButton: function() {
            $(".operations [type=submit]", this.grido.$table).off("click.grido").on("click.grido", $.proxy(this.onSubmit, this));
        },
        disableSelection: function() {
            this.grido.$table.attr("unselectable", "on").css("user-select", "none");
        },
        enableSelection: function() {
            if (window.getSelection) {
                var selection = window.getSelection();
                selection.removeAllRanges && selection.removeAllRanges();
            } else document.selection && //IE < 9
            document.selection.empty();
            this.grido.$table.attr("unselectable", "off").attr("style", null);
        },
        /**
         * Returns operation select.
         * @returns {jQuery}
         */
        getSelect: function() {
            return $('.operations [name="operations[operations]"]', this.grido.$table);
        },
        /**
         * @param {jQuery} $row
         * @param {bool} selected
         */
        changeRow: function($row, selected) {
            selected ? $row.addClass("active") : $row.removeClass("active"), 0 === $(this.selector + ":checked", this.grido.$table).length ? this.controlState("disabled") : this.controlState("enabled");
        },
        onSubmit: function() {
            var hasConfirm = this.getSelect().attr("data-grido-confirm-" + this.getSelect().val());
            return hasConfirm ? confirm(hasConfirm.replace(/%i/g, $(this.selector + ":checked", this.grido.$table).length)) ? !0 : (this.getSelect().val(""), 
            !1) : !0;
        },
        /**
         * @param {String} state
         */
        controlState: function(state) {
            var $button = $('[name="buttons[operations]"]', this.grido.$table);
            "disabled" === state ? (this.getSelect().attr("disabled", "disabled").addClass("disabled"), 
            $button.addClass("disabled")) : (this.getSelect().removeAttr("disabled").removeClass("disabled"), 
            $button.removeClass("disabled"));
        }
    }, /**
     * Ajax definition.
     * @param {Grido} Grido
     */
    Grido.Ajax = function(Grido) {
        this.grido = Grido;
    }, Grido.Ajax.prototype = {
        init: function() {
            return this.grido.options.ajax ? (this.registerSuccessEvent(), this.registerPopState(), 
            this) : null;
        },
        registerSuccessEvent: function() {
            var that = this;
            this.grido.$element.off("success.ajax.grido").on("success.ajax.grido", function(event, payload) {
                $.proxy(that.handleSuccessEvent, that)(payload), event.stopImmediatePropagation();
            });
        },
        registerPopState: function() {
            var that = this;
            $(window).off("popstate.ajax.grido").on("popstate.ajax.grido", function(event) {
                $.proxy(that.onPopState, that)(event), event.stopImmediatePropagation();
            });
        },
        /**
         * @param {Object} payload
         */
        handleSuccessEvent: function(payload) {
            var that = this, params = {}, snippet = "snippet-" + this.grido.name + "-grid";
            if (payload && payload.snippets && payload.snippets[snippet] && payload.state) {
                //is ajax update?
                $.each(payload.state, function(key, val) {
                    (val || 0 === val) && key.indexOf("" + that.grido.name + "-") >= 0 && (params[key] = val);
                });
                var query = this.getQueryString(params);
                $.data(document, this.grido.name + "-query", query), this.onSuccessEvent(params, query);
            }
        },
        /**
         * @param {Object} params
         * @returns {String}
         */
        getQueryString: function(params) {
            var queryString;
            if ($.isEmptyObject(params)) {
                var newParams = {}, oldParams = this.getQueryParams();
                for (var key in oldParams) 0 !== key.indexOf(this.grido.name) && (newParams[key] = oldParams[key]);
                queryString = $.isEmptyObject(newParams) ? window.location.pathname : "?" + $.param(newParams);
            } else queryString = "?" + $.param($.extend(this.getQueryParams(), params));
            return this.coolUri(queryString);
        },
        /**
         * @param {Object} params - grido params
         * @param {String} url
         */
        onSuccessEvent: function(params, url) {
            window.history.pushState(params, document.title, url);
        },
        /**
         * @param Event event
         */
        onPopState: function(event) {
            var state = $.data(document, this.grido.name + "-query") || "", query = window.location.search;
            if (state !== query) {
                var url = this.getRefreshGridHandlerUrl(this.grido.$element);
                this.doRequest(url);
            }
        },
        /**
         * Load data from the server using a HTTP GET request.
         * @param {String} url
         */
        doRequest: function(url) {
            $.get(url);
        },
        /**
         * Own decodeURIComponent() implementation.
         * @param {String} encodedUri
         */
        coolUri: function(encodedUri) {
            var cool = encodedUri, replace = {
                "%5B": "[",
                "%5D": "]",
                "%E2%86%91": "",
                "%E2%86%93": ""
            };
            return $.each(replace, function(key, val) {
                cool = cool.replace(new RegExp(key, "g"), val);
            }), cool;
        },
        /**
         * Returns url for AJAX call to Refresh grid.
         * @param {jQuery} $form
         * @return {String} Url from data atribute of form
         */
        getRefreshGridHandlerUrl: function($form) {
            return $form.data("grido-refresh-handler");
        },
        /**
         * Returns window.location.search as object
         * @link http://jsbin.com/adali3/2
         * @link http://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript/2880929#2880929
         */
        getQueryParams: function() {
            for (var e, d = function(s) {
                return decodeURIComponent(s).replace(/\+/g, " ");
            }, q = window.location.search.substring(1), r = /([^&=]+)=?([^&]*)/g, params = {}; e = r.exec(q); ) if (-1 === e[1].indexOf("[")) params[d(e[1])] = d(e[2]); else {
                var b1 = e[1].indexOf("["), aN = e[1].slice(b1 + 1, e[1].indexOf("]", b1)), pN = d(e[1].slice(0, b1));
                "object" != typeof params[pN] && (params[d(pN)] = {}), aN ? params[d(pN)][d(aN)] = d(e[2]) : Array.prototype.push.call(params[d(pN)], d(e[2]));
            }
            return params;
        }
    }, /**
     * Inline editable definition.
     * @author Jakub Kopiva <kopriva.jakub@gmail.com>
     * @param {Grido} Grido
     */
    Grido.Editable = function(Grido) {
        this.grido = Grido;
    }, Grido.Editable.prototype = {
        init: function($td) {
            return this.grido.options.ajax !== !0 || this.grido.options.editable !== !0 ? null : (this.td = $td.addClass("edit"), 
            this.th = this.getColumnHeader(this.td), this.getEditHandlerUrl(this.th) && (this.value = this.getValue(this.td), 
            this.oldValue = this.getOldValue(this.td), this.primaryKey = this.getPrimaryKeyValue(this.td.parent()), 
            this.componentName = this.getComponentName(this.th), this.editControlHtml = this.getEditControl(this.componentName, this.getEditControlHandlerUrl(this.th)), 
            this.renderEditControl(this.td, this.editControlHtml), this.editControlObject = this.getEditControlObject(this.td), 
            this.setFocus(this.editControlObject), this.initBindings(this.editControlObject)), 
            this);
        },
        /**
         * Returns column <th> object.
         * @param {jQuery} $td cell
         * @return {jQuery} header cell of column
         */
        getColumnHeader: function($td) {
            for (var headerClass, classList = $td.attr("class").replace("cell", "header").split(/\s+/), i = 0; i < classList.length; i++) -1 !== classList[i].indexOf("-header-") && (headerClass = classList[i]);
            return $('th[class~="' + headerClass + '"]');
        },
        /**
         * Returns value of primary key.
         * @param {jQuery} $tr row
         * @return {String} Primary key value
         */
        getPrimaryKeyValue: function($tr) {
            return $tr.attr("class").match(/[grid\-row\-]([0-9]+)/)[1];
        },
        /**
         * Returns name of component for AJAX params calls.
         * @param {jQuery} $th header cell
         * @return {String} component name for AJAX params calls
         */
        getComponentName: function($th) {
            var handler = this.getEditControlHandlerUrl($th).replace("/[.d]*/g", "");
            return handler = handler.match(/[\??\&?](do=)+(.*)/)[2], handler.match(/(.*)\-edit/)[1];
        },
        /**
         * Returns url for AJAX editable handler.
         * @param {jQuery} $th header cell
         * @return {String} Url from data atribute of header cell
         */
        getEditHandlerUrl: function($th) {
            return $th.data("grido-editable-handler");
        },
        /**
         * Returns url for AJAX call to Editable class.
         * @param {jQuery} $th header cell
         * @return {String} Url from data atribute of header cell
         */
        getEditControlHandlerUrl: function($th) {
            return $th.data("grido-editablecontrol-handler");
        },
        /**
         * Returns raw value for editable control.
         * @param {jQuery} $td
         * @returns {String}
         */
        getValue: function($td) {
            return $td.data("grido-editable-value");
        },
        /**
         * Returns value in the cell.
         * @param {jQuery} $td
         * @returns {jQuery}|{String}
         */
        getOldValue: function($td) {
            return $td.children().length > 0 ? $td.children() : $td.text().trim();
        },
        /**
         * Returns html of control.
         * @param {String} componentName component name for AJAX call
         * @param {String} handleLink url for AJAX call
         * @return {String} HTML of control
         */
        getEditControl: function(componentName, handleLink) {
            var control, data = {};
            return data[componentName + "-value"] = this.value, $.ajax({
                type: "GET",
                url: handleLink,
                data: data,
                async: !1
            }).success(function(data) {
                control = data;
            }), control;
        },
        /**
         * Render html in cell.
         * @param {jQuery} $td cell
         * @param {String} $html HTML
         */
        renderEditControl: function($td, $html) {
            $td.html($html);
        },
        /**
         * Returns Children of cell.
         * @param {jQuery} $td cell
         * @return {jQuery} children of cell
         */
        getEditControlObject: function($td) {
            return $td.children();
        },
        /**
         * Sets focus in text input if type="text".
         * @param {jQuery} $editControlObject input
         */
        setFocus: function($editControlObject) {
            "text" === $editControlObject[0].type && $editControlObject.focus();
        },
        /**
         * AJAX call to Editable handler for saving data.
         * @param {String} oldValue value of cell before edit was done
         * @param {String} componentName name of component handler for AJAX params
         * @param {String} primaryKey value of primary key
         * @param {jQuery} $th header cell of column
         * @param {jQuery} $td edited cell
         */
        saveData: function(oldValue, componentName, primaryKey, $th, $td, oldHtml) {
            var data = {}, that = this, newValue = $("[type=checkbox]", this.editControlObject).length ? ~~+$("[type=checkbox]", this.editControlObject).is(":checked") : this.editControlObject.val();
            return newValue === oldValue ? void $td.html(oldHtml) : (data[componentName + "-id"] = primaryKey, 
            data[componentName + "-newValue"] = newValue, data[componentName + "-oldValue"] = oldValue, 
            void $.ajax({
                type: "POST",
                url: this.getEditHandlerUrl($th),
                data: data,
                async: !0
            }).success(function(data) {
                data.updated === !0 ? (data.html ? $td.html(data.html) : $td.html(newValue), $td.data("grido-editable-value", newValue), 
                that.oldValue = newValue, that.flashSuccess($td)) : (that.flashError($td), that.revertChanges($td));
            }));
        },
        /**
         * Revert changes in cell.
         * @param {jQuery} $td edited cell
         */
        revertChanges: function($td) {
            $td.html(this.oldValue);
        },
        /**
         * Provide feedback to user, cell was succesfully changed.
         * @param {jQuery} $td edited cell
         */
        flashSuccess: function($td) {
            var transp = 0, multiplicator = 1, timer = setInterval(function() {
                transp += .01 * multiplicator, $td.css("background", "rgba(196,234,195," + transp + ")"), 
                transp >= 1 && (multiplicator = -1), 0 >= transp && (clearInterval(timer), $td.css("background", ""));
            }, 1);
        },
        /**
         * Provide feedback to user, cell was not changed.
         * @param {jQuery} $td edited cell
         */
        flashError: function($td) {
            var transp = 0, multiplicator = 1, timer = setInterval(function() {
                transp += .01 * multiplicator, $td.css("background", "rgba(240,54,69," + transp + ")"), 
                transp >= 1 && (multiplicator = -1), 0 >= transp && (clearInterval(timer), $td.css("background", ""));
            }, 1);
        },
        /**
         * Init key bindings to an edited control.
         * @param {jQuery} $control
         */
        initBindings: function($control) {
            var that = this, keypress = function(event) {
                if (13 === event.keyCode) {
                    //enter
                    if ("TEXTAREA" === this.tagName) return;
                    return saveData(this), event.preventDefault(), !1;
                }
            }, keydown = function(event) {
                //esc
                //CTRL/CMD + ENTER
                return 27 === event.keyCode ? (that.revertChanges(that.td), that.td.removeClass("edit"), 
                event.preventDefault(), !1) : helpers.isCtrl(event) && 13 === event.keyCode ? (saveData(this), 
                event.preventDefault(), !1) : void 0;
            }, saveData = function(element) {
                return "object" != typeof window.Nette || window.Nette.validateControl(element) ? (that.saveData(that.value, that.componentName, that.primaryKey, that.th, that.td, that.oldValue), 
                void that.td.removeClass("edit")) : !1;
            };
            $control.off("keypress.grido").on("keypress.grido", keypress).off("keydown.grido").on("keydown.grido", keydown);
        }
    };
    /*        GRIDO HELPERS       */
    /* ========================== */
    var helpers = {
        isCtrl: function(event) {
            return (event.ctrlKey || event.metaKey) && !event.altKey;
        }
    }, old = $.fn.grido;
    /*      GRIDO NO CONFLICT     */
    /* ========================== */
    /*      GRIDO DEFAULTS        */
    /* ========================== */
    return $.fn.grido = function(options) {
        return this.each(function() {
            var $this = $(this);
            $this.data("grido") || $this.data("grido", new Grido.Grid($this, options).init());
        });
    }, $.fn.grido.noConflict = function() {
        return $.fn.grido = old, this;
    }, $.fn.grido.defaults = {
        ajax: !0,
        datepicker: {
            mask: "99.99.9999",
            format: "dd.mm.yyyy"
        }
    }, window.Grido = Grido, Grido;
}(jQuery, window, document, location, navigator), function($) {
    "use strict";
    $.fn.gridoEditable = function() {
        this.on("keyup keypress", function(e) {
            var code = e.keyCode || e.which;
            return 13 == code ? (e.preventDefault(), !1) : void 0;
        }), this.on("click", function(e) {
            return e.preventDefault(), !1;
        }), this.on("change", function() {
            var object = $(this), link = object.attr("data-handle-link").replace("REPLACE_VALUE", object.val());
            object.addClass("edit-error"), $.ajax({
                url: link,
                success: function(result) {
                    object.removeClass("edit-error"), object.addClass("edit-success");
                },
                error: function(result) {
                    object.removeClass("edit-success"), object.addClass("edit-error");
                }
            });
        });
    };
}(jQuery), function($, window, undefined) {
    /*jshint laxbreak: true, expr: true */
    "use strict";
    /**
     * @param {string} url
     * @param {Element|null} ussually Anchor or Form
     * @param {event|null} event causing the request
     */
    window.Grido.Ajax.prototype.doRequest = function(url, ui, e) {
        return $.fn.netteAjax === undefined ? void console.error('Plugin "nette.ajax.js" is missing! Run `bower install nette.ajax.js` and load it.') : void $.nette.ajax({
            url: url
        }, ui, e);
    };
}(jQuery, window), function($) {
    "use strict";
    $.nette.ext("grido", {
        load: function() {
            this.selector = $(".grido"), this.selector.grido();
        },
        success: function(payload) {
            payload.grido && (this.selector.trigger("success.ajax.grido", payload), $("[data-handle-link]").gridoEditable());
        }
    });
}(jQuery), function($, window, undefined) {
    /*jshint laxbreak: true, expr: true */
    "use strict";
    window.Grido.Grid.prototype.onInit.push(function(Grido) {
        if ($.fn.typeahead === undefined) return void console.error('Plugin "typeahead.js" is missing! Run `bower install typeahead.js` and load bundled version.');
        if (window.Bloodhound === undefined) return void console.error('Plugin "Bloodhound" required by "typeahead.js" is missing!');
        var _this = Grido;
        Grido.$element.find("input.suggest").each(function() {
            var url = $(this).data("grido-suggest-handler"), wildcard = $(this).data("grido-suggest-replacement"), options = {
                limit: $(this).data("grido-suggest-limit"),
                datumTokenizer: window.Bloodhound.tokenizers.obj.whitespace("value"),
                queryTokenizer: window.Bloodhound.tokenizers.whitespace,
                remote: {
                    url: url.replace(wildcard, "%QUERY")
                }
            };
            window.NProgress !== undefined && (options.remote.ajax = {
                beforeSend: $.proxy(window.NProgress.start),
                complete: $.proxy(window.NProgress.done)
            });
            var source = new window.Bloodhound(options);
            source.initialize(), $(this).typeahead(null, {
                displayKey: function(item) {
                    return item;
                },
                source: source.ttAdapter()
            }), $(this).on("typeahead:selected", function() {
                _this.sendFilterForm();
            });
        });
    });
}(jQuery, window), /*
Copyright 2014 Igor Vaynberg

Version: 3.4.8 Timestamp: Thu May  1 09:50:32 EDT 2014

This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
General Public License version 2 (the "GPL License"). You may choose either license to govern your
use of this software only upon the condition that you accept all of the terms of either the Apache
License or the GPL License.

You may obtain a copy of the Apache License and the GPL License at:

http://www.apache.org/licenses/LICENSE-2.0
http://www.gnu.org/licenses/gpl-2.0.html

Unless required by applicable law or agreed to in writing, software distributed under the Apache License
or the GPL Licesnse is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
either express or implied. See the Apache License and the GPL License for the specific language governing
permissions and limitations under the Apache License and the GPL License.
*/
!function(a) {
    "undefined" == typeof a.fn.each2 && a.extend(a.fn, {
        each2: function(b) {
            for (var c = a([ 0 ]), d = -1, e = this.length; ++d < e && (c.context = c[0] = this[d]) && b.call(c[0], d, c) !== !1; ) ;
            return this;
        }
    });
}(jQuery), function(a, b) {
    "use strict";
    function n(b) {
        var c = a(document.createTextNode(""));
        b.before(c), c.before(b), c.remove();
    }
    function o(a) {
        function b(a) {
            return m[a] || a;
        }
        return a.replace(/[^\u0000-\u007E]/g, b);
    }
    function p(a, b) {
        for (var c = 0, d = b.length; d > c; c += 1) if (r(a, b[c])) return c;
        return -1;
    }
    function q() {
        var b = a(l);
        b.appendTo("body");
        var c = {
            width: b.width() - b[0].clientWidth,
            height: b.height() - b[0].clientHeight
        };
        return b.remove(), c;
    }
    function r(a, c) {
        return a === c ? !0 : a === b || c === b ? !1 : null === a || null === c ? !1 : a.constructor === String ? a + "" == c + "" : c.constructor === String ? c + "" == a + "" : !1;
    }
    function s(b, c) {
        var d, e, f;
        if (null === b || b.length < 1) return [];
        for (d = b.split(c), e = 0, f = d.length; f > e; e += 1) d[e] = a.trim(d[e]);
        return d;
    }
    function t(a) {
        return a.outerWidth(!1) - a.width();
    }
    function u(c) {
        var d = "keyup-change-value";
        c.on("keydown", function() {
            a.data(c, d) === b && a.data(c, d, c.val());
        }), c.on("keyup", function() {
            var e = a.data(c, d);
            e !== b && c.val() !== e && (a.removeData(c, d), c.trigger("keyup-change"));
        });
    }
    function v(c) {
        c.on("mousemove", function(c) {
            var d = i;
            (d === b || d.x !== c.pageX || d.y !== c.pageY) && a(c.target).trigger("mousemove-filtered", c);
        });
    }
    function w(a, c, d) {
        d = d || b;
        var e;
        return function() {
            var b = arguments;
            window.clearTimeout(e), e = window.setTimeout(function() {
                c.apply(d, b);
            }, a);
        };
    }
    function x(a, b) {
        var c = w(a, function(a) {
            b.trigger("scroll-debounced", a);
        });
        b.on("scroll", function(a) {
            p(a.target, b.get()) >= 0 && c(a);
        });
    }
    function y(a) {
        a[0] !== document.activeElement && window.setTimeout(function() {
            var d, b = a[0], c = a.val().length;
            a.focus();
            var e = b.offsetWidth > 0 || b.offsetHeight > 0;
            e && b === document.activeElement && (b.setSelectionRange ? b.setSelectionRange(c, c) : b.createTextRange && (d = b.createTextRange(), 
            d.collapse(!1), d.select()));
        }, 0);
    }
    function z(b) {
        b = a(b)[0];
        var c = 0, d = 0;
        if ("selectionStart" in b) c = b.selectionStart, d = b.selectionEnd - c; else if ("selection" in document) {
            b.focus();
            var e = document.selection.createRange();
            d = document.selection.createRange().text.length, e.moveStart("character", -b.value.length), 
            c = e.text.length - d;
        }
        return {
            offset: c,
            length: d
        };
    }
    function A(a) {
        a.preventDefault(), a.stopPropagation();
    }
    function B(a) {
        a.preventDefault(), a.stopImmediatePropagation();
    }
    function C(b) {
        if (!h) {
            var c = b[0].currentStyle || window.getComputedStyle(b[0], null);
            h = a(document.createElement("div")).css({
                position: "absolute",
                left: "-10000px",
                top: "-10000px",
                display: "none",
                fontSize: c.fontSize,
                fontFamily: c.fontFamily,
                fontStyle: c.fontStyle,
                fontWeight: c.fontWeight,
                letterSpacing: c.letterSpacing,
                textTransform: c.textTransform,
                whiteSpace: "nowrap"
            }), h.attr("class", "select2-sizer"), a("body").append(h);
        }
        return h.text(b.val()), h.width();
    }
    function D(b, c, d) {
        var e, g, f = [];
        e = b.attr("class"), e && (e = "" + e, a(e.split(" ")).each2(function() {
            0 === this.indexOf("select2-") && f.push(this);
        })), e = c.attr("class"), e && (e = "" + e, a(e.split(" ")).each2(function() {
            0 !== this.indexOf("select2-") && (g = d(this), g && f.push(g));
        })), b.attr("class", f.join(" "));
    }
    function E(a, b, c, d) {
        var e = o(a.toUpperCase()).indexOf(o(b.toUpperCase())), f = b.length;
        return 0 > e ? void c.push(d(a)) : (c.push(d(a.substring(0, e))), c.push("<span class='select2-match'>"), 
        c.push(d(a.substring(e, e + f))), c.push("</span>"), void c.push(d(a.substring(e + f, a.length))));
    }
    function F(a) {
        var b = {
            "\\": "&#92;",
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;",
            "/": "&#47;"
        };
        return String(a).replace(/[&<>"'\/\\]/g, function(a) {
            return b[a];
        });
    }
    function G(c) {
        var d, e = null, f = c.quietMillis || 100, g = c.url, h = this;
        return function(i) {
            window.clearTimeout(d), d = window.setTimeout(function() {
                var d = c.data, f = g, j = c.transport || a.fn.select2.ajaxDefaults.transport, k = {
                    type: c.type || "GET",
                    cache: c.cache || !1,
                    jsonpCallback: c.jsonpCallback || b,
                    dataType: c.dataType || "json"
                }, l = a.extend({}, a.fn.select2.ajaxDefaults.params, k);
                d = d ? d.call(h, i.term, i.page, i.context) : null, f = "function" == typeof f ? f.call(h, i.term, i.page, i.context) : f, 
                e && "function" == typeof e.abort && e.abort(), c.params && (a.isFunction(c.params) ? a.extend(l, c.params.call(h)) : a.extend(l, c.params)), 
                a.extend(l, {
                    url: f,
                    dataType: c.dataType,
                    data: d,
                    success: function(a) {
                        var b = c.results(a, i.page);
                        i.callback(b);
                    }
                }), e = j.call(h, l);
            }, f);
        };
    }
    function H(b) {
        var d, e, c = b, f = function(a) {
            return "" + a.text;
        };
        a.isArray(c) && (e = c, c = {
            results: e
        }), a.isFunction(c) === !1 && (e = c, c = function() {
            return e;
        });
        var g = c();
        return g.text && (f = g.text, a.isFunction(f) || (d = g.text, f = function(a) {
            return a[d];
        })), function(b) {
            var g, d = b.term, e = {
                results: []
            };
            return "" === d ? void b.callback(c()) : (g = function(c, e) {
                var h, i;
                if (c = c[0], c.children) {
                    h = {};
                    for (i in c) c.hasOwnProperty(i) && (h[i] = c[i]);
                    h.children = [], a(c.children).each2(function(a, b) {
                        g(b, h.children);
                    }), (h.children.length || b.matcher(d, f(h), c)) && e.push(h);
                } else b.matcher(d, f(c), c) && e.push(c);
            }, a(c().results).each2(function(a, b) {
                g(b, e.results);
            }), void b.callback(e));
        };
    }
    function I(c) {
        var d = a.isFunction(c);
        return function(e) {
            var f = e.term, g = {
                results: []
            }, h = d ? c(e) : c;
            a.isArray(h) && (a(h).each(function() {
                var a = this.text !== b, c = a ? this.text : this;
                ("" === f || e.matcher(f, c)) && g.results.push(a ? this : {
                    id: this,
                    text: this
                });
            }), e.callback(g));
        };
    }
    function J(b, c) {
        if (a.isFunction(b)) return !0;
        if (!b) return !1;
        if ("string" == typeof b) return !0;
        throw new Error(c + " must be a string, function, or falsy value");
    }
    function K(b) {
        if (a.isFunction(b)) {
            var c = Array.prototype.slice.call(arguments, 1);
            return b.apply(null, c);
        }
        return b;
    }
    function L(b) {
        var c = 0;
        return a.each(b, function(a, b) {
            b.children ? c += L(b.children) : c++;
        }), c;
    }
    function M(a, c, d, e) {
        var h, i, j, k, l, f = a, g = !1;
        if (!e.createSearchChoice || !e.tokenSeparators || e.tokenSeparators.length < 1) return b;
        for (;;) {
            for (i = -1, j = 0, k = e.tokenSeparators.length; k > j && (l = e.tokenSeparators[j], 
            i = a.indexOf(l), !(i >= 0)); j++) ;
            if (0 > i) break;
            if (h = a.substring(0, i), a = a.substring(i + l.length), h.length > 0 && (h = e.createSearchChoice.call(this, h, c), 
            h !== b && null !== h && e.id(h) !== b && null !== e.id(h))) {
                for (g = !1, j = 0, k = c.length; k > j; j++) if (r(e.id(h), e.id(c[j]))) {
                    g = !0;
                    break;
                }
                g || d(h);
            }
        }
        return f !== a ? a : void 0;
    }
    function N() {
        var a = this;
        Array.prototype.forEach.call(arguments, function(b) {
            a[b].remove(), a[b] = null;
        });
    }
    function O(b, c) {
        var d = function() {};
        return d.prototype = new b(), d.prototype.constructor = d, d.prototype.parent = b.prototype, 
        d.prototype = a.extend(d.prototype, c), d;
    }
    if (window.Select2 === b) {
        var c, d, e, f, g, h, j, k, i = {
            x: 0,
            y: 0
        }, c = {
            TAB: 9,
            ENTER: 13,
            ESC: 27,
            SPACE: 32,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            SHIFT: 16,
            CTRL: 17,
            ALT: 18,
            PAGE_UP: 33,
            PAGE_DOWN: 34,
            HOME: 36,
            END: 35,
            BACKSPACE: 8,
            DELETE: 46,
            isArrow: function(a) {
                switch (a = a.which ? a.which : a) {
                  case c.LEFT:
                  case c.RIGHT:
                  case c.UP:
                  case c.DOWN:
                    return !0;
                }
                return !1;
            },
            isControl: function(a) {
                var b = a.which;
                switch (b) {
                  case c.SHIFT:
                  case c.CTRL:
                  case c.ALT:
                    return !0;
                }
                return a.metaKey ? !0 : !1;
            },
            isFunctionKey: function(a) {
                return a = a.which ? a.which : a, a >= 112 && 123 >= a;
            }
        }, l = "<div class='select2-measure-scrollbar'></div>", m = {
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "AA",
            "": "AE",
            "": "AE",
            "": "AE",
            "": "AO",
            "": "AU",
            "": "AV",
            "": "AV",
            "": "AY",
            "": "B",
            "": "B",
            "": "B",
            "": "B",
            "": "B",
            "": "B",
            "": "B",
            "": "B",
            "": "C",
            "": "C",
            "": "C",
            "": "C",
            "": "C",
            "": "C",
            "": "C",
            "": "C",
            "": "C",
            "": "C",
            "": "C",
            "": "D",
            "": "D",
            "": "D",
            "": "D",
            "": "D",
            "": "D",
            "": "D",
            "": "D",
            "": "D",
            "": "D",
            "": "D",
            "": "D",
            "": "D",
            "": "DZ",
            "": "DZ",
            "": "Dz",
            "": "Dz",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "F",
            "": "F",
            "": "F",
            "": "F",
            "": "F",
            "": "G",
            "": "G",
            "": "G",
            "": "G",
            "": "G",
            "": "G",
            "": "G",
            "": "G",
            "": "G",
            "": "G",
            "": "G",
            "": "G",
            "": "G",
            "": "G",
            "": "H",
            "": "H",
            "": "H",
            "": "H",
            "": "H",
            "": "H",
            "": "H",
            "": "H",
            "": "H",
            "": "H",
            "": "H",
            "": "H",
            "": "H",
            "": "I",
            "": "I",
            "": "I",
            "": "I",
            "": "I",
            "": "I",
            "": "I",
            "": "I",
            "": "I",
            "": "I",
            "": "I",
            "": "I",
            "": "I",
            "": "I",
            "": "I",
            "": "I",
            "": "I",
            "": "I",
            "": "I",
            "": "J",
            "": "J",
            "": "J",
            "": "J",
            "": "K",
            "": "K",
            "": "K",
            "": "K",
            "": "K",
            "": "K",
            "": "K",
            "": "K",
            "": "K",
            "": "K",
            "": "K",
            "": "K",
            "": "K",
            "": "L",
            "": "L",
            "": "L",
            "": "L",
            "": "L",
            "": "L",
            "": "L",
            "": "L",
            "": "L",
            "": "L",
            "": "L",
            "": "L",
            "": "L",
            "": "L",
            "": "L",
            "": "L",
            "": "L",
            "": "LJ",
            "": "Lj",
            "": "M",
            "": "M",
            "": "M",
            "": "M",
            "": "M",
            "": "M",
            "": "M",
            "": "N",
            "": "N",
            "": "N",
            "": "N",
            "": "N",
            "": "N",
            "": "N",
            "": "N",
            "": "N",
            "": "N",
            "": "N",
            "": "N",
            "": "N",
            "": "N",
            "": "N",
            "": "NJ",
            "": "Nj",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "OI",
            "": "OO",
            "": "OU",
            "": "P",
            "": "P",
            "": "P",
            "": "P",
            "": "P",
            "": "P",
            "": "P",
            "": "P",
            "": "P",
            "": "Q",
            "": "Q",
            "": "Q",
            "": "Q",
            "": "Q",
            "": "R",
            "": "R",
            "": "R",
            "": "R",
            "": "R",
            "": "R",
            "": "R",
            "": "R",
            "": "R",
            "": "R",
            "": "R",
            "": "R",
            "": "R",
            "": "R",
            "": "R",
            "": "R",
            "": "S",
            "": "S",
            "": "S",
            "": "S",
            "": "S",
            "": "S",
            "": "S",
            "": "S",
            "": "S",
            "": "S",
            "": "S",
            "": "S",
            "": "S",
            "": "S",
            "": "S",
            "": "S",
            "": "T",
            "": "T",
            "": "T",
            "": "T",
            "": "T",
            "": "T",
            "": "T",
            "": "T",
            "": "T",
            "": "T",
            "": "T",
            "": "T",
            "": "T",
            "": "T",
            "": "TZ",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "V",
            "": "V",
            "": "V",
            "": "V",
            "": "V",
            "": "V",
            "": "V",
            "": "VY",
            "": "W",
            "": "W",
            "": "W",
            "": "W",
            "": "W",
            "": "W",
            "": "W",
            "": "W",
            "": "W",
            "": "X",
            "": "X",
            "": "X",
            "": "X",
            "": "Y",
            "": "Y",
            "": "Y",
            "": "Y",
            "": "Y",
            "": "Y",
            "": "Y",
            "": "Y",
            "": "Y",
            "": "Y",
            "": "Y",
            "": "Y",
            "": "Y",
            "": "Y",
            "": "Z",
            "": "Z",
            "": "Z",
            "": "Z",
            "": "Z",
            "": "Z",
            "": "Z",
            "": "Z",
            "": "Z",
            "": "Z",
            "": "Z",
            "": "Z",
            "": "Z",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "aa",
            "": "ae",
            "": "ae",
            "": "ae",
            "": "ao",
            "": "au",
            "": "av",
            "": "av",
            "": "ay",
            "": "b",
            "": "b",
            "": "b",
            "": "b",
            "": "b",
            "": "b",
            "": "b",
            "": "b",
            "": "c",
            "": "c",
            "": "c",
            "": "c",
            "": "c",
            "": "c",
            "": "c",
            "": "c",
            "": "c",
            "": "c",
            "": "c",
            "": "c",
            "": "d",
            "": "d",
            "": "d",
            "": "d",
            "": "d",
            "": "d",
            "": "d",
            "": "d",
            "": "d",
            "": "d",
            "": "d",
            "": "d",
            "": "d",
            "": "dz",
            "": "dz",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "f",
            "": "f",
            "": "f",
            "": "f",
            "": "f",
            "": "g",
            "": "g",
            "": "g",
            "": "g",
            "": "g",
            "": "g",
            "": "g",
            "": "g",
            "": "g",
            "": "g",
            "": "g",
            "": "g",
            "": "g",
            "": "g",
            "": "h",
            "": "h",
            "": "h",
            "": "h",
            "": "h",
            "": "h",
            "": "h",
            "": "h",
            "": "h",
            "": "h",
            "": "h",
            "": "h",
            "": "h",
            "": "h",
            "": "hv",
            "": "i",
            "": "i",
            "": "i",
            "": "i",
            "": "i",
            "": "i",
            "": "i",
            "": "i",
            "": "i",
            "": "i",
            "": "i",
            "": "i",
            "": "i",
            "": "i",
            "": "i",
            "": "i",
            "": "i",
            "": "i",
            "": "i",
            "": "j",
            "": "j",
            "": "j",
            "": "j",
            "": "j",
            "": "k",
            "": "k",
            "": "k",
            "": "k",
            "": "k",
            "": "k",
            "": "k",
            "": "k",
            "": "k",
            "": "k",
            "": "k",
            "": "k",
            "": "k",
            "": "l",
            "": "l",
            "": "l",
            "": "l",
            "": "l",
            "": "l",
            "": "l",
            "": "l",
            "": "l",
            "": "l",
            "": "l",
            "": "l",
            "": "l",
            "": "l",
            "": "l",
            "": "l",
            "": "l",
            "": "l",
            "": "lj",
            "": "m",
            "": "m",
            "": "m",
            "": "m",
            "": "m",
            "": "m",
            "": "m",
            "": "n",
            "": "n",
            "": "n",
            "": "n",
            "": "n",
            "": "n",
            "": "n",
            "": "n",
            "": "n",
            "": "n",
            "": "n",
            "": "n",
            "": "n",
            "": "n",
            "": "n",
            "": "n",
            "": "nj",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "oi",
            "": "ou",
            "": "oo",
            "": "p",
            "": "p",
            "": "p",
            "": "p",
            "": "p",
            "": "p",
            "": "p",
            "": "p",
            "": "p",
            "": "q",
            "": "q",
            "": "q",
            "": "q",
            "": "q",
            "": "r",
            "": "r",
            "": "r",
            "": "r",
            "": "r",
            "": "r",
            "": "r",
            "": "r",
            "": "r",
            "": "r",
            "": "r",
            "": "r",
            "": "r",
            "": "r",
            "": "r",
            "": "r",
            "": "s",
            "": "s",
            "": "s",
            "": "s",
            "": "s",
            "": "s",
            "": "s",
            "": "s",
            "": "s",
            "": "s",
            "": "s",
            "": "s",
            "": "s",
            "": "s",
            "": "s",
            "": "s",
            "": "s",
            "": "t",
            "": "t",
            "": "t",
            "": "t",
            "": "t",
            "": "t",
            "": "t",
            "": "t",
            "": "t",
            "": "t",
            "": "t",
            "": "t",
            "": "t",
            "": "t",
            "": "t",
            "": "tz",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "v",
            "": "v",
            "": "v",
            "": "v",
            "": "v",
            "": "v",
            "": "v",
            "": "vy",
            "": "w",
            "": "w",
            "": "w",
            "": "w",
            "": "w",
            "": "w",
            "": "w",
            "": "w",
            "": "w",
            "": "w",
            "": "x",
            "": "x",
            "": "x",
            "": "x",
            "": "y",
            "": "y",
            "": "y",
            "": "y",
            "": "y",
            "": "y",
            "": "y",
            "": "y",
            "": "y",
            "": "y",
            "": "y",
            "": "y",
            "": "y",
            "": "y",
            "": "y",
            "": "z",
            "": "z",
            "": "z",
            "": "z",
            "": "z",
            "": "z",
            "": "z",
            "": "z",
            "": "z",
            "": "z",
            "": "z",
            "": "z",
            "": "z"
        };
        j = a(document), g = function() {
            var a = 1;
            return function() {
                return a++;
            };
        }(), j.on("mousemove", function(a) {
            i.x = a.pageX, i.y = a.pageY;
        }), d = O(Object, {
            bind: function(a) {
                var b = this;
                return function() {
                    a.apply(b, arguments);
                };
            },
            init: function(c) {
                var d, e, f = ".select2-results";
                this.opts = c = this.prepareOpts(c), this.id = c.id, c.element.data("select2") !== b && null !== c.element.data("select2") && c.element.data("select2").destroy(), 
                this.container = this.createContainer(), this.liveRegion = a("<span>", {
                    role: "status",
                    "aria-live": "polite"
                }).addClass("select2-hidden-accessible").appendTo(document.body), this.containerId = "s2id_" + (c.element.attr("id") || "autogen" + g()), 
                this.containerEventName = this.containerId.replace(/([.])/g, "_").replace(/([;&,\-\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g, "\\$1"), 
                this.container.attr("id", this.containerId), this.container.attr("title", c.element.attr("title")), 
                this.body = a("body"), D(this.container, this.opts.element, this.opts.adaptContainerCssClass), 
                this.container.attr("style", c.element.attr("style")), this.container.css(K(c.containerCss)), 
                this.container.addClass(K(c.containerCssClass)), this.elementTabIndex = this.opts.element.attr("tabindex"), 
                this.opts.element.data("select2", this).attr("tabindex", "-1").before(this.container).on("click.select2", A), 
                this.container.data("select2", this), this.dropdown = this.container.find(".select2-drop"), 
                D(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass), this.dropdown.addClass(K(c.dropdownCssClass)), 
                this.dropdown.data("select2", this), this.dropdown.on("click", A), this.results = d = this.container.find(f), 
                this.search = e = this.container.find("input.select2-input"), this.queryCount = 0, 
                this.resultsPage = 0, this.context = null, this.initContainer(), this.container.on("click", A), 
                v(this.results), this.dropdown.on("mousemove-filtered", f, this.bind(this.highlightUnderEvent)), 
                this.dropdown.on("touchstart touchmove touchend", f, this.bind(function(a) {
                    this._touchEvent = !0, this.highlightUnderEvent(a);
                })), this.dropdown.on("touchmove", f, this.bind(this.touchMoved)), this.dropdown.on("touchstart touchend", f, this.bind(this.clearTouchMoved)), 
                this.dropdown.on("click", this.bind(function() {
                    this._touchEvent && (this._touchEvent = !1, this.selectHighlighted());
                })), x(80, this.results), this.dropdown.on("scroll-debounced", f, this.bind(this.loadMoreIfNeeded)), 
                a(this.container).on("change", ".select2-input", function(a) {
                    a.stopPropagation();
                }), a(this.dropdown).on("change", ".select2-input", function(a) {
                    a.stopPropagation();
                }), a.fn.mousewheel && d.mousewheel(function(a, b, c, e) {
                    var f = d.scrollTop();
                    e > 0 && 0 >= f - e ? (d.scrollTop(0), A(a)) : 0 > e && d.get(0).scrollHeight - d.scrollTop() + e <= d.height() && (d.scrollTop(d.get(0).scrollHeight - d.height()), 
                    A(a));
                }), u(e), e.on("keyup-change input paste", this.bind(this.updateResults)), e.on("focus", function() {
                    e.addClass("select2-focused");
                }), e.on("blur", function() {
                    e.removeClass("select2-focused");
                }), this.dropdown.on("mouseup", f, this.bind(function(b) {
                    a(b.target).closest(".select2-result-selectable").length > 0 && (this.highlightUnderEvent(b), 
                    this.selectHighlighted(b));
                })), this.dropdown.on("click mouseup mousedown touchstart touchend focusin", function(a) {
                    a.stopPropagation();
                }), this.nextSearchTerm = b, a.isFunction(this.opts.initSelection) && (this.initSelection(), 
                this.monitorSource()), null !== c.maximumInputLength && this.search.attr("maxlength", c.maximumInputLength);
                var h = c.element.prop("disabled");
                h === b && (h = !1), this.enable(!h);
                var i = c.element.prop("readonly");
                i === b && (i = !1), this.readonly(i), k = k || q(), this.autofocus = c.element.prop("autofocus"), 
                c.element.prop("autofocus", !1), this.autofocus && this.focus(), this.search.attr("placeholder", c.searchInputPlaceholder);
            },
            destroy: function() {
                var a = this.opts.element, c = a.data("select2");
                this.close(), this.propertyObserver && (this.propertyObserver.disconnect(), this.propertyObserver = null), 
                c !== b && (c.container.remove(), c.liveRegion.remove(), c.dropdown.remove(), a.removeClass("select2-offscreen").removeData("select2").off(".select2").prop("autofocus", this.autofocus || !1), 
                this.elementTabIndex ? a.attr({
                    tabindex: this.elementTabIndex
                }) : a.removeAttr("tabindex"), a.show()), N.call(this, "container", "liveRegion", "dropdown", "results", "search");
            },
            optionToData: function(a) {
                return a.is("option") ? {
                    id: a.prop("value"),
                    text: a.text(),
                    element: a.get(),
                    css: a.attr("class"),
                    disabled: a.prop("disabled"),
                    locked: r(a.attr("locked"), "locked") || r(a.data("locked"), !0)
                } : a.is("optgroup") ? {
                    text: a.attr("label"),
                    children: [],
                    element: a.get(),
                    css: a.attr("class")
                } : void 0;
            },
            prepareOpts: function(c) {
                var d, e, f, h, i = this;
                if (d = c.element, "select" === d.get(0).tagName.toLowerCase() && (this.select = e = c.element), 
                e && a.each([ "id", "multiple", "ajax", "query", "createSearchChoice", "initSelection", "data", "tags" ], function() {
                    if (this in c) throw new Error("Option '" + this + "' is not allowed for Select2 when attached to a <select> element.");
                }), c = a.extend({}, {
                    populateResults: function(d, e, f) {
                        var h, j = this.opts.id, k = this.liveRegion;
                        (h = function(d, e, l) {
                            var m, n, o, p, q, r, s, t, u, v;
                            for (d = c.sortResults(d, e, f), m = 0, n = d.length; n > m; m += 1) o = d[m], q = o.disabled === !0, 
                            p = !q && j(o) !== b, r = o.children && o.children.length > 0, s = a("<li></li>"), 
                            s.addClass("select2-results-dept-" + l), s.addClass("select2-result"), s.addClass(p ? "select2-result-selectable" : "select2-result-unselectable"), 
                            q && s.addClass("select2-disabled"), r && s.addClass("select2-result-with-children"), 
                            s.addClass(i.opts.formatResultCssClass(o)), s.attr("role", "presentation"), t = a(document.createElement("div")), 
                            t.addClass("select2-result-label"), t.attr("id", "select2-result-label-" + g()), 
                            t.attr("role", "option"), v = c.formatResult(o, t, f, i.opts.escapeMarkup), v !== b && (t.html(v), 
                            s.append(t)), r && (u = a("<ul></ul>"), u.addClass("select2-result-sub"), h(o.children, u, l + 1), 
                            s.append(u)), s.data("select2-data", o), e.append(s);
                            k.text(c.formatMatches(d.length));
                        })(e, d, 0);
                    }
                }, a.fn.select2.defaults, c), "function" != typeof c.id && (f = c.id, c.id = function(a) {
                    return a[f];
                }), a.isArray(c.element.data("select2Tags"))) {
                    if ("tags" in c) throw "tags specified as both an attribute 'data-select2-tags' and in options of Select2 " + c.element.attr("id");
                    c.tags = c.element.data("select2Tags");
                }
                if (e ? (c.query = this.bind(function(a) {
                    var f, g, h, c = {
                        results: [],
                        more: !1
                    }, e = a.term;
                    h = function(b, c) {
                        var d;
                        b.is("option") ? a.matcher(e, b.text(), b) && c.push(i.optionToData(b)) : b.is("optgroup") && (d = i.optionToData(b), 
                        b.children().each2(function(a, b) {
                            h(b, d.children);
                        }), d.children.length > 0 && c.push(d));
                    }, f = d.children(), this.getPlaceholder() !== b && f.length > 0 && (g = this.getPlaceholderOption(), 
                    g && (f = f.not(g))), f.each2(function(a, b) {
                        h(b, c.results);
                    }), a.callback(c);
                }), c.id = function(a) {
                    return a.id;
                }) : "query" in c || ("ajax" in c ? (h = c.element.data("ajax-url"), h && h.length > 0 && (c.ajax.url = h), 
                c.query = G.call(c.element, c.ajax)) : "data" in c ? c.query = H(c.data) : "tags" in c && (c.query = I(c.tags), 
                c.createSearchChoice === b && (c.createSearchChoice = function(b) {
                    return {
                        id: a.trim(b),
                        text: a.trim(b)
                    };
                }), c.initSelection === b && (c.initSelection = function(b, d) {
                    var e = [];
                    a(s(b.val(), c.separator)).each(function() {
                        var b = {
                            id: this,
                            text: this
                        }, d = c.tags;
                        a.isFunction(d) && (d = d()), a(d).each(function() {
                            return r(this.id, b.id) ? (b = this, !1) : void 0;
                        }), e.push(b);
                    }), d(e);
                }))), "function" != typeof c.query) throw "query function not defined for Select2 " + c.element.attr("id");
                if ("top" === c.createSearchChoicePosition) c.createSearchChoicePosition = function(a, b) {
                    a.unshift(b);
                }; else if ("bottom" === c.createSearchChoicePosition) c.createSearchChoicePosition = function(a, b) {
                    a.push(b);
                }; else if ("function" != typeof c.createSearchChoicePosition) throw "invalid createSearchChoicePosition option must be 'top', 'bottom' or a custom function";
                return c;
            },
            monitorSource: function() {
                var c, d, a = this.opts.element;
                a.on("change.select2", this.bind(function() {
                    this.opts.element.data("select2-change-triggered") !== !0 && this.initSelection();
                })), c = this.bind(function() {
                    var c = a.prop("disabled");
                    c === b && (c = !1), this.enable(!c);
                    var d = a.prop("readonly");
                    d === b && (d = !1), this.readonly(d), D(this.container, this.opts.element, this.opts.adaptContainerCssClass), 
                    this.container.addClass(K(this.opts.containerCssClass)), D(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass), 
                    this.dropdown.addClass(K(this.opts.dropdownCssClass));
                }), a.length && a[0].attachEvent && a.each(function() {
                    this.attachEvent("onpropertychange", c);
                }), d = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver, 
                d !== b && (this.propertyObserver && (delete this.propertyObserver, this.propertyObserver = null), 
                this.propertyObserver = new d(function(a) {
                    a.forEach(c);
                }), this.propertyObserver.observe(a.get(0), {
                    attributes: !0,
                    subtree: !1
                }));
            },
            triggerSelect: function(b) {
                var c = a.Event("select2-selecting", {
                    val: this.id(b),
                    object: b
                });
                return this.opts.element.trigger(c), !c.isDefaultPrevented();
            },
            triggerChange: function(b) {
                b = b || {}, b = a.extend({}, b, {
                    type: "change",
                    val: this.val()
                }), this.opts.element.data("select2-change-triggered", !0), this.opts.element.trigger(b), 
                this.opts.element.data("select2-change-triggered", !1), this.opts.element.click(), 
                this.opts.blurOnChange && this.opts.element.blur();
            },
            isInterfaceEnabled: function() {
                return this.enabledInterface === !0;
            },
            enableInterface: function() {
                var a = this._enabled && !this._readonly, b = !a;
                return a === this.enabledInterface ? !1 : (this.container.toggleClass("select2-container-disabled", b), 
                this.close(), this.enabledInterface = a, !0);
            },
            enable: function(a) {
                a === b && (a = !0), this._enabled !== a && (this._enabled = a, this.opts.element.prop("disabled", !a), 
                this.enableInterface());
            },
            disable: function() {
                this.enable(!1);
            },
            readonly: function(a) {
                a === b && (a = !1), this._readonly !== a && (this._readonly = a, this.opts.element.prop("readonly", a), 
                this.enableInterface());
            },
            opened: function() {
                return this.container.hasClass("select2-dropdown-open");
            },
            positionDropdown: function() {
                var t, u, v, w, x, b = this.dropdown, c = this.container.offset(), d = this.container.outerHeight(!1), e = this.container.outerWidth(!1), f = b.outerHeight(!1), g = a(window), h = g.width(), i = g.height(), j = g.scrollLeft() + h, l = g.scrollTop() + i, m = c.top + d, n = c.left, o = l >= m + f, p = c.top - f >= g.scrollTop(), q = b.outerWidth(!1), r = j >= n + q, s = b.hasClass("select2-drop-above");
                s ? (u = !0, !p && o && (v = !0, u = !1)) : (u = !1, !o && p && (v = !0, u = !0)), 
                v && (b.hide(), c = this.container.offset(), d = this.container.outerHeight(!1), 
                e = this.container.outerWidth(!1), f = b.outerHeight(!1), j = g.scrollLeft() + h, 
                l = g.scrollTop() + i, m = c.top + d, n = c.left, q = b.outerWidth(!1), r = j >= n + q, 
                b.show(), this.focusSearch()), this.opts.dropdownAutoWidth ? (x = a(".select2-results", b)[0], 
                b.addClass("select2-drop-auto-width"), b.css("width", ""), q = b.outerWidth(!1) + (x.scrollHeight === x.clientHeight ? 0 : k.width), 
                q > e ? e = q : q = e, f = b.outerHeight(!1), r = j >= n + q) : this.container.removeClass("select2-drop-auto-width"), 
                "static" !== this.body.css("position") && (t = this.body.offset(), m -= t.top, n -= t.left), 
                r || (n = c.left + this.container.outerWidth(!1) - q), w = {
                    left: n,
                    width: e
                }, u ? (w.top = c.top - f, w.bottom = "auto", this.container.addClass("select2-drop-above"), 
                b.addClass("select2-drop-above")) : (w.top = m, w.bottom = "auto", this.container.removeClass("select2-drop-above"), 
                b.removeClass("select2-drop-above")), w = a.extend(w, K(this.opts.dropdownCss)), 
                b.css(w);
            },
            shouldOpen: function() {
                var b;
                return this.opened() ? !1 : this._enabled === !1 || this._readonly === !0 ? !1 : (b = a.Event("select2-opening"), 
                this.opts.element.trigger(b), !b.isDefaultPrevented());
            },
            clearDropdownAlignmentPreference: function() {
                this.container.removeClass("select2-drop-above"), this.dropdown.removeClass("select2-drop-above");
            },
            open: function() {
                return this.shouldOpen() ? (this.opening(), !0) : !1;
            },
            opening: function() {
                var f, b = this.containerEventName, c = "scroll." + b, d = "resize." + b, e = "orientationchange." + b;
                this.container.addClass("select2-dropdown-open").addClass("select2-container-active"), 
                this.clearDropdownAlignmentPreference(), this.dropdown[0] !== this.body.children().last()[0] && this.dropdown.detach().appendTo(this.body), 
                f = a("#select2-drop-mask"), 0 == f.length && (f = a(document.createElement("div")), 
                f.attr("id", "select2-drop-mask").attr("class", "select2-drop-mask"), f.hide(), 
                f.appendTo(this.body), f.on("mousedown touchstart click", function(b) {
                    n(f);
                    var d, c = a("#select2-drop");
                    c.length > 0 && (d = c.data("select2"), d.opts.selectOnBlur && d.selectHighlighted({
                        noFocus: !0
                    }), d.close(), b.preventDefault(), b.stopPropagation());
                })), this.dropdown.prev()[0] !== f[0] && this.dropdown.before(f), a("#select2-drop").removeAttr("id"), 
                this.dropdown.attr("id", "select2-drop"), f.show(), this.positionDropdown(), this.dropdown.show(), 
                this.positionDropdown(), this.dropdown.addClass("select2-drop-active");
                var g = this;
                this.container.parents().add(window).each(function() {
                    a(this).on(d + " " + c + " " + e, function() {
                        g.opened() && g.positionDropdown();
                    });
                });
            },
            close: function() {
                if (this.opened()) {
                    var b = this.containerEventName, c = "scroll." + b, d = "resize." + b, e = "orientationchange." + b;
                    this.container.parents().add(window).each(function() {
                        a(this).off(c).off(d).off(e);
                    }), this.clearDropdownAlignmentPreference(), a("#select2-drop-mask").hide(), this.dropdown.removeAttr("id"), 
                    this.dropdown.hide(), this.container.removeClass("select2-dropdown-open").removeClass("select2-container-active"), 
                    this.results.empty(), this.clearSearch(), this.search.removeClass("select2-active"), 
                    this.opts.element.trigger(a.Event("select2-close"));
                }
            },
            externalSearch: function(a) {
                this.open(), this.search.val(a), this.updateResults(!1);
            },
            clearSearch: function() {},
            getMaximumSelectionSize: function() {
                return K(this.opts.maximumSelectionSize);
            },
            ensureHighlightVisible: function() {
                var c, d, e, f, g, h, i, b = this.results;
                if (d = this.highlight(), !(0 > d)) {
                    if (0 == d) return void b.scrollTop(0);
                    c = this.findHighlightableChoices().find(".select2-result-label"), e = a(c[d]), 
                    f = e.offset().top + e.outerHeight(!0), d === c.length - 1 && (i = b.find("li.select2-more-results"), 
                    i.length > 0 && (f = i.offset().top + i.outerHeight(!0))), g = b.offset().top + b.outerHeight(!0), 
                    f > g && b.scrollTop(b.scrollTop() + (f - g)), h = e.offset().top - b.offset().top, 
                    0 > h && "none" != e.css("display") && b.scrollTop(b.scrollTop() + h);
                }
            },
            findHighlightableChoices: function() {
                return this.results.find(".select2-result-selectable:not(.select2-disabled):not(.select2-selected)");
            },
            moveHighlight: function(b) {
                for (var c = this.findHighlightableChoices(), d = this.highlight(); d > -1 && d < c.length; ) {
                    d += b;
                    var e = a(c[d]);
                    if (e.hasClass("select2-result-selectable") && !e.hasClass("select2-disabled") && !e.hasClass("select2-selected")) {
                        this.highlight(d);
                        break;
                    }
                }
            },
            highlight: function(b) {
                var d, e, c = this.findHighlightableChoices();
                return 0 === arguments.length ? p(c.filter(".select2-highlighted")[0], c.get()) : (b >= c.length && (b = c.length - 1), 
                0 > b && (b = 0), this.removeHighlight(), d = a(c[b]), d.addClass("select2-highlighted"), 
                this.search.attr("aria-activedescendant", d.find(".select2-result-label").attr("id")), 
                this.ensureHighlightVisible(), this.liveRegion.text(d.text()), e = d.data("select2-data"), 
                void (e && this.opts.element.trigger({
                    type: "select2-highlight",
                    val: this.id(e),
                    choice: e
                })));
            },
            removeHighlight: function() {
                this.results.find(".select2-highlighted").removeClass("select2-highlighted");
            },
            touchMoved: function() {
                this._touchMoved = !0;
            },
            clearTouchMoved: function() {
                this._touchMoved = !1;
            },
            countSelectableResults: function() {
                return this.findHighlightableChoices().length;
            },
            highlightUnderEvent: function(b) {
                var c = a(b.target).closest(".select2-result-selectable");
                if (c.length > 0 && !c.is(".select2-highlighted")) {
                    var d = this.findHighlightableChoices();
                    this.highlight(d.index(c));
                } else 0 == c.length && this.removeHighlight();
            },
            loadMoreIfNeeded: function() {
                var c, a = this.results, b = a.find("li.select2-more-results"), d = this.resultsPage + 1, e = this, f = this.search.val(), g = this.context;
                0 !== b.length && (c = b.offset().top - a.offset().top - a.height(), c <= this.opts.loadMorePadding && (b.addClass("select2-active"), 
                this.opts.query({
                    element: this.opts.element,
                    term: f,
                    page: d,
                    context: g,
                    matcher: this.opts.matcher,
                    callback: this.bind(function(c) {
                        e.opened() && (e.opts.populateResults.call(this, a, c.results, {
                            term: f,
                            page: d,
                            context: g
                        }), e.postprocessResults(c, !1, !1), c.more === !0 ? (b.detach().appendTo(a).text(K(e.opts.formatLoadMore, d + 1)), 
                        window.setTimeout(function() {
                            e.loadMoreIfNeeded();
                        }, 10)) : b.remove(), e.positionDropdown(), e.resultsPage = d, e.context = c.context, 
                        this.opts.element.trigger({
                            type: "select2-loaded",
                            items: c
                        }));
                    })
                })));
            },
            tokenize: function() {},
            updateResults: function(c) {
                function m() {
                    d.removeClass("select2-active"), h.positionDropdown(), e.find(".select2-no-results,.select2-selection-limit,.select2-searching").length ? h.liveRegion.text(e.text()) : h.liveRegion.text(h.opts.formatMatches(e.find(".select2-result-selectable").length));
                }
                function n(a) {
                    e.html(a), m();
                }
                var g, i, l, d = this.search, e = this.results, f = this.opts, h = this, j = d.val(), k = a.data(this.container, "select2-last-term");
                if ((c === !0 || !k || !r(j, k)) && (a.data(this.container, "select2-last-term", j), 
                c === !0 || this.showSearchInput !== !1 && this.opened())) {
                    l = ++this.queryCount;
                    var o = this.getMaximumSelectionSize();
                    if (o >= 1 && (g = this.data(), a.isArray(g) && g.length >= o && J(f.formatSelectionTooBig, "formatSelectionTooBig"))) return void n("<li class='select2-selection-limit'>" + K(f.formatSelectionTooBig, o) + "</li>");
                    if (d.val().length < f.minimumInputLength) return n(J(f.formatInputTooShort, "formatInputTooShort") ? "<li class='select2-no-results'>" + K(f.formatInputTooShort, d.val(), f.minimumInputLength) + "</li>" : ""), 
                    void (c && this.showSearch && this.showSearch(!0));
                    if (f.maximumInputLength && d.val().length > f.maximumInputLength) return void n(J(f.formatInputTooLong, "formatInputTooLong") ? "<li class='select2-no-results'>" + K(f.formatInputTooLong, d.val(), f.maximumInputLength) + "</li>" : "");
                    f.formatSearching && 0 === this.findHighlightableChoices().length && n("<li class='select2-searching'>" + K(f.formatSearching) + "</li>"), 
                    d.addClass("select2-active"), this.removeHighlight(), i = this.tokenize(), i != b && null != i && d.val(i), 
                    this.resultsPage = 1, f.query({
                        element: f.element,
                        term: d.val(),
                        page: this.resultsPage,
                        context: null,
                        matcher: f.matcher,
                        callback: this.bind(function(g) {
                            var i;
                            if (l == this.queryCount) {
                                if (!this.opened()) return void this.search.removeClass("select2-active");
                                if (this.context = g.context === b ? null : g.context, this.opts.createSearchChoice && "" !== d.val() && (i = this.opts.createSearchChoice.call(h, d.val(), g.results), 
                                i !== b && null !== i && h.id(i) !== b && null !== h.id(i) && 0 === a(g.results).filter(function() {
                                    return r(h.id(this), h.id(i));
                                }).length && this.opts.createSearchChoicePosition(g.results, i)), 0 === g.results.length && J(f.formatNoMatches, "formatNoMatches")) return void n("<li class='select2-no-results'>" + K(f.formatNoMatches, d.val()) + "</li>");
                                e.empty(), h.opts.populateResults.call(this, e, g.results, {
                                    term: d.val(),
                                    page: this.resultsPage,
                                    context: null
                                }), g.more === !0 && J(f.formatLoadMore, "formatLoadMore") && (e.append("<li class='select2-more-results'>" + h.opts.escapeMarkup(K(f.formatLoadMore, this.resultsPage)) + "</li>"), 
                                window.setTimeout(function() {
                                    h.loadMoreIfNeeded();
                                }, 10)), this.postprocessResults(g, c), m(), this.opts.element.trigger({
                                    type: "select2-loaded",
                                    items: g
                                });
                            }
                        })
                    });
                }
            },
            cancel: function() {
                this.close();
            },
            blur: function() {
                this.opts.selectOnBlur && this.selectHighlighted({
                    noFocus: !0
                }), this.close(), this.container.removeClass("select2-container-active"), this.search[0] === document.activeElement && this.search.blur(), 
                this.clearSearch(), this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
            },
            focusSearch: function() {
                y(this.search);
            },
            selectHighlighted: function(a) {
                if (this._touchMoved) return void this.clearTouchMoved();
                var b = this.highlight(), c = this.results.find(".select2-highlighted"), d = c.closest(".select2-result").data("select2-data");
                d ? (this.highlight(b), this.onSelect(d, a)) : a && a.noFocus && this.close();
            },
            getPlaceholder: function() {
                var a;
                return this.opts.element.attr("placeholder") || this.opts.element.attr("data-placeholder") || this.opts.element.data("placeholder") || this.opts.placeholder || ((a = this.getPlaceholderOption()) !== b ? a.text() : b);
            },
            getPlaceholderOption: function() {
                if (this.select) {
                    var c = this.select.children("option").first();
                    if (this.opts.placeholderOption !== b) return "first" === this.opts.placeholderOption && c || "function" == typeof this.opts.placeholderOption && this.opts.placeholderOption(this.select);
                    if ("" === a.trim(c.text()) && "" === c.val()) return c;
                }
            },
            initContainerWidth: function() {
                function c() {
                    var c, d, e, f, g, h;
                    if ("off" === this.opts.width) return null;
                    if ("element" === this.opts.width) return 0 === this.opts.element.outerWidth(!1) ? "auto" : this.opts.element.outerWidth(!1) + "px";
                    if ("copy" === this.opts.width || "resolve" === this.opts.width) {
                        if (c = this.opts.element.attr("style"), c !== b) for (d = c.split(";"), f = 0, 
                        g = d.length; g > f; f += 1) if (h = d[f].replace(/\s/g, ""), e = h.match(/^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i), 
                        null !== e && e.length >= 1) return e[1];
                        return "resolve" === this.opts.width ? (c = this.opts.element.css("width"), c.indexOf("%") > 0 ? c : 0 === this.opts.element.outerWidth(!1) ? "auto" : this.opts.element.outerWidth(!1) + "px") : null;
                    }
                    return a.isFunction(this.opts.width) ? this.opts.width() : this.opts.width;
                }
                var d = c.call(this);
                null !== d && this.container.css("width", d);
            }
        }), e = O(d, {
            createContainer: function() {
                var b = a(document.createElement("div")).attr({
                    "class": "select2-container"
                }).html([ "<a href='javascript:void(0)' class='select2-choice' tabindex='-1'>", "   <span class='select2-chosen'>&#160;</span><abbr class='select2-search-choice-close'></abbr>", "   <span class='select2-arrow' role='presentation'><b role='presentation'></b></span>", "</a>", "<label for='' class='select2-offscreen'></label>", "<input class='select2-focusser select2-offscreen' type='text' aria-haspopup='true' role='button' />", "<div class='select2-drop select2-display-none'>", "   <div class='select2-search'>", "       <label for='' class='select2-offscreen'></label>", "       <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input' role='combobox' aria-expanded='true'", "       aria-autocomplete='list' />", "   </div>", "   <ul class='select2-results' role='listbox'>", "   </ul>", "</div>" ].join(""));
                return b;
            },
            enableInterface: function() {
                this.parent.enableInterface.apply(this, arguments) && this.focusser.prop("disabled", !this.isInterfaceEnabled());
            },
            opening: function() {
                var c, d, e;
                this.opts.minimumResultsForSearch >= 0 && this.showSearch(!0), this.parent.opening.apply(this, arguments), 
                this.showSearchInput !== !1 && this.search.val(this.focusser.val()), this.opts.shouldFocusInput(this) && (this.search.focus(), 
                c = this.search.get(0), c.createTextRange ? (d = c.createTextRange(), d.collapse(!1), 
                d.select()) : c.setSelectionRange && (e = this.search.val().length, c.setSelectionRange(e, e))), 
                "" === this.search.val() && this.nextSearchTerm != b && (this.search.val(this.nextSearchTerm), 
                this.search.select()), this.focusser.prop("disabled", !0).val(""), this.updateResults(!0), 
                this.opts.element.trigger(a.Event("select2-open"));
            },
            close: function() {
                this.opened() && (this.parent.close.apply(this, arguments), this.focusser.prop("disabled", !1), 
                this.opts.shouldFocusInput(this) && this.focusser.focus());
            },
            focus: function() {
                this.opened() ? this.close() : (this.focusser.prop("disabled", !1), this.opts.shouldFocusInput(this) && this.focusser.focus());
            },
            isFocused: function() {
                return this.container.hasClass("select2-container-active");
            },
            cancel: function() {
                this.parent.cancel.apply(this, arguments), this.focusser.prop("disabled", !1), this.opts.shouldFocusInput(this) && this.focusser.focus();
            },
            destroy: function() {
                a("label[for='" + this.focusser.attr("id") + "']").attr("for", this.opts.element.attr("id")), 
                this.parent.destroy.apply(this, arguments), N.call(this, "selection", "focusser");
            },
            initContainer: function() {
                var b, h, d = this.container, e = this.dropdown, f = g();
                this.opts.minimumResultsForSearch < 0 ? this.showSearch(!1) : this.showSearch(!0), 
                this.selection = b = d.find(".select2-choice"), this.focusser = d.find(".select2-focusser"), 
                b.find(".select2-chosen").attr("id", "select2-chosen-" + f), this.focusser.attr("aria-labelledby", "select2-chosen-" + f), 
                this.results.attr("id", "select2-results-" + f), this.search.attr("aria-owns", "select2-results-" + f), 
                this.focusser.attr("id", "s2id_autogen" + f), h = a("label[for='" + this.opts.element.attr("id") + "']"), 
                this.focusser.prev().text(h.text()).attr("for", this.focusser.attr("id"));
                var i = this.opts.element.attr("title");
                this.opts.element.attr("title", i || h.text()), this.focusser.attr("tabindex", this.elementTabIndex), 
                this.search.attr("id", this.focusser.attr("id") + "_search"), this.search.prev().text(a("label[for='" + this.focusser.attr("id") + "']").text()).attr("for", this.search.attr("id")), 
                this.search.on("keydown", this.bind(function(a) {
                    if (this.isInterfaceEnabled()) {
                        if (a.which === c.PAGE_UP || a.which === c.PAGE_DOWN) return void A(a);
                        switch (a.which) {
                          case c.UP:
                          case c.DOWN:
                            return this.moveHighlight(a.which === c.UP ? -1 : 1), void A(a);

                          case c.ENTER:
                            return this.selectHighlighted(), void A(a);

                          case c.TAB:
                            return void this.selectHighlighted({
                                noFocus: !0
                            });

                          case c.ESC:
                            return this.cancel(a), void A(a);
                        }
                    }
                })), this.search.on("blur", this.bind(function() {
                    document.activeElement === this.body.get(0) && window.setTimeout(this.bind(function() {
                        this.opened() && this.search.focus();
                    }), 0);
                })), this.focusser.on("keydown", this.bind(function(a) {
                    if (this.isInterfaceEnabled() && a.which !== c.TAB && !c.isControl(a) && !c.isFunctionKey(a) && a.which !== c.ESC) {
                        if (this.opts.openOnEnter === !1 && a.which === c.ENTER) return void A(a);
                        if (a.which == c.DOWN || a.which == c.UP || a.which == c.ENTER && this.opts.openOnEnter) {
                            if (a.altKey || a.ctrlKey || a.shiftKey || a.metaKey) return;
                            return this.open(), void A(a);
                        }
                        return a.which == c.DELETE || a.which == c.BACKSPACE ? (this.opts.allowClear && this.clear(), 
                        void A(a)) : void 0;
                    }
                })), u(this.focusser), this.focusser.on("keyup-change input", this.bind(function(a) {
                    if (this.opts.minimumResultsForSearch >= 0) {
                        if (a.stopPropagation(), this.opened()) return;
                        this.open();
                    }
                })), b.on("mousedown touchstart", "abbr", this.bind(function(a) {
                    this.isInterfaceEnabled() && (this.clear(), B(a), this.close(), this.selection.focus());
                })), b.on("mousedown touchstart", this.bind(function(c) {
                    n(b), this.container.hasClass("select2-container-active") || this.opts.element.trigger(a.Event("select2-focus")), 
                    this.opened() ? this.close() : this.isInterfaceEnabled() && this.open(), A(c);
                })), e.on("mousedown touchstart", this.bind(function() {
                    this.opts.shouldFocusInput(this) && this.search.focus();
                })), b.on("focus", this.bind(function(a) {
                    A(a);
                })), this.focusser.on("focus", this.bind(function() {
                    this.container.hasClass("select2-container-active") || this.opts.element.trigger(a.Event("select2-focus")), 
                    this.container.addClass("select2-container-active");
                })).on("blur", this.bind(function() {
                    this.opened() || (this.container.removeClass("select2-container-active"), this.opts.element.trigger(a.Event("select2-blur")));
                })), this.search.on("focus", this.bind(function() {
                    this.container.hasClass("select2-container-active") || this.opts.element.trigger(a.Event("select2-focus")), 
                    this.container.addClass("select2-container-active");
                })), this.initContainerWidth(), this.opts.element.addClass("select2-offscreen"), 
                this.setPlaceholder();
            },
            clear: function(b) {
                var c = this.selection.data("select2-data");
                if (c) {
                    var d = a.Event("select2-clearing");
                    if (this.opts.element.trigger(d), d.isDefaultPrevented()) return;
                    var e = this.getPlaceholderOption();
                    this.opts.element.val(e ? e.val() : ""), this.selection.find(".select2-chosen").empty(), 
                    this.selection.removeData("select2-data"), this.setPlaceholder(), b !== !1 && (this.opts.element.trigger({
                        type: "select2-removed",
                        val: this.id(c),
                        choice: c
                    }), this.triggerChange({
                        removed: c
                    }));
                }
            },
            initSelection: function() {
                if (this.isPlaceholderOptionSelected()) this.updateSelection(null), this.close(), 
                this.setPlaceholder(); else {
                    var c = this;
                    this.opts.initSelection.call(null, this.opts.element, function(a) {
                        a !== b && null !== a && (c.updateSelection(a), c.close(), c.setPlaceholder(), c.nextSearchTerm = c.opts.nextSearchTerm(a, c.search.val()));
                    });
                }
            },
            isPlaceholderOptionSelected: function() {
                var a;
                return this.getPlaceholder() === b ? !1 : (a = this.getPlaceholderOption()) !== b && a.prop("selected") || "" === this.opts.element.val() || this.opts.element.val() === b || null === this.opts.element.val();
            },
            prepareOpts: function() {
                var b = this.parent.prepareOpts.apply(this, arguments), c = this;
                return "select" === b.element.get(0).tagName.toLowerCase() ? b.initSelection = function(a, b) {
                    var d = a.find("option").filter(function() {
                        return this.selected && !this.disabled;
                    });
                    b(c.optionToData(d));
                } : "data" in b && (b.initSelection = b.initSelection || function(c, d) {
                    var e = c.val(), f = null;
                    b.query({
                        matcher: function(a, c, d) {
                            var g = r(e, b.id(d));
                            return g && (f = d), g;
                        },
                        callback: a.isFunction(d) ? function() {
                            d(f);
                        } : a.noop
                    });
                }), b;
            },
            getPlaceholder: function() {
                return this.select && this.getPlaceholderOption() === b ? b : this.parent.getPlaceholder.apply(this, arguments);
            },
            setPlaceholder: function() {
                var a = this.getPlaceholder();
                if (this.isPlaceholderOptionSelected() && a !== b) {
                    if (this.select && this.getPlaceholderOption() === b) return;
                    this.selection.find(".select2-chosen").html(this.opts.escapeMarkup(a)), this.selection.addClass("select2-default"), 
                    this.container.removeClass("select2-allowclear");
                }
            },
            postprocessResults: function(a, b, c) {
                var d = 0, e = this;
                if (this.findHighlightableChoices().each2(function(a, b) {
                    return r(e.id(b.data("select2-data")), e.opts.element.val()) ? (d = a, !1) : void 0;
                }), c !== !1 && (b === !0 && d >= 0 ? this.highlight(d) : this.highlight(0)), b === !0) {
                    var g = this.opts.minimumResultsForSearch;
                    g >= 0 && this.showSearch(L(a.results) >= g);
                }
            },
            showSearch: function(b) {
                this.showSearchInput !== b && (this.showSearchInput = b, this.dropdown.find(".select2-search").toggleClass("select2-search-hidden", !b), 
                this.dropdown.find(".select2-search").toggleClass("select2-offscreen", !b), a(this.dropdown, this.container).toggleClass("select2-with-searchbox", b));
            },
            onSelect: function(a, b) {
                if (this.triggerSelect(a)) {
                    var c = this.opts.element.val(), d = this.data();
                    this.opts.element.val(this.id(a)), this.updateSelection(a), this.opts.element.trigger({
                        type: "select2-selected",
                        val: this.id(a),
                        choice: a
                    }), this.nextSearchTerm = this.opts.nextSearchTerm(a, this.search.val()), this.close(), 
                    b && b.noFocus || !this.opts.shouldFocusInput(this) || this.focusser.focus(), r(c, this.id(a)) || this.triggerChange({
                        added: a,
                        removed: d
                    });
                }
            },
            updateSelection: function(a) {
                var d, e, c = this.selection.find(".select2-chosen");
                this.selection.data("select2-data", a), c.empty(), null !== a && (d = this.opts.formatSelection(a, c, this.opts.escapeMarkup)), 
                d !== b && c.append(d), e = this.opts.formatSelectionCssClass(a, c), e !== b && c.addClass(e), 
                this.selection.removeClass("select2-default"), this.opts.allowClear && this.getPlaceholder() !== b && this.container.addClass("select2-allowclear");
            },
            val: function() {
                var a, c = !1, d = null, e = this, f = this.data();
                if (0 === arguments.length) return this.opts.element.val();
                if (a = arguments[0], arguments.length > 1 && (c = arguments[1]), this.select) this.select.val(a).find("option").filter(function() {
                    return this.selected;
                }).each2(function(a, b) {
                    return d = e.optionToData(b), !1;
                }), this.updateSelection(d), this.setPlaceholder(), c && this.triggerChange({
                    added: d,
                    removed: f
                }); else {
                    if (!a && 0 !== a) return void this.clear(c);
                    if (this.opts.initSelection === b) throw new Error("cannot call val() if initSelection() is not defined");
                    this.opts.element.val(a), this.opts.initSelection(this.opts.element, function(a) {
                        e.opts.element.val(a ? e.id(a) : ""), e.updateSelection(a), e.setPlaceholder(), 
                        c && e.triggerChange({
                            added: a,
                            removed: f
                        });
                    });
                }
            },
            clearSearch: function() {
                this.search.val(""), this.focusser.val("");
            },
            data: function(a) {
                var c, d = !1;
                return 0 === arguments.length ? (c = this.selection.data("select2-data"), c == b && (c = null), 
                c) : (arguments.length > 1 && (d = arguments[1]), void (a ? (c = this.data(), this.opts.element.val(a ? this.id(a) : ""), 
                this.updateSelection(a), d && this.triggerChange({
                    added: a,
                    removed: c
                })) : this.clear(d)));
            }
        }), f = O(d, {
            createContainer: function() {
                var b = a(document.createElement("div")).attr({
                    "class": "select2-container select2-container-multi"
                }).html([ "<ul class='select2-choices'>", "  <li class='select2-search-field'>", "    <label for='' class='select2-offscreen'></label>", "    <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input'>", "  </li>", "</ul>", "<div class='select2-drop select2-drop-multi select2-display-none'>", "   <ul class='select2-results'>", "   </ul>", "</div>" ].join(""));
                return b;
            },
            prepareOpts: function() {
                var b = this.parent.prepareOpts.apply(this, arguments), c = this;
                return "select" === b.element.get(0).tagName.toLowerCase() ? b.initSelection = function(a, b) {
                    var d = [];
                    a.find("option").filter(function() {
                        return this.selected && !this.disabled;
                    }).each2(function(a, b) {
                        d.push(c.optionToData(b));
                    }), b(d);
                } : "data" in b && (b.initSelection = b.initSelection || function(c, d) {
                    var e = s(c.val(), b.separator), f = [];
                    b.query({
                        matcher: function(c, d, g) {
                            var h = a.grep(e, function(a) {
                                return r(a, b.id(g));
                            }).length;
                            return h && f.push(g), h;
                        },
                        callback: a.isFunction(d) ? function() {
                            for (var a = [], c = 0; c < e.length; c++) for (var g = e[c], h = 0; h < f.length; h++) {
                                var i = f[h];
                                if (r(g, b.id(i))) {
                                    a.push(i), f.splice(h, 1);
                                    break;
                                }
                            }
                            d(a);
                        } : a.noop
                    });
                }), b;
            },
            selectChoice: function(a) {
                var b = this.container.find(".select2-search-choice-focus");
                b.length && a && a[0] == b[0] || (b.length && this.opts.element.trigger("choice-deselected", b), 
                b.removeClass("select2-search-choice-focus"), a && a.length && (this.close(), a.addClass("select2-search-choice-focus"), 
                this.opts.element.trigger("choice-selected", a)));
            },
            destroy: function() {
                a("label[for='" + this.search.attr("id") + "']").attr("for", this.opts.element.attr("id")), 
                this.parent.destroy.apply(this, arguments), N.call(this, "searchContainer", "selection");
            },
            initContainer: function() {
                var d, b = ".select2-choices";
                this.searchContainer = this.container.find(".select2-search-field"), this.selection = d = this.container.find(b);
                var e = this;
                this.selection.on("click", ".select2-search-choice:not(.select2-locked)", function() {
                    e.search[0].focus(), e.selectChoice(a(this));
                }), this.search.attr("id", "s2id_autogen" + g()), this.search.prev().text(a("label[for='" + this.opts.element.attr("id") + "']").text()).attr("for", this.search.attr("id")), 
                this.search.on("input paste", this.bind(function() {
                    this.isInterfaceEnabled() && (this.opened() || this.open());
                })), this.search.attr("tabindex", this.elementTabIndex), this.keydowns = 0, this.search.on("keydown", this.bind(function(a) {
                    if (this.isInterfaceEnabled()) {
                        ++this.keydowns;
                        var b = d.find(".select2-search-choice-focus"), e = b.prev(".select2-search-choice:not(.select2-locked)"), f = b.next(".select2-search-choice:not(.select2-locked)"), g = z(this.search);
                        if (b.length && (a.which == c.LEFT || a.which == c.RIGHT || a.which == c.BACKSPACE || a.which == c.DELETE || a.which == c.ENTER)) {
                            var h = b;
                            return a.which == c.LEFT && e.length ? h = e : a.which == c.RIGHT ? h = f.length ? f : null : a.which === c.BACKSPACE ? this.unselect(b.first()) && (this.search.width(10), 
                            h = e.length ? e : f) : a.which == c.DELETE ? this.unselect(b.first()) && (this.search.width(10), 
                            h = f.length ? f : null) : a.which == c.ENTER && (h = null), this.selectChoice(h), 
                            A(a), void (h && h.length || this.open());
                        }
                        if ((a.which === c.BACKSPACE && 1 == this.keydowns || a.which == c.LEFT) && 0 == g.offset && !g.length) return this.selectChoice(d.find(".select2-search-choice:not(.select2-locked)").last()), 
                        void A(a);
                        if (this.selectChoice(null), this.opened()) switch (a.which) {
                          case c.UP:
                          case c.DOWN:
                            return this.moveHighlight(a.which === c.UP ? -1 : 1), void A(a);

                          case c.ENTER:
                            return this.selectHighlighted(), void A(a);

                          case c.TAB:
                            return this.selectHighlighted({
                                noFocus: !0
                            }), void this.close();

                          case c.ESC:
                            return this.cancel(a), void A(a);
                        }
                        if (a.which !== c.TAB && !c.isControl(a) && !c.isFunctionKey(a) && a.which !== c.BACKSPACE && a.which !== c.ESC) {
                            if (a.which === c.ENTER) {
                                if (this.opts.openOnEnter === !1) return;
                                if (a.altKey || a.ctrlKey || a.shiftKey || a.metaKey) return;
                            }
                            this.open(), (a.which === c.PAGE_UP || a.which === c.PAGE_DOWN) && A(a), a.which === c.ENTER && A(a);
                        }
                    }
                })), this.search.on("keyup", this.bind(function() {
                    this.keydowns = 0, this.resizeSearch();
                })), this.search.on("blur", this.bind(function(b) {
                    this.container.removeClass("select2-container-active"), this.search.removeClass("select2-focused"), 
                    this.selectChoice(null), this.opened() || this.clearSearch(), b.stopImmediatePropagation(), 
                    this.opts.element.trigger(a.Event("select2-blur"));
                })), this.container.on("click", b, this.bind(function(b) {
                    this.isInterfaceEnabled() && (a(b.target).closest(".select2-search-choice").length > 0 || (this.selectChoice(null), 
                    this.clearPlaceholder(), this.container.hasClass("select2-container-active") || this.opts.element.trigger(a.Event("select2-focus")), 
                    this.open(), this.focusSearch(), b.preventDefault()));
                })), this.container.on("focus", b, this.bind(function() {
                    this.isInterfaceEnabled() && (this.container.hasClass("select2-container-active") || this.opts.element.trigger(a.Event("select2-focus")), 
                    this.container.addClass("select2-container-active"), this.dropdown.addClass("select2-drop-active"), 
                    this.clearPlaceholder());
                })), this.initContainerWidth(), this.opts.element.addClass("select2-offscreen"), 
                this.clearSearch();
            },
            enableInterface: function() {
                this.parent.enableInterface.apply(this, arguments) && this.search.prop("disabled", !this.isInterfaceEnabled());
            },
            initSelection: function() {
                if ("" === this.opts.element.val() && "" === this.opts.element.text() && (this.updateSelection([]), 
                this.close(), this.clearSearch()), this.select || "" !== this.opts.element.val()) {
                    var c = this;
                    this.opts.initSelection.call(null, this.opts.element, function(a) {
                        a !== b && null !== a && (c.updateSelection(a), c.close(), c.clearSearch());
                    });
                }
            },
            clearSearch: function() {
                var a = this.getPlaceholder(), c = this.getMaxSearchWidth();
                a !== b && 0 === this.getVal().length && this.search.hasClass("select2-focused") === !1 ? (this.search.val(a).addClass("select2-default"), 
                this.search.width(c > 0 ? c : this.container.css("width"))) : this.search.val("").width(10);
            },
            clearPlaceholder: function() {
                this.search.hasClass("select2-default") && this.search.val("").removeClass("select2-default");
            },
            opening: function() {
                this.clearPlaceholder(), this.resizeSearch(), this.parent.opening.apply(this, arguments), 
                this.focusSearch(), "" === this.search.val() && this.nextSearchTerm != b && (this.search.val(this.nextSearchTerm), 
                this.search.select()), this.updateResults(!0), this.opts.shouldFocusInput(this) && this.search.focus(), 
                this.opts.element.trigger(a.Event("select2-open"));
            },
            close: function() {
                this.opened() && this.parent.close.apply(this, arguments);
            },
            focus: function() {
                this.close(), this.search.focus();
            },
            isFocused: function() {
                return this.search.hasClass("select2-focused");
            },
            updateSelection: function(b) {
                var c = [], d = [], e = this;
                a(b).each(function() {
                    p(e.id(this), c) < 0 && (c.push(e.id(this)), d.push(this));
                }), b = d, this.selection.find(".select2-search-choice").remove(), a(b).each(function() {
                    e.addSelectedChoice(this);
                }), e.postprocessResults();
            },
            tokenize: function() {
                var a = this.search.val();
                a = this.opts.tokenizer.call(this, a, this.data(), this.bind(this.onSelect), this.opts), 
                null != a && a != b && (this.search.val(a), a.length > 0 && this.open());
            },
            onSelect: function(a, c) {
                this.triggerSelect(a) && (this.addSelectedChoice(a), this.opts.element.trigger({
                    type: "selected",
                    val: this.id(a),
                    choice: a
                }), this.nextSearchTerm = this.opts.nextSearchTerm(a, this.search.val()), this.clearSearch(), 
                this.updateResults(), (this.select || !this.opts.closeOnSelect) && this.postprocessResults(a, !1, this.opts.closeOnSelect === !0), 
                this.opts.closeOnSelect ? (this.close(), this.search.width(10)) : this.countSelectableResults() > 0 ? (this.search.width(10), 
                this.resizeSearch(), this.getMaximumSelectionSize() > 0 && this.val().length >= this.getMaximumSelectionSize() ? this.updateResults(!0) : this.nextSearchTerm != b && (this.search.val(this.nextSearchTerm), 
                this.updateResults(), this.search.select()), this.positionDropdown()) : (this.close(), 
                this.search.width(10)), this.triggerChange({
                    added: a
                }), c && c.noFocus || this.focusSearch());
            },
            cancel: function() {
                this.close(), this.focusSearch();
            },
            addSelectedChoice: function(c) {
                var j, k, d = !c.locked, e = a("<li class='select2-search-choice'>    <div></div>    <a href='#' class='select2-search-choice-close' tabindex='-1'></a></li>"), f = a("<li class='select2-search-choice select2-locked'><div></div></li>"), g = d ? e : f, h = this.id(c), i = this.getVal();
                j = this.opts.formatSelection(c, g.find("div"), this.opts.escapeMarkup), j != b && g.find("div").replaceWith("<div>" + j + "</div>"), 
                k = this.opts.formatSelectionCssClass(c, g.find("div")), k != b && g.addClass(k), 
                d && g.find(".select2-search-choice-close").on("mousedown", A).on("click dblclick", this.bind(function(b) {
                    this.isInterfaceEnabled() && (this.unselect(a(b.target)), this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus"), 
                    A(b), this.close(), this.focusSearch());
                })).on("focus", this.bind(function() {
                    this.isInterfaceEnabled() && (this.container.addClass("select2-container-active"), 
                    this.dropdown.addClass("select2-drop-active"));
                })), g.data("select2-data", c), g.insertBefore(this.searchContainer), i.push(h), 
                this.setVal(i);
            },
            unselect: function(b) {
                var d, e, c = this.getVal();
                if (b = b.closest(".select2-search-choice"), 0 === b.length) throw "Invalid argument: " + b + ". Must be .select2-search-choice";
                if (d = b.data("select2-data")) {
                    var f = a.Event("select2-removing");
                    if (f.val = this.id(d), f.choice = d, this.opts.element.trigger(f), f.isDefaultPrevented()) return !1;
                    for (;(e = p(this.id(d), c)) >= 0; ) c.splice(e, 1), this.setVal(c), this.select && this.postprocessResults();
                    return b.remove(), this.opts.element.trigger({
                        type: "select2-removed",
                        val: this.id(d),
                        choice: d
                    }), this.triggerChange({
                        removed: d
                    }), !0;
                }
            },
            postprocessResults: function(a, b, c) {
                var d = this.getVal(), e = this.results.find(".select2-result"), f = this.results.find(".select2-result-with-children"), g = this;
                e.each2(function(a, b) {
                    var c = g.id(b.data("select2-data"));
                    p(c, d) >= 0 && (b.addClass("select2-selected"), b.find(".select2-result-selectable").addClass("select2-selected"));
                }), f.each2(function(a, b) {
                    b.is(".select2-result-selectable") || 0 !== b.find(".select2-result-selectable:not(.select2-selected)").length || b.addClass("select2-selected");
                }), -1 == this.highlight() && c !== !1 && g.highlight(0), !this.opts.createSearchChoice && !e.filter(".select2-result:not(.select2-selected)").length > 0 && (!a || a && !a.more && 0 === this.results.find(".select2-no-results").length) && J(g.opts.formatNoMatches, "formatNoMatches") && this.results.append("<li class='select2-no-results'>" + K(g.opts.formatNoMatches, g.search.val()) + "</li>");
            },
            getMaxSearchWidth: function() {
                return this.selection.width() - t(this.search);
            },
            resizeSearch: function() {
                var a, b, c, d, e, f = t(this.search);
                a = C(this.search) + 10, b = this.search.offset().left, c = this.selection.width(), 
                d = this.selection.offset().left, e = c - (b - d) - f, a > e && (e = c - f), 40 > e && (e = c - f), 
                0 >= e && (e = a), this.search.width(Math.floor(e));
            },
            getVal: function() {
                var a;
                return this.select ? (a = this.select.val(), null === a ? [] : a) : (a = this.opts.element.val(), 
                s(a, this.opts.separator));
            },
            setVal: function(b) {
                var c;
                this.select ? this.select.val(b) : (c = [], a(b).each(function() {
                    p(this, c) < 0 && c.push(this);
                }), this.opts.element.val(0 === c.length ? "" : c.join(this.opts.separator)));
            },
            buildChangeDetails: function(a, b) {
                for (var b = b.slice(0), a = a.slice(0), c = 0; c < b.length; c++) for (var d = 0; d < a.length; d++) r(this.opts.id(b[c]), this.opts.id(a[d])) && (b.splice(c, 1), 
                c > 0 && c--, a.splice(d, 1), d--);
                return {
                    added: b,
                    removed: a
                };
            },
            val: function(c, d) {
                var e, f = this;
                if (0 === arguments.length) return this.getVal();
                if (e = this.data(), e.length || (e = []), !c && 0 !== c) return this.opts.element.val(""), 
                this.updateSelection([]), this.clearSearch(), void (d && this.triggerChange({
                    added: this.data(),
                    removed: e
                }));
                if (this.setVal(c), this.select) this.opts.initSelection(this.select, this.bind(this.updateSelection)), 
                d && this.triggerChange(this.buildChangeDetails(e, this.data())); else {
                    if (this.opts.initSelection === b) throw new Error("val() cannot be called if initSelection() is not defined");
                    this.opts.initSelection(this.opts.element, function(b) {
                        var c = a.map(b, f.id);
                        f.setVal(c), f.updateSelection(b), f.clearSearch(), d && f.triggerChange(f.buildChangeDetails(e, f.data()));
                    });
                }
                this.clearSearch();
            },
            onSortStart: function() {
                if (this.select) throw new Error("Sorting of elements is not supported when attached to <select>. Attach to <input type='hidden'/> instead.");
                this.search.width(0), this.searchContainer.hide();
            },
            onSortEnd: function() {
                var b = [], c = this;
                this.searchContainer.show(), this.searchContainer.appendTo(this.searchContainer.parent()), 
                this.resizeSearch(), this.selection.find(".select2-search-choice").each(function() {
                    b.push(c.opts.id(a(this).data("select2-data")));
                }), this.setVal(b), this.triggerChange();
            },
            data: function(b, c) {
                var e, f, d = this;
                return 0 === arguments.length ? this.selection.children(".select2-search-choice").map(function() {
                    return a(this).data("select2-data");
                }).get() : (f = this.data(), b || (b = []), e = a.map(b, function(a) {
                    return d.opts.id(a);
                }), this.setVal(e), this.updateSelection(b), this.clearSearch(), void (c && this.triggerChange(this.buildChangeDetails(f, this.data()))));
            }
        }), a.fn.select2 = function() {
            var d, e, f, g, h, c = Array.prototype.slice.call(arguments, 0), i = [ "val", "destroy", "opened", "open", "close", "focus", "isFocused", "container", "dropdown", "onSortStart", "onSortEnd", "enable", "disable", "readonly", "positionDropdown", "data", "search" ], j = [ "opened", "isFocused", "container", "dropdown" ], k = [ "val", "data" ], l = {
                search: "externalSearch"
            };
            return this.each(function() {
                if (0 === c.length || "object" == typeof c[0]) d = 0 === c.length ? {} : a.extend({}, c[0]), 
                d.element = a(this), "select" === d.element.get(0).tagName.toLowerCase() ? h = d.element.prop("multiple") : (h = d.multiple || !1, 
                "tags" in d && (d.multiple = h = !0)), e = h ? new window.Select2["class"].multi() : new window.Select2["class"].single(), 
                e.init(d); else {
                    if ("string" != typeof c[0]) throw "Invalid arguments to select2 plugin: " + c;
                    if (p(c[0], i) < 0) throw "Unknown method: " + c[0];
                    if (g = b, e = a(this).data("select2"), e === b) return;
                    if (f = c[0], "container" === f ? g = e.container : "dropdown" === f ? g = e.dropdown : (l[f] && (f = l[f]), 
                    g = e[f].apply(e, c.slice(1))), p(c[0], j) >= 0 || p(c[0], k) >= 0 && 1 == c.length) return !1;
                }
            }), g === b ? this : g;
        }, a.fn.select2.defaults = {
            width: "copy",
            loadMorePadding: 0,
            closeOnSelect: !0,
            openOnEnter: !0,
            containerCss: {},
            dropdownCss: {},
            containerCssClass: "",
            dropdownCssClass: "",
            formatResult: function(a, b, c, d) {
                var e = [];
                return E(a.text, c.term, e, d), e.join("");
            },
            formatSelection: function(a, c, d) {
                return a ? d(a.text) : b;
            },
            sortResults: function(a) {
                return a;
            },
            formatResultCssClass: function(a) {
                return a.css;
            },
            formatSelectionCssClass: function() {
                return b;
            },
            formatMatches: function(a) {
                return a + " results are available, use up and down arrow keys to navigate.";
            },
            formatNoMatches: function() {
                return "Nic nenalezeno";
            },
            formatInputTooShort: function(a, b) {
                var c = b - a.length;
                return "Zadejte alespo " + c + " znak" + (1 == c ? "" : "y");
            },
            formatInputTooLong: function(a, b) {
                var c = a.length - b;
                return "Please delete " + c + " character" + (1 == c ? "" : "s");
            },
            formatSelectionTooBig: function(a) {
                return "You can only select " + a + " item" + (1 == a ? "" : "s");
            },
            formatLoadMore: function() {
                return "Loading more results";
            },
            formatSearching: function() {
                return "Hledm";
            },
            minimumResultsForSearch: 0,
            minimumInputLength: 0,
            maximumInputLength: null,
            maximumSelectionSize: 0,
            id: function(a) {
                return a == b ? null : a.id;
            },
            matcher: function(a, b) {
                return o("" + b).toUpperCase().indexOf(o("" + a).toUpperCase()) >= 0;
            },
            separator: ",",
            tokenSeparators: [],
            tokenizer: M,
            escapeMarkup: F,
            blurOnChange: !1,
            selectOnBlur: !1,
            adaptContainerCssClass: function(a) {
                return a;
            },
            adaptDropdownCssClass: function() {
                return null;
            },
            nextSearchTerm: function() {
                return b;
            },
            searchInputPlaceholder: "",
            createSearchChoicePosition: "top",
            shouldFocusInput: function(a) {
                var b = "ontouchstart" in window || navigator.msMaxTouchPoints > 0;
                return b && a.opts.minimumResultsForSearch < 0 ? !1 : !0;
            }
        }, a.fn.select2.ajaxDefaults = {
            transport: a.ajax,
            params: {
                type: "GET",
                cache: !1,
                dataType: "json"
            }
        }, window.Select2 = {
            query: {
                ajax: G,
                local: H,
                tags: I
            },
            util: {
                debounce: w,
                markMatch: E,
                escapeMarkup: F,
                stripDiacritics: o
            },
            "class": {
                "abstract": d,
                single: e,
                multi: f
            }
        };
    }
}(jQuery), /**
 * Created by mk on 25.5.15.
 */
jQuery.fn.extend({
    // input element pro tagy - onLoad funkce
    dataTags: function() {
        var self = $(this), data = self.attr("data-tags"), object = {
            tags: data.split(","),
            tokenSeparators: [ "," ]
        };
        self.hasClass("onlyonevalue") && (object.maximumSelectionSize = 1), self.select2(object);
    }
}), function($) {
    $.fn.dateRange = function() {
        this.each(function() {
            var original = $(this);
            original.hide();
            var wrapper = original.parent(), values = original.val().split(/ [^0-9]*/), fromValue = values[0], toValue = values[1], fromTo = {
                from: fromValue,
                to: toValue
            };
            for (var key in fromTo) {
                var value = fromTo[key], input = $('<input type="text"></input>');
                input.addClass(original.attr("class"));
                var date = new Date(value);
                if (!isNaN(date)) {
                    var formatted = $.datepicker.formatDate($.datepicker._defaults.dateFormat, date);
                    input.val(formatted);
                }
                fromTo[key] = input;
                var inputWrapper = $("<div><span>" + original.attr("data-" + key + "-text") + "</span></div>");
                inputWrapper.append(input), wrapper.append(inputWrapper);
            }
            var from = fromTo.from, to = fromTo.to, joinSymbol = original.attr("data-join-symbol"), redrawOriginal = function() {
                var result = [];
                for (var key in fromTo) {
                    var value = fromTo[key].datetimepicker("getDate");
                    null === value || "string" == typeof value && "" === value.trim() ? result.push("") : result.push($.datepicker.formatDate("yy-mm-dd", value));
                }
                original.val(result.join(void 0 !== joinSymbol ? joinSymbol : " - "));
            };
            from.datepicker({
                onClose: function(dateText, inst) {
                    if ("" != to.val()) {
                        var testStartDate = from.datetimepicker("getDate"), testEndDate = to.datetimepicker("getDate");
                        null != testStartDate && testStartDate > testEndDate && to.datetimepicker("setDate", testStartDate);
                    } else to.val(dateText);
                    redrawOriginal();
                },
                onSelect: function(selectedDateTime) {
                    console.log(selectedDateTime), "" != from.val() && to.datetimepicker("option", "minDate", from.datetimepicker("getDate"));
                }
            }), to.datepicker({
                onClose: function(dateText, inst) {
                    if ("" != from.val()) {
                        var testStartDate = from.datetimepicker("getDate"), testEndDate = to.datetimepicker("getDate");
                        null != testEndDate && testStartDate > testEndDate && from.datetimepicker("setDate", testEndDate);
                    } else from.val(dateText);
                    redrawOriginal();
                },
                onSelect: function(selectedDateTime) {
                    "" != to.val() && from.datetimepicker("option", "maxDate", to.datetimepicker("getDate"));
                }
            });
        });
    };
}(jQuery);

/* 
 * Rozsireni datepicker filteru u Grido o posun datumu (zpet | dnes | dalsi)
 * - je postaven na miru Datepickeru
 * 
 * autor: Ondra Machala
 */
var fullDateFormat = function(d) {
    var month = d.getMonth() + 1 + "", date = d.getDate() + "", year = d.getFullYear();
    return 1 == month.length && (month = "0" + month), 1 == date.length && (date = "0" + date), 
    year + "-" + month + "-" + date;
}, dateSwitcher = function() {
    $(".dateinput-buttons[type=hidden]").each(function() {
        var hiddenInput = $(this), createInput = function(textValue) {
            return $("<input>").attr("type", "button").val(textValue);
        }, timeShift = function(dateValue, shift) {
            return new Date(dateValue.getTime() + shift);
        }, bindClick = function(element, date) {
            element.on("click", function(e) {
                hiddenInput.val(fullDateFormat(date)), submitForm();
            });
        }, submitForm = function() {
            var form = hiddenInput.closest("form");
            $(form.find("input[type=submit]")[0]).click();
        }, backButton = createInput(""), forButton = createInput(""), todayLink = createInput("dnes"), selectedDate = new Date(hiddenInput.val()), forDay = timeShift(selectedDate, 864e5), backDay = timeShift(selectedDate, -864e5), today = new Date();
        bindClick(forButton, forDay), bindClick(backButton, backDay), bindClick(todayLink, today);
        var visibleInput = hiddenInput.parent().find(".hasDatepicker");
        hiddenInput.before(backButton).before(todayLink).after(forButton), visibleInput.on("change", function() {
            submitForm();
        });
    });
};

$(document).ready(function() {
    $("[data-handle-link]").gridoEditable();
}), $(function() {
    $.datepicker.regional.cs = {
        closeText: "Hotovo",
        prevText: "Pedchoz",
        nextText: "Dal",
        currentText: "Dnes",
        monthNames: [ "Leden", "nor", "Bezen", "Duben", "Kvten", "erven", "ervenec", "Srpen", "Z", "jen", "Listopad", "Prosinec" ],
        monthNamesShort: [ "Led", "no", "Be", "Dub", "Kv", "er", "ec", "Srp", "Z", "j", "Lis", "Pro" ],
        dayNames: [ "Nedle", "Pondl", "ter", "Steda", "tvrtek", "Ptek", "Sobota" ],
        dayNamesShort: [ "Ned", "Pon", "te", "St", "tv", "Pt", "Sob" ],
        dayNamesMin: [ "Ne", "Po", "t", "St", "t", "P", "So" ],
        weekHeader: "T",
        dateFormat: "dd.mm.yy",
        firstDay: 1,
        isRTL: !1,
        showMonthAfterYear: !1,
        yearSuffix: ""
    }, $.datepicker.setDefaults($.datepicker.regional.cs), $.timepicker.regional.cs = {
        currentText: "Nyn",
        closeText: "Hotovo",
        amNames: [ "AM", "A" ],
        pmNames: [ "PM", "P" ],
        timeFormat: "HH:mm:ss",
        timeSuffix: "",
        timeOnlyTitle: "Vyberte as",
        timeText: "as",
        hourText: "Hodina",
        minuteText: "Minuta",
        secondText: "Sekunda",
        millisecText: "Milisekunda",
        microsecText: "Mikrosekunda",
        timezoneText: "asov zna",
        isRTL: !1
    }, $.timepicker.setDefaults($.timepicker.regional.cs);
    var myControl = {
        create: function(tp_inst, obj, unit, val, min, max, step) {
            return $('<input class="ui-timepicker-input" value="' + val + '" style="width:50%">').appendTo(obj).spinner({
                min: min,
                max: max,
                step: step,
                change: function(e, ui) {
                    // key events
                    // don't call if api was used and not key press
                    void 0 !== e.originalEvent && tp_inst._onTimeChange(), tp_inst._onSelectHandler();
                },
                spin: function(e, ui) {
                    // spin events
                    tp_inst.control.value(tp_inst, obj, unit, ui.value), tp_inst._onTimeChange(), tp_inst._onSelectHandler();
                }
            }), obj;
        },
        options: function(tp_inst, obj, unit, opts, val) {
            return "string" == typeof opts && void 0 !== val ? obj.find(".ui-timepicker-input").spinner(opts, val) : obj.find(".ui-timepicker-input").spinner(opts);
        },
        value: function(tp_inst, obj, unit, val) {
            return void 0 !== val ? obj.find(".ui-timepicker-input").spinner("value", val) : obj.find(".ui-timepicker-input").spinner("value");
        }
    };
    $.timepicker.setDefaults({
        controlType: myControl
    }), $("#content a#saveandback").click(function() {
        return $(this).hasClass("callPostBeforeSave") && "undefined" != typeof postEdit && postEdit.BeforeSave(), 
        $('#content input[name="save"]').trigger("click"), !1;
    });
    var makeDateInput = function(object) {
        object.dateinput({
            datetime: {
                dateFormat: "d.m.yy",
                timeFormat: "H:mm:ss",
                options: {
                    changeYear: !0
                }
            },
            "datetime-local": {
                dateFormat: "d.m.yy",
                timeFormat: "H:mm:ss"
            },
            date: {
                dateFormat: "d.m.yy"
            },
            month: {
                dateFormat: "MM yy"
            },
            week: {
                dateFormat: "w. 'week of' yy"
            },
            time: {
                timeFormat: "H:mm:ss"
            }
        });
    }, jsControls = function() {
        $("select.select2:not(.select2-offscreen)").select2(), makeDateInput($("input[data-dateinput-type]")), 
        $("input.daterange").dateRange();
    };
    jsControls(), $.nette.ext("jsControls", {
        success: jsControls
    }), $.nette.init(), $("#content").on("change", "input.change-submit, select.change-submit", function(e) {
        $(this).closest("form").submit();
    }), $("#content").on("change", "input.change-ajax-submit, select.change-ajax-submit", function(e) {
        var self = $(this), form = self.closest("form");
        form.netteAjax(e);
    }), $("#content").on("change", "input.change-ajax-submit-click, select.change-ajax-submit-click", function(e) {
        var self = $(this), form = self.closest("form");
        form.find("input[type=submit]").click();
    }), $("[custom-confirm]").click(function() {
        var self = $(this), message = self.attr("custom-confirm");
        return confirm(message);
    }), $("#content").on("click", "a.ajax-click", function(e) {
        var self = $(this), form = self.closest("form");
        form.netteAjax(e);
    }), /**
	 * Modul Admin:Article:Article:edit
	 */
    $(document).on("click", "#content a.opencloseBlock", function() {
        var self = $(this), target = self.next("#content div.openableBlock");
        return self.hasClass("closed") ? target.slideDown(function() {
            self.text(self.data("texthide"));
        }) : target.slideUp(function() {
            self.text(self.data("textshow"));
        }), self.toggleClass("closed"), !1;
    }), $(".grido tr.forPageMove").hover(function() {
        $(".pageMoveIconsWrapper", $(this)).css({
            visibility: "visible"
        });
    }, function() {
        $(".pageMoveIconsWrapper", $(this)).css({
            visibility: "hidden"
        });
    }), $("#content input[data-tags]").each(function() {
        $(this).dataTags();
    });
    $("body").on("mousemove", "img.zoomable", function(event) {
        var div = $("#editorZoom"), img = $("#editorZoomImg"), span = $("#editorZoomText"), source = $(this), textDivider = source.data("text").length && source.data("size").length ? "/" : "";
        img.hide(), div.css("left", event.pageX + 64), div.css("top", event.pageY - div.outerWidth() / 2), 
        span.text(source.data("text") + textDivider + source.data("size")), img.attr("src", "/min.php?file=" + source.data("big") + "&w=400&h=400"), 
        img.show(), div.show();
    }).mouseout(function() {
        $("#editorZoom").hide();
    }), /**
	 * Admin:Article:edit
	 */
    $(document).on("click", "#addMainPhoto", function() {
        return fromTinyMce = !1, $("#photo-picker-wrapper").modal("show"), photoPickerObject.FocusSearchField(), 
        !1;
    }), /**
	 * Admin:Article:edit
	 */
    $(document).on("click", "#deleteMainPhoto", function() {
        return $("#mainPhotoHidden").removeAttr("value"), $("#deleteMainPhoto").hide(), 
        $("#mainPhotoWrapper").hide(), !1;
    }), /**
	 * Pro button upload file, ze ablony uploadFormGroup
	 */
    $(".upload-file input").change(function() {
        $(this).closest(".form-group").find(".upload-file-name").text($(this).val());
    });
}), /**
 * Created by mk on 26.5.15.
 */
$(function() {
    $("#photo-picker-wrapper").on("shown.bs.modal", function(e) {
        $(e.relatedTarget).addClass("activeButton"), $(this).attr("data-photo-hidden", $(e.relatedTarget).data("photo-hidden")), 
        //kam se vlozi id fotky - nadazen formul
        $(this).attr("data-thumbnail", $(e.relatedTarget).data("thumbnail"));
    }).on("hide.bs.modal", function() {
        $("button").removeClass("activeButton");
    });
}), /**
 * Funkcionalita pro photoUploadForm
 * Created by mk on 25.5.15.
 */
$.nette.ext("photoUploadAjax", {
    load: function() {
        $(".photoUploadAjax").off("submit.photoUploadAjax").on("submit.photoUploadAjax", function(e) {
            var modal = $("#photoUploadModal"), mainPhotoId = "", thumbnailId = "";
            $(this).netteAjax(e, {
                beforeSend: function() {
                    mainPhotoId = "#" + $("button.activeButton").data("photo-hidden"), thumbnailId = "#" + $("button.activeButton").data("thumbnail");
                }
            }).done(function(payload) {
                if (payload.id) {
                    $(mainPhotoId).attr("value", payload.id);
                    var img = $(thumbnailId);
                    img.attr("src", payload.img.src), img.data("big", payload.img.srcBig), $(thumbnailId).closest(".form-group").show(), 
                    modal.modal("hide");
                }
            });
        });
    }
}), $(function() {
    $("#photoUploadModal").on("hide.bs.modal", function() {
        $("button").removeClass("activeButton");
    }).on("show.bs.modal", function(e) {
        var modal = $(this);
        $(e.relatedTarget).addClass("activeButton"), modal.attr("data-photo-hidden", $(e.relatedTarget).data("photo-hidden")), 
        //kam se vlozi id fotky - nadazen formul
        modal.attr("data-thumbnail", $(e.relatedTarget).data("thumbnail"));
    }).on("shown.bs.modal", function(e) {
        $("#photoUploadModal input[data-tags]").each(function() {
            $(this).dataTags();
        });
        var imageStringId = $(e.relatedTarget).data("image"), imageNameId = $(e.relatedTarget).data("name"), photoId = $(e.relatedTarget).data("upload"), fillFormFields = function(imageString, imageName) {
            document.getElementById(imageStringId).value = imageString, document.getElementById(imageNameId).value = imageName;
        }, control = document.getElementById(photoId);
        control.addEventListener("change", function(event) {
            var file = control.files[0], imageType = /image.*/;
            if (file.type.match(imageType)) {
                var reader = new FileReader();
                reader.onload = function(event) {
                    fillFormFields(event.target.result, control.files[0].name);
                }, reader.onerror = function(event) {
                    console.error("File could not be read! Code " + event.target.error.code);
                }, reader.readAsDataURL(control.files[0]);
            } else fillFormFields("", "");
        }, !1);
    });
});

/**
 * Created by mk on 10.8.15.
 */
/*jslint browser: true*/
/*global $, jQuery*/
var randomString = function(length) {
    "use strict";
    for (var text = "", possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", i = 0; length > i; i++) text += possible.charAt(Math.floor(Math.random() * possible.length));
    return text;
}, createReplaceFunction = function(templateObj, appendObj, callback) {
    "use strict";
    return function() {
        var text = templateObj.html();
        text = text.replace(/replacelabel/gi, "label"), text = text.replace(/replaceinput/gi, "input"), 
        text = text.replace(/replaceid/gi, "new" + randomString(8));
        var html = $(text);
        return void 0 !== callback && (html = callback(html)), appendObj.append(html), !1;
    };
};

/**
 * Funcionalita tlatka pro vbr vech prvk v select2
 * Created by mk on 1.7.15.
 */
/*jslint browser: true*/
/*global $, jQuery*/
$(function() {
    "use strict";
    $(document).on("click", ".select2-all", function() {
        var select = $(this).closest(".form-group").find("select");
        select.find("option").prop("selected", "selected"), select.trigger("change"), $(this).addClass("active");
    });
}), /**
 * Funcionalita tlatka pro reset multiselectu, kde je povolen jen jeden prvek
 * Created by mk on 13.10.15.
 */
/*jslint browser: true*/
/*global $, jQuery*/
$(function() {
    "use strict";
    $(document).on("click", ".select2-clear", function() {
        var parent = $(this).closest(".form-group"), select = parent.find(".select2-chosen");
        parent.find('input[type="hidden"]').val(""), select.html(""), select.trigger("change");
    });
}), /* 
 * Implementace Jquery.InputMask-3.x na textovy input
 * - vytvori input pro mm:ss, prepocte sekundovy cas a vlozi
 * - puvodni input skyje a pri kazde zmene aktualizuje
 * 
 * autor: Ondra Machala
 */
$.fn.timeInput = function() {
    // className of included input (with mask)
    var inputClassName = "input-time-mask", inputSelector = this.selector.replace(".", ""), maskTimeToInt = function(text) {
        var parse = function(string) {
            return "undefined" == typeof string ? 0 : parseInt(string.replace("_", "")) || 0;
        }, parts = text.split(":"), minutes = parse(parts[0]), seconds = parse(parts[1]);
        return 60 * minutes + seconds;
    }, intToTimeMask = function(text) {
        if (!text.length || parseInt(text) <= 0) return "";
        var timeReadable = function(t) {
            return ("0" + Math.floor(t / 60)).slice(-2) + ("0" + t % 60).slice(-2);
        };
        return timeReadable(parseInt(text));
    };
    this.each(function() {
        var element = $(this), name = element.attr("name"), classes = inputClassName + " " + element.attr("class").replace(inputSelector, "");
        element.hide(), $(this).after($("<input>").attr({
            type: "text",
            "data-target": name,
            "class": classes
        }));
        var value = this.value, mask = intToTimeMask(value);
        $('input[data-target="' + name + '"]').val(mask);
    }), $("." + inputClassName).keyup(function() {
        var target = $(this).attr("data-target"), seconds = maskTimeToInt(this.value);
        $('input[name="' + target + '"]').val(seconds);
    }), $("." + inputClassName).inputmask("99:99");
}, $(document).ready(function() {
    var whisperInit = function() {
        $("[data-whisper-multiselect]").each(function() {
            url = $(this).attr("data-whisper-multiselect"), $(this).select2({
                minimumInputLength: 2,
                tags: [],
                dropdownAutoWidth: !0,
                ajax: {
                    url: url,
                    dataType: "json",
                    type: "GET",
                    quietMillis: 20,
                    data: function(term) {
                        return {
                            term: term
                        };
                    },
                    results: function(data) {
                        return {
                            results: $.map(data, function(item) {
                                return {
                                    text: item.text,
                                    id: item.id
                                };
                            })
                        };
                    }
                },
                initSelection: function(element, callback) {
                    var ids = $(element).val();
                    "" != ids && $.ajax(url, {
                        data: {
                            ids: ids
                        },
                        dataType: "json"
                    }).done(function(data) {
                        callback(data);
                    });
                }
            });
        }), $("[data-whisper-select]").each(function() {
            url = $(this).attr("data-whisper-select"), $(this).select2({
                minimumInputLength: 2,
                dropdownAutoWidth: !0,
                ajax: {
                    url: url,
                    dataType: "json",
                    type: "GET",
                    quietMillis: 20,
                    data: function(term) {
                        return {
                            term: term
                        };
                    },
                    results: function(data) {
                        return {
                            results: $.map(data, function(item) {
                                return {
                                    text: item.text,
                                    id: item.id
                                };
                            })
                        };
                    }
                },
                initSelection: function(element, callback) {
                    var ids = $(element).val();
                    "" != ids && $.ajax(url, {
                        data: {
                            ids: ids
                        },
                        dataType: "json"
                    }).done(function(data) {
                        callback(data[0]);
                    });
                }
            });
        });
    };
    whisperInit(), $.nette.ext("whisperInit", {
        success: whisperInit
    });
});